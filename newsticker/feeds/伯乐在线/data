;; -*- coding: utf-8 -*-
(("文章 – 伯乐在线" nil "http://blog.jobbole.com" (22433 31814 167143 0) feed 0 nil nil ((title nil "文章 – 伯乐在线") (atom:link ((href . "http://blog.jobbole.com/feed/") (rel . "self") (type . "application/rss+xml"))) (link nil "http://blog.jobbole.com") (description nil) (lastBuildDate nil "Tue, 02 Aug 2016 12:48:24 +0000") (language nil "zh-CN") (sy:updatePeriod nil "hourly") (sy:updateFrequency nil "1") (generator nil "https://wordpress.org/?v=4.5.3") (item nil (title nil "编写高质量代码") (link nil "http://blog.jobbole.com/104080/") (comments nil "http://blog.jobbole.com/104080/#respond") (pubDate nil "Tue, 02 Aug 2016 02:10:03 +0000") (dc:creator nil "ABOER") (category nil "IT技术") (category nil "C++") (guid ((isPermaLink . "false")) "http://blog.jobbole.com/?p=104080") (description nil "<p>本文介绍如何编写高质量的C++代码。从微观角度，以一个实际的例子，从正确、高效、易读等特性着手，介绍如何编写高质量的代码。从宏观出发，从软件开发流程入手，着重介绍其中的几个方面，包括代码规范、Code Review、测试等。</p><p><a href=\"http://blog.jobbole.com/104080/\">编写高质量代码</a>，首发于<a href=\"http://blog.jobbole.com\">文章 - 伯乐在线</a>。</p>") (content:encoded nil "<p style=\"text-align: justify\">我们知道，<strong>int</strong>和<strong>double</strong>能表示的数值的范围不同。其中，<strong>64</strong>位有符号整数的范围是[<strong>-9223372036854775808</strong>,<strong>9223372036854775807</strong>]，而<strong>64</strong>位无符号整数的范围是[<strong>0</strong>,<strong>18446744073709551615</strong>]。这两个区间有一定的<strong>overlap</strong>，而<strong>double</strong>可以表示的范围更大。</p><p style=\"text-align: justify\">现在，需要编写两个函数:给定一个<strong>double</strong>型的<strong>value</strong>，判断这个<strong>value</strong>是否是一个合法的<strong>int64_t</strong>或者<strong>uint64_t</strong>。本文说的“合法”，是指数值上落在了范围内。</p><p></p><pre class=\"crayon-plain-tag\">bool is_valid_uint64(const Double &amp;value);

bool is_valid_int64(const Double &amp;value);</pre><p></p><p style=\"text-align: justify\">这里我们用<strong>Double</strong>而不是<strong>double</strong>，原因是我们的<strong>double</strong>不是基础数据类型，而是通过一定方法实现的<strong>ADT</strong>，这个<strong>ADT</strong>的成员函数有：</p><p></p><pre class=\"crayon-plain-tag\">class Double
{
  public:
    int get_next_digit(bool &amp;is_decimal);
    bool is_zero();
    bool is_neg();
};</pre><p></p><p style=\"text-align: justify\">通过调用<code>get_next_digit</code>，可以返回一个数字，不断调用它，可以得到所有<strong>digits</strong>。举个例子，对于值为<strong>45.67</strong>的一个<strong>Double</strong>对象，调用它的<code>get_next_digit</code>成员函数将依次得到</p><p style=\"text-align: justify\">4 is_decimal = false //表示整数部分</p><p style=\"text-align: justify\">5 is_decimal = false //表示整数部分</p><p style=\"text-align: justify\">6 is_decimal = true //表示小数部分</p><p style=\"text-align: justify\">7 is_decimal = true //表示小数部分</p><p style=\"text-align: justify\">当<code>get_next_digit</code>返回<strong>-1</strong>时，表示读取完毕。</p><p style=\"text-align: justify\">如何利用<strong>Double</strong>类里的成员函数，来实现<code>is_valid_uint64</code>和<code>is_valid_int64</code>这两个函数呢？</p><p style=\"text-align: justify\">一些新手可能会写这样的代码：</p><p></p><pre class=\"crayon-plain-tag\">bool is_valid_uint64(const Double &amp;value)
{
  bool is_valid = true;
  int digits[2000];
  int counts = 0;
  if (value.is_zero()) {
    is_valid = true;
  } else if(value.is_neg()) {
    is_valid = false;
  } else {
    bool is_decimal = false;
    int digit = 0;
    while((digit=value.get_next_digit(is_decimal)) != -1) {
      if (is_decimal) {
        is_valid = false;
        break;
      } else {
        digits[counts++] = digit;
      }
    }
    uint64_t tmp = 0;
    uint64_t base = 1;
    for (int i = counts - 1; i &gt;= 0; i++) {
      tmp += digits[i] * base;
      if (tmp &gt; UINT64_MAX) {
        is_valid = false;
        break;
      }
      base *= 10;
    }
  }
  return is_valid;
}
bool is_valid_int64(const Double &amp;value)
{
  bool is_valid = true;
  int digits[2000];
  int counts = 0;
  if (value.is_zero()) {
    is_valid = true;
  } else if(value.is_neg()) {
    bool is_decimal = false;
    int digit = 0;
    while((digit=value.get_next_digit(is_decimal)) != -1) {
      if (is_decimal) {
        is_valid = false;
        break;
      } else {
        digits[counts++] = digit;
      }
    }
    uint64_t tmp = 0;
    uint64_t base = 1;
    for (int i = counts - 1; i &gt;= 0; i++) {
      tmp += digits[i] * base;
      tmp *= -1;
      if (tmp  INT64_MIN) {
        is_valid = false;
        break;
      }
      base *= 10;
    }
  } else {
    bool is_decimal = false;
    int digit = 0;
    while((digit=value.get_next_digit(is_decimal)) != -1) {
      if (is_decimal) {
        is_valid = false;
        break;
      } else {
        digits[counts++] = digit;
      }
    }
    uint64_t tmp = 0;
    uint64_t base = 1;
    for (int i = counts - 1; i &gt;= 0; i++) {
      tmp += digits[i] * base;
      if (tmp &gt; INT64_MAX) {
        is_valid = false;
        break;
      }
      base *= 10;
    }
  }
  return is_valid;
}</pre><p></p><p style=\"text-align: justify\">这样的代码，存在诸多问题。</p><h2 id=\"section\" style=\"text-align: justify\">设计问题</h2><p style=\"text-align: justify\">不难发现，两个函数存在很多相似甚至相同的代码；而同一个函数内部，也有不少代码重复。重复的东西往往不是好的。重构？</p><h2 id=\"section-1\" style=\"text-align: justify\">性能问题</h2><p style=\"text-align: justify\">先获得所有digits，然后从最低位开始向最高位构造值，效率较低。难道没有可以从最高位开始，边获得边计算，不需要临时数组存储所有digits的方法吗？</p><h2 id=\"section-2\" style=\"text-align: justify\">正确性问题</h2><p style=\"text-align: justify\">随便举几个例子：</p><p style=\"text-align: justify\">第<strong>24</strong>行，<code>tmp += digits[i] * base</code>;有没有考虑到可能的溢出呢？</p><p style=\"text-align: justify\">第<strong>68</strong>行，难道有小数部分就一定不是合法的<strong>int64</strong>吗？那么，<strong>123.000</strong>？嗯？</p><h2 id=\"section-3\" style=\"text-align: justify\">规范问题</h2><p style=\"text-align: justify\">帅哥，这么多代码，一行注释都没有，这样真的好吗？</p><p style=\"text-align: justify\">因此，毫无疑问，这是烂代码，不合格的代码，需要重写的代码。</p><p style=\"text-align: justify\">以下是我个人认为比较好的设计和实现，仅供参考。</p><p></p><pre class=\"crayon-plain-tag\">bool is_valid_uint64(const Double &amp;value)

{

  bool ret = false;

  check_range(value, &amp;ret, NULL);

  return ret;

}



bool is_valid_int64(const Double &amp;value)

{

  bool ret = false;

  check_range(value, NULL, &amp;ret);

  return ret;

}



void check_range(const Double &amp;value,

                 bool *is_valid_uint64,

                 bool *is_valid_int64) const

{

  /*

   * 对于一个负数的value，它不可能是一个合法的uint64.

   * 因此，只剩下三种可能：

   * I 输入的value是负数，判断是否是合法的int64

   * II 输入的value是正数，判断是否是合法的uint64

   * III 输入的value是正数，判断是否是合法的int64

   * 对于第II、III这两种情况：只要判断value的值是否超过uint64、int64的上界即可

   * 对于第I种情况，我们利用-A &gt; -B 等价于 A 

   * 因此，在第I种情况里，可以判断value的绝对值，是否超过int64的最小值的绝对值即可。

   * （int64的最小值的绝对值？那不就是int64的最大值？哦，不！）

   * 因此，不管哪种情况，判断绝对值是否超过某个上界即可。

   * 这三种情况，上界不一样。把三个上界存到了一个二维数组THRESHOLD里

  */



  bool *is_valid = NULL;

  static const int FLAG_INT64 = 0;

  static const int FLAG_UINT64 = 1;

  static const int SIGN_NEG = 0;

  static const int SIGN_POS = 1;

  int flag = FLAG_INT64;

  if (NULL != is_valid_uint64) {

    is_valid = is_valid_uint64;

    flag = FLAG_UINT64;

  } else {

    is_valid = is_valid_int64;

  }

  *is_valid = true;

  if (value.is_zero()) {

    //do nothing。0是合法的uint64，也是合法的int64

  } else {

    int sign = value.is_neg() ? SIGN_NEG : SIGN_POS;

    if ((SIGN_NEG == sign) &amp;&amp; (FLAG_UINT64 == flag)) {

      *is_valid = false;//负数不可能是合法的uint64

    } else {

      uint64_t valueUint = 0;

      static uint64_t ABS_INT64_MIN = 9223372036854775808ULL;

                                         //int64        uint64

      static uint64_t THRESHOLD[2][2] = { {ABS_INT64_MIN, 0}, //neg

                                         {INT64_MAX,     UINT64_MAX} }; //pos

      int digit = 0;

      bool is_decimal = false;

      while ((digit = value.get_next_digit(is_decimal)) != -1) {

        if (!is_decimal) {

          //为了防止溢出，我们不能这么写:

          //\"value * 10 + digit &gt; THRESHOLD[index]\"

          if (valueUint &gt; (THRESHOLD[sign][flag] - digit) / 10) {

            *is_valid = false;

            break;

          } else {

            valueUint = valueUint * 10 + digit;//霍纳法则（也叫秦九韶算法）

          }

        } else {

          if (!digit) {

            *is_valid = false; //小数部分必须是0；否则不可能是合法的uint64、int64

            break;

          }

        }

      }

    }

  }

}</pre><p></p><h2 id=\"section\" style=\"text-align: justify\">代码规范</h2><p style=\"text-align: justify\">团队的代码规范，一般由领导和大佬们制定后，大家统一实行。这里面有几个问题：</p><h3 id=\"section-1\" style=\"text-align: justify\">真的需要代码规范吗？</h3><p style=\"text-align: justify\">言下之意，制定和执行代码规范是否浪费时间？</p><p style=\"text-align: justify\">答案是：It depends。如果项目很庞大、代码质量要求很高，那么，制定和执行代码规范所花费的时间，将大大少于后期因为不规范开发带来的种种调试和维护成本。如果是小打小闹的代码，就无所谓了。</p><h3 id=\"section-2\" style=\"text-align: justify\">代码规范的制定为什么这么难？</h3><p style=\"text-align: justify\">原因众多，其中一个很重要的部分是团队每个人的口味和观点不尽相同。就代码风格而言，有人喜欢对内置类型变量i使用i++，有人坚持认为应该使用++i不管i是不是复杂类型。因此，制定代码规范需要在讨论之后最后拍板决定，这里面甚至需要独裁！是的，独裁！</p><h3 id=\"section-3\" style=\"text-align: justify\">代码规范制定需要注意什么事项？</h3><p style=\"text-align: justify\">如果代码规范限制太松，那么等于没有规范；如果太严，大大影响开发效率。这里面的尺度，需要根据项目需要、团队成员特点全面考量，进行取舍。</p><p style=\"text-align: justify\">需要注意的是，没有任何一种代码规范是完美的。例如，在C++中，如果启用异常，那么代码的流程将会被各种异常处理中断，各种try catch throw让代码很不美观；如果禁用异常，也就是在开发的过程中不能使用异常特性，那么团队成员可能因为长期没有接触这项语言feature而造成知识和技能短板。</p><h3 id=\"section-4\" style=\"text-align: justify\">代码风格举例</h3><p style=\"text-align: justify\">举两个我认为比较重要、比较新鲜、比较有趣的代码风格。</p><p style=\"text-align: justify\">1，使用引用需要判空吗？</p><p></p><pre class=\"crayon-plain-tag\">void f(int &amp;p);
void g(int *p);</pre><p></p><p style=\"text-align: justify\">我们都知道，在g中，使用*p前需要对p是否为NULL进行判断，那么f呢？如果质量非常关键、代码安全非常重要的场景，那么实际上，也是需要的。因为调用者可能这样：</p><p></p><pre class=\"crayon-plain-tag\">int *q = NULL;
//......
f(*q);</pre><p></p><p style=\"text-align: justify\">因此，需要在f里增加<code>if(NULL == &amp;p)</code>的判断。</p><p style=\"text-align: justify\">2，级联if else语句。</p><p style=\"text-align: justify\">首先看一个我个人认为不好的代码风格：</p><p></p><pre class=\"crayon-plain-tag\">int f(int a, int b)
{
  if (a &gt;= 1) {
    if (b &gt;= 1) {
      if (a &gt;= b) {
        //do sth
      } else {
        //error1
      }
    } else {
      //error2
    }
  } else {
    //error3
  }
}</pre><p></p><p style=\"text-align: justify\">这个函数的核心在于do sth部分。其实我们可以改写为级联if－else形式，如下：</p><p></p><pre class=\"crayon-plain-tag\">int f(int a, int b)
{
  if (a &lt; 1) {
    //error3
  } else if (b &lt; 1) {
    //error2
  } else if (a &lt; b) {
    //error1
  } else {
    //so, a&gt;=1 &amp;&amp; b&gt;=1 &amp;&amp; a&gt;=b
    //do sth
  }
}</pre><p></p><p style=\"text-align: justify\">是不是优美多了？前面只做一些错误处理、前期准备、参数检查等，最后的else分支做实实在在的功能性事情。</p><h2 id=\"code-review\" style=\"text-align: justify\">Code Review</h2><h3 id=\"code-review-1\" style=\"text-align: justify\">什么是Code Review？</h3><p style=\"text-align: justify\">很多人把它翻译为代码审查，我觉得太政治味了。程序员尤其是新手写完代码后，可能会有风格问题（比如不符合团队的代码规范）、安全性问题(比如忘记指针判空)、优雅性问题(比如大量冗余代码)、正确性问题（比如算法设计错误），那么在发布代码到公共库之前，提交给师兄或者mentor，让他帮你review一下代码，并提出可能的问题和建议，让你好好修改。这样的过程，就叫做Code Review。</p><h3 id=\"section-5\" style=\"text-align: justify\">我的天呐，那这不是很占用时间？</h3><p style=\"text-align: justify\">是的。一个写代码，一个看代码，看代码的时间可能并不比全新写一份代码少。那么，这又是何必呢？</p><p style=\"text-align: justify\">主要的原因有：</p><p style=\"text-align: justify\">1，review确实占用了开发时间，然而开发，或者说写代码，其实只占很少的时间比例。很多时间花在debug、调试、写文档、需求分析、设计算法、维护等等上。</p><p style=\"text-align: justify\">2，代码质量非常重要，这点时间投入是值得的。与其后期苦逼追bug，不如前期多投入点时间和人力。</p><p style=\"text-align: justify\">3，培养新人，让新手更快成长。</p><h3 id=\"code-review-2\" style=\"text-align: justify\">如何更好的执行Code Review</h3><p style=\"text-align: justify\">这里给几点建议：</p><p style=\"text-align: justify\">1，不走过场。走过场，还不如不要这个流程。</p><p style=\"text-align: justify\">2，作为Reviewer，看不懂代码就把作者拉过来，当面询问，不要不懂装懂，也不要爱面子不好意思问。</p><p style=\"text-align: justify\">3，作为Coder，心里要有感激之情。真的。不要得了便宜还卖乖，感恩reviewer，感激reviewer对自己的进步和成长所做出的贡献，所花费的心血。中国人里狼心狗肺、忘恩负义、不懂感恩的人还算少吗？</p><p style=\"text-align: justify\">4，作为Coder，给Reviewer Review之前，请先做单元测试并确保通过，并自己尝试先整体看一遍自己本次提交的代码。注意，不要给别人提还没调试通过的代码，这是非常不尊重别人的表现。</p><h2 id=\"section-6\" style=\"text-align: justify\">质量保证</h2><p style=\"text-align: justify\">1，测试不是专属QA的活儿，对自己写的代码提供质量保证，是程序员的职责。QA要负责的，是系统的质量，不是模块的质量。</p><p style=\"text-align: justify\">2，测试，需要意识，需要坚持。我发现C++程序员、前端程序员的测试意识或者说质量意识最强；数据科学家或者数据工程师的质量意识最差，很多人甚至不写测试用例。当然，这不怪他们，毕竟，有时候代码里有个bug，准确率和召回率会更高。</p><p style=\"text-align: justify\">3，测试用例的编写和设计需要保证一定的代码覆盖率，力求让每个分支和流程的代码都走到，然后分析运行结果是否是符合期望的，不要只考虑正确路径上的那些分支。</p><p style=\"text-align: justify\">4，测试用例的编写和设计力求全面，考虑到方方面面。以非常经典的二分搜索为例：</p><p style=\"text-align: justify\">int binary_search(int *p, int n, int target, int &amp;idx);</p><p style=\"text-align: justify\">binary_search函数返回值为0表示成功执行，输出参数idx返回target在有序数组p中(第一次出现)的位置，－1表示不存在。</p><p style=\"text-align: justify\">那么测试用例至少应该涵盖：</p><ul style=\"text-align: justify\"><li>p为NULL的情况</li><li>数组大小n分别为负数、0、1、2时情况</li><li>数组p不是有序数组的情况</li><li>target在数组中出现0次、1次、n次的情况</li></ul><p style=\"text-align: justify\">你是否都考虑到了呢？</p><p style=\"text-align: justify\">4，有时候，自己书写测试用例显得刀耕火种，现在已经有很多辅助的工具，读者可以自行google一下。</p><div class=\"wp_rp_wrap  wp_rp_plain\" id=\"wp_rp_first\"><div class=\"wp_rp_content\"><h3 class=\"related_post_title\">相关文章</h3><ul class=\"related_post wp_rp\" style=\"visibility: visible\"><li ><a href=\"http://blog.jobbole.com/104042/\" class=\"wp_rp_title\">如何在 Linux 下检测内存泄漏</a></li><li ><a href=\"http://blog.jobbole.com/103102/\" class=\"wp_rp_title\">C++虚表，你搞懂了吗？</a></li><li ><a href=\"http://blog.jobbole.com/93699/\" class=\"wp_rp_title\">趣文：C++ 程序员离职之前要做的事</a></li><li ><a href=\"http://blog.jobbole.com/88050/\" class=\"wp_rp_title\">Notepad++源码编译及其分析</a></li><li ><a href=\"http://blog.jobbole.com/103669/\" class=\"wp_rp_title\">C++11 中的 Defaulted 和 Deleted 函数</a></li><li ><a href=\"http://blog.jobbole.com/36088/\" class=\"wp_rp_title\">你可能不知道的陷阱：C#委托和事件的困惑</a></li><li ><a href=\"http://blog.jobbole.com/87586/\" class=\"wp_rp_title\">标准模板库（STL）使用入门（上）</a></li><li ><a href=\"http://blog.jobbole.com/101441/\" class=\"wp_rp_title\">漫谈 C++：良好的编程习惯与编程要点</a></li><li ><a href=\"http://blog.jobbole.com/83497/\" class=\"wp_rp_title\">在C++中实现Python的切片</a></li><li ><a href=\"http://blog.jobbole.com/82628/\" class=\"wp_rp_title\">C++之父：C++ 的五个普遍误解（3）</a></li></ul></div></div><p><a href=\"http://blog.jobbole.com/104080/\">编写高质量代码</a>，首发于<a href=\"http://blog.jobbole.com\">文章 - 伯乐在线</a>。</p>") (wfw:commentRss nil "http://blog.jobbole.com/104080/feed/") (slash:comments nil "0")) (item nil (title nil "NASA 的 10 大编程规则") (link nil "http://blog.jobbole.com/104016/") (comments nil "http://blog.jobbole.com/104016/#comments") (pubDate nil "Mon, 01 Aug 2016 16:04:09 +0000") (dc:creator nil "西西里的仔仔") (category nil "开发") (category nil "NASA") (category nil "编程") (guid ((isPermaLink . "false")) "http://blog.jobbole.com/?p=104016") (description nil "<p>那些为 NASA 工作的世界顶级程序员，在开发安全关键代码的时候遵守着一套准则。它们就像车里的安全带：刚开始用会有点不舒服，但是过了一段时间就会成为一种习惯，你会无法想象不使用它们的日子。</p><p><a href=\"http://blog.jobbole.com/104016/\">NASA 的 10 大编程规则</a>，首发于<a href=\"http://blog.jobbole.com\">文章 - 伯乐在线</a>。</p>") (content:encoded nil "<p>大型复杂的软件项目会使用某种编程标准或准则。这些准则组成了软件编写的基本规则。</p><ul><li>代码应该如何组织？</li><li>应该以及不应该使用哪些语言特征？</li></ul><p>为了确保有效，这些规则要简短并且足够具体，以便理解和记忆。</p><p>那些为 NASA 工作的世界顶级程序员，在开发安全关键代码的时候遵守着一套准则。实际上包括 NASA 的喷气推进实验室（ NASA’s Jet Propulsion Laboratory ，JPL）在内的很多组织，主要使用 C 语言进行代码编写。</p><p>原因是，C 语言有大量的支持性工具，包括逻辑模型提取器、调试器、稳定的编译环境，以及在代码分析器和度量工具上拥有强大的资源。</p><p>有时候非常有必要遵循编程规则，特别是当代码的正确性与你的生活息息相关的时候 — 用来控制你乘坐的飞机的代码，用来控制将宇航员送入轨道的太空船的代码，或者用来控制你家几英里远的核电站的代码。这里介绍的 NASA 的 10 大编程规则，主要偏重于安全参数，这 10 大规则是由 NASA 喷气推进实验室（JPL）的首席科学家 Gerard J. Holzmann 提出的。这些准则也可以用于其他编程语言。</p><p><img id=\"pic\" class=\" \" src=\"http://ww3.sinaimg.cn/large/7cc829d3gw1f6ddtv31s1j20lc09yabi.jpg\" /></p><h3>第 1 条规则 — 简单的控制流</h3><p>用非常简单的控制流结构体来编写程序 — 不要用 setjmp 或者 longjmp 结构体，goto 语句，以及直接或间接的递归调用。</p><p><b></b><strong>理由：</strong>简单的控制流能够提高代码的清晰度以及拥有更强大的验证能力。不使用递归，就不会产生循环函数调用关系图，同时这也证明应该是有界的执行过程确实是有界的。</p><h3>第 2 条规则 — 循环设置固定的上限</h3><p>所有的循环必须有一个固定的上限。对于检查工具来说，在给定循环次数的情况下，可以通过静态分析证实循环结果不超过预设的上限。如果工具不能静态检测出循环上限，那么这条规则就不适用。</p><p><b></b><strong>理由：</strong>设置循环边界、不使用递归能够阻止代码失控。但是这个原则并不适用于迭代，迭代意味着无穷无尽（比如进程调度）。 这种情况下就该使用相反的规则 — 必须可以静态地检测到迭代不会终止。</p><h3>第 3 条规则 — 没有动态内存分配</h3><p>初始化之后不要使用动态内存分配。</p><p><b></b><strong>理由：</strong>内存分配运算符比如 malloc 以及 garbage collectors 通常伴有不可预测的行为，这些行为会严重影响性能。甚至还可能因为程序员的错误而发生内存错误，包括：</p><ul><li>试图分配比物理内存更多的内存空间</li><li>忘记释放内存</li><li>继续使用已经释放了的内存</li><li>超出内存分配的边界</li></ul><p>将所有的模块强制存放在固定的、预先分配的内存空间中，可以消除这类问题，同时验证内存的使用情况也会更加容易。</p><p>在堆中内存分配不足的情况下进行动态申请内存的一种方法是使用栈内存。</p><h3>第 4 条规则 — 没有大函数</h3><p>如果以一行一条声明和一行一条语句这样标准的格式来写，那么函数的长度不应该超过一张纸。这也就是说一个函数不应该超过 60 行代码。</p><p><b></b><strong>理由：</strong>冗长的函数通常等于糟糕的代码结构。每个函数应该是一个易懂可证实的逻辑单元。而理解一个多屏幕长的逻辑单元是很困难的。</p><h3>第 5 条原则 — 低断言使用密度</h3><p>代码断言的密度应该低至平均每个函数两个。断言是用来检查现实执行中不会发生的不正常情况。它应该被定义为布尔测试。当断言失败，应当立即采取恢复措施。</p><p>如果静态检测工具证明断言永远不会失败或者条件永远不为真，这条规则就无效。</p><p><b></b><strong>理由：</strong>工业编码工作统计显示，单元测试中每 10 到 100 行代码至少发现一个代码瑕疵。随着断言的密度增长，有瑕疵的代码被拦截的几率越大。作为强大的防御型代码策略，断言的使用也是非常重要的。断言可以用来验证函数的前后条件、参数以及函数和循环不变式的返回值。在测试完效率关键代码后，断言可以选择性地禁用。</p><h3>第 6 条规则 — 最小范围内声明数据对象</h3><p>这条规则支持数据隐藏的基本原则。所有的数据对象必须在尽可能最小范围内声明。</p><p><b></b><strong>理由：</strong>如果一个对象不在该范围内，其值也不能被引用或者销毁。这条规则阻止了变量的重复和冲突性的使用，这些行为会使错误诊断更加复杂。</p><h3>第 7 条规则 — 检查参数和返回值</h3><p>当函数的返回值为非空的时候，每次函数调用都应该检查其返回值，并且每个被调用的函数还要检查所带参数的有效性。</p><p>在最严格的模式下，这条规则意味着printf和文件关闭语句的返回值也要检查</p><p><b></b><strong>理由：</strong>如果一个错误的返回值和一个正确的返回值没有什么区别的话，这个时候就有必要精确检查返回值。在函数中有调用 close 和 prinf 语句的情况下，函数返回值是 void 能够被接受，表明程序员故意（并且不是偶然）忽略返回值。</p><h3>第 8 条规则 — 限制使用预处理器</h3><p>预处理器的使用应该限制在头文件和宏定义中。不允许使用递归宏调用，拼接符和可变参数列表。即使在大型程序的开发工作中，如果使用了超过一两个条件编译指令必须要有充足的理由，这么做超出了统一的代码标准，同样也是为了避免同样的头文件包含多重释义。每次这么做必须在代码中要有由基于工具的检查器进行标记并且要有充分的理由。</p><p><b></b><strong>理由：</strong>C 语言的预处理器是一个非常强大并且难懂的工具，它能够破坏代码的清晰性并迷惑基于文本的检查器。即使手上有正式语言定义，在无尽的预处理器代码中，代码的结构也是很难理解的。</p><p>条件编译也同样需要谨慎，10 个条件编译指令代码中就会有 1024（2^10）个不同版本的代码，这也增加了测试的工作量。</p><h3>第 9 条规则 — 限制使用指针</h3><p>必须要限制指针的使用。最多只允许使用一级指针解引用。指针解引用操作不可以隐藏在类型声明或宏定义中。还有，不允许使用函数指针。</p><p><b></b><strong>理由：</strong>即使是专家，也很容易误用指针。指针使得它们（尤其是基于工具的静态分析器）很难跟踪或分析程序中的数据流。函数指针还限制了静态分析器的检查类型，只有在理由非常充分的情况才能使用函数指针。如果使用函数指针，几乎不可能使用工具来证明缺少的递归，所以必须有足以弥补这部分缺失的分析能力的替代方法。</p><h3>第 10 条规则 — 所有代码必须能编译通过</h3><p>从开发的第一天起，所有的代码都必须通过编译。所有的编译器警告必须遵循编译器可使用警告。在编译器可使用警告范围内，编译的代码必须没有警告。</p><p>所有代码必须每天至少使用一个（最好多于一个）最新的静态源代码分析器进行检查，而且以0警告通过所有的分析。</p><p><b></b><strong>理由：</strong>市场上有很多相当有效的源代码分析软件，其中一些还是免费的。软件开发项目没有任何理由不去使用这个现成的技术</p><p>如果编译器或者分析器被搞混淆了（报出错误的警告），那么应该重写使其混淆的这部分代码。</p><p><b></b><strong>NASA 是这么评价这些规则的：</strong></p><blockquote><p>“它们就像车里的安全带：刚开始用会有点不舒服，但是过了一段时间就会成为一种习惯，你会无法想象不使用它们的日子。”</p></blockquote><div class=\"wp_rp_wrap  wp_rp_plain\" ><div class=\"wp_rp_content\"><h3 class=\"related_post_title\">相关文章</h3><ul class=\"related_post wp_rp\" style=\"visibility: visible\"><li ><a href=\"http://blog.jobbole.com/70604/\" class=\"wp_rp_title\">Hello World：美用激光束从太空传回高清视频</a></li><li ><a href=\"http://blog.jobbole.com/75812/\" class=\"wp_rp_title\">21个挑战题，几杯咖啡的时间，来试试</a></li><li ><a href=\"http://blog.jobbole.com/42886/\" class=\"wp_rp_title\">编程从业5年总结的14条经验</a></li><li ><a href=\"http://blog.jobbole.com/101161/\" class=\"wp_rp_title\">.NET 编程基础知识</a></li><li ><a href=\"http://blog.jobbole.com/15801/\" class=\"wp_rp_title\">也谈编程改革</a></li><li ><a href=\"http://blog.jobbole.com/98633/\" class=\"wp_rp_title\">StackOverflow 这么大，它的架构是怎么样的？</a></li><li ><a href=\"http://blog.jobbole.com/18144/\" class=\"wp_rp_title\">张砷镓：我所信奉的编程哲学 </a></li><li ><a href=\"http://blog.jobbole.com/98541/\" class=\"wp_rp_title\">Facebook 工程师是如何高效工作的？</a></li><li ><a href=\"http://blog.jobbole.com/26294/\" class=\"wp_rp_title\">把 hello 打印 10 次</a></li><li ><a href=\"http://blog.jobbole.com/100737/\" class=\"wp_rp_title\">编程超过 30 年，我是如何避开倦怠期的？</a></li></ul></div></div><p><a href=\"http://blog.jobbole.com/104016/\">NASA 的 10 大编程规则</a>，首发于<a href=\"http://blog.jobbole.com\">文章 - 伯乐在线</a>。</p>") (wfw:commentRss nil "http://blog.jobbole.com/104016/feed/") (slash:comments nil "1")) (item nil (title nil "计算机程序的思维逻辑 (2) ：赋值") (link nil "http://blog.jobbole.com/100330/") (comments nil "http://blog.jobbole.com/100330/#respond") (pubDate nil "Mon, 01 Aug 2016 08:50:59 +0000") (dc:creator nil "老马") (category nil "IT技术") (category nil "赋值") (guid ((isPermaLink . "false")) "http://blog.jobbole.com/?p=100330") (description nil "<p>上节我们说了数据类型和变量，通过声明变量，每个变量赋予一个数据类型和一个有意义的名字，我们就告诉了计算机我们要操作的数据。

有了数据，我们能做很多操作。但本文只说说对数据做的第一个操作：赋值。</p><p><a href=\"http://blog.jobbole.com/100330/\">计算机程序的思维逻辑 (2) ：赋值</a>，首发于<a href=\"http://blog.jobbole.com\">文章 - 伯乐在线</a>。</p>") (content:encoded nil "<p><strong>赋值</strong></p><p><a href=\"http://blog.jobbole.com/100329/\" target=\"_blank\">上节</a>我们说了数据类型和变量，通过声明变量，每个变量赋予一个数据类型和一个有意义的名字，我们就告诉了计算机我们要操作的数据。</p><p>有了数据，我们能做很多操作。但本文只说说对数据做的第一个操作：赋值。声明变量之后，就在内存分配了一块位置，但这个位置的内容是未知的，赋值就是把这块位置的内容设为一个确定的值。</p><p>Java中基本类型、数组、对象的赋值有明显不同，本文介绍基本类型和数组的赋值，关于对象后续文章会详述。</p><p>我们先来说基本类型的赋值，然后再说数组的赋值。</p><p><strong>基本类型的赋值</strong></p><p><strong>整数类型</strong></p><p>整数类型有byte, short, int和long，分别占用1/2/4/8个字节，取值范围分别是：</p><table><tbody><tr><td valign=\"top\" width=\"61\">类型名</td><td valign=\"top\" width=\"155\">取值范围</td></tr><tr><td valign=\"top\" width=\"61\">byte</td><td valign=\"top\" width=\"155\">-2^7 ~ 2^7-1</td></tr><tr><td valign=\"top\" width=\"61\">short</td><td valign=\"top\" width=\"155\">-2^15 ~ 2^15-1</td></tr><tr><td valign=\"top\" width=\"61\">int</td><td valign=\"top\" width=\"155\">-2^31 ~ 2^31-1</td></tr><tr><td valign=\"top\" width=\"61\">long</td><td valign=\"top\" width=\"155\">-2^63 ~ 2^63-1</td></tr></tbody></table><p>我们用^表示指数，2^7即2的7次方。这个范围我们不需要记的那么清楚，有个大概范围认识就可以了，大多数日常应用，一般用int就可以了。后续文章会从二进制的角度进一步分析表示范围为什么会是这样的。</p><p>赋值形式很简单，直接把熟悉的数字常量形式赋值给变量即可，对应的内存空间的值就从未知变成了确定的常量。但常量不能超过对应类型的表示范围。例如：</p><div><pre class=\"crayon-plain-tag\">byte b = 23;
short s = 3333;
int i = 9999;
long l = 32323;</pre></div><p>但是，在给long类型赋值时，如果常量超过了int的表示范围，需要在常量后面加大写或小写的L，即L或l，例如:</p><div><pre class=\"crayon-plain-tag\">long a = 3232343433L;</pre></div><p>这个是由于数字常量默认为是int类型。</p><p><strong>小数类型</strong></p><p>小数类型有float和double，占用的内存空间分别是4和8个字节，有不同的取值范围和精度，double表示的范围更大，精度更高，具体来说：</p><table><tbody><tr><td valign=\"top\" width=\"58\">类型名</td><td valign=\"top\" width=\"196\">取值范围</td></tr><tr><td valign=\"top\" width=\"58\">float</td><td valign=\"top\" width=\"196\">1.4E-45 ~ 3.4E+38</p><p>-3.4E+38 ~-1.4E-45</td></tr><tr><td valign=\"top\" width=\"58\">double</td><td valign=\"top\" width=\"196\">4.9E-324 ~1.7E+308</p><p>-1.7E+308 ~ -4.9E-324</td></tr></tbody></table><p>取值范围看上去很奇怪，一般我们也不需要记住，有个大概印象就可以了。E表示以10为底的指数，E后面的+号和-号代表正指数和负指数，例如：1.4E-45表示1.4乘以10的-45次方。后续文章会进一步分析小数的二进制表示。</p><p>对于double，直接把熟悉的小数表示赋值给变量即可，例如：</p><div><pre class=\"crayon-plain-tag\">double d = 333.33;</pre></div><p>但对于float，需要在数字后面加大写F或小写f，例如：</p><div><pre class=\"crayon-plain-tag\">float f = 333.33f;</pre></div><p>这个是由于小数常量默认为是double类型。</p><p>除了小数，也可以把整数直接赋值给float或double，例如：</p><div><pre class=\"crayon-plain-tag\">float f = 33;
double d = 3333333333333L;</pre></div><p><strong>boolean类型</strong></p><p>这个很简单，直接使用true或false赋值，分别表示真和假，例如：</p><div><pre class=\"crayon-plain-tag\">boolean b = true;
b = false;</pre></div><p><strong>字符类型</strong></p><p>字符类型char用于表示一个字符，这个字符可以是中文字符，也可以是英文字符。在内存中，Java用两个字节表示一个字符。赋值时把常量字符用单引号括起来，不要使用双引号，例如：</p><div><pre class=\"crayon-plain-tag\">char c = 'A';
char z = '中';</pre></div><p>关于字符类型有一些细节，后续文章会进一步深度解析。</p><p><strong>一些说明</strong><strong><br /></strong></p><p>上面介绍的赋值都是直接给变量设置一个常量值。但也可以把变量赋给变量，例如：</p><div><pre class=\"crayon-plain-tag\">int a = 100;
int b = a;</pre></div><p>变量可以进行各种运算（后续文章讲解），也可以将变量的运算结果赋给变量，例如：</p><div><pre class=\"crayon-plain-tag\">int a = 1;
int b = 2;
int c = 2*a+b; //2乘以a的值再加上b的值赋给c</pre></div><p>上面介绍的赋值都是在声明变量的时候就进行了赋值，但这不是必须的，可以先声明变量，随后再进行赋值。</p><p><strong>数组类型</strong></p><p><strong>赋值语法</strong></p><p>基本类型的数组有三种赋值形式，如下所示：</p><div><pre class=\"crayon-plain-tag\">1. int[] arr = {1,2,3};

2. int[] arr = new int[]{1,2,3};

3. int[] arr = new int[3];
    arr[0]=1; arr[1]=2; arr[2]=3;</pre></div><p>第一种和第二种都是预先知道数组的内容，而第三种是先分配长度，然后再给每个元素赋值。</p><p>第三种形式中，即使没有给每个元素赋值，每个元素也都有一个默认值，这个默认值跟数组类型有关。数值类型的值为0，boolean为false, char为空字符。</p><p>数组长度可以动态确定，如下所示：</p><div><pre class=\"crayon-plain-tag\">int length = ... ;//根据一些条件动态计算
int arr = new int[length];</pre></div><p>虽然可以动态确定，但定了之后就不可以变，数组有一个length属性，但只能读，不能改。</p><p>一个小细节，不能在给定初始值的同时还给定长度，即如下格式是不允许的：</p><div><pre class=\"crayon-plain-tag\">int[] arr = new int[3]{1,2,3}</pre></div><p>这是可以理解的，因为初始值已经决定了长度，再给个长度，如果还不一致，计算机将无所适从。</p><p><strong>数组和基本类型的区别</strong></p><p>一个基本类型变量，内存中只会有一块对应的内存空间。但数组有两块，一块用于存储数组内容本身，另一块用于存储内容的位置。</p><p>用一个例子来说明，有一个int变量a，和一个int数组变量arr，其代码，变量对应的内存地址和内存内容如下所示：</p><table><tbody><tr><td valign=\"top\" width=\"123\">代码</td><td valign=\"top\" width=\"66\">内存地址</td><td valign=\"top\" width=\"77\">内存数据</td></tr><tr><td valign=\"top\" width=\"123\">int a = 100;</td><td valign=\"top\" width=\"66\">1000</td><td valign=\"top\" width=\"77\">100</td></tr><tr><td valign=\"top\" width=\"123\">int[] arr = {1,2,3};</td><td valign=\"top\" width=\"66\">2000</td><td valign=\"top\" width=\"77\">3000</td></tr><tr><td valign=\"top\" width=\"123\"></td><td valign=\"top\" width=\"66\">3000</td><td valign=\"top\" width=\"77\">1</td></tr><tr><td valign=\"top\" width=\"123\"></td><td valign=\"top\" width=\"66\">3004</td><td valign=\"top\" width=\"77\">2</td></tr><tr><td colspan=\"1\" rowspan=\"1\" valign=\"top\" width=\"123\"></td><td colspan=\"1\" rowspan=\"1\" valign=\"top\" width=\"66\">3008</td><td colspan=\"1\" rowspan=\"1\" valign=\"top\" width=\"77\">3</td></tr></tbody></table><p>基本类型a的内存地址是1000，这个位置存储的就是它的值100。</p><p>数组类型arr的内存地址是2000，这个位置存储的值是一个位置3000，3000开始的位置存储的才是实际的数据1,2,3。</p><p><strong>为什么数组要用两块空间</strong></p><p>不能只用一块空间吗？我们来看下面这个代码：</p><div><pre class=\"crayon-plain-tag\">int[] arrA = {1,2,3};

int[] arrB = {4,5,6,7};
arrA = arrB;</pre></div><p>这个代码中，arrA初始的长度是3，arrB的长度是4，后来将arrB的值赋给了arrA。如果arrA对应的内存空间是直接存储的数组内容，那么它将没有足够的空间去容纳arrB的所有元素。</p><p>用两块空间存储，这个就简单的多，arrA存储的值就变成了和arrB的一样，存储的都是数组内容{4,5,6,7}的地址，此后访问arrA就和arrB是一样的了，而arrA {1,2,3}的内存空间由于无人引用会被垃圾回收，如下所示：</p><blockquote><p>arrA        {1,2,3}</p><p>\\</p><p>\\</p><p>arrB  -&gt;  {4,5,6,7}</p></blockquote><p>由上，也可以看出，给数组变量赋值和给数组中元素赋值是两回事。给数组中元素赋值是改变数组内容，而给数组变量赋值则会让变量指向一个不同的位置。</p><p>上面我们说数组的长度是不可以变的，不可变指的是数组的内容空间，一经分配，长度就不能再变了，但是可以改变数组变量的值，让它指向一个长度不同的空间，就像上例中arrA后来指向了arrB一样。</p><p><strong>小结</strong></p><p>给变量赋值就是将变量对应的内存空间设置为一个明确的值，有了值之后，变量可以被加载到CPU，CPU可以对这些值进行各种运算，运算后的结果又可以被赋值给变量，保存到内存中。</p><p>数据可以进行哪些运算？如何进行运算呢？</p><div class=\"wp_rp_wrap  wp_rp_plain\" ><div class=\"wp_rp_content\"><h3 class=\"related_post_title\">相关文章</h3><ul class=\"related_post wp_rp\" style=\"visibility: visible\"><li ><a href=\"http://blog.jobbole.com/98633/\" class=\"wp_rp_title\">StackOverflow 这么大，它的架构是怎么样的？</a></li><li ><a href=\"http://blog.jobbole.com/99151/\" class=\"wp_rp_title\">聊聊创业团队的项目管理如何面向开发人员优化</a></li><li ><a href=\"http://blog.jobbole.com/102415/\" class=\"wp_rp_title\">DNS 原理入门</a></li><li ><a href=\"http://blog.jobbole.com/101136/\" class=\"wp_rp_title\">坐在马桶上看算法（9）：巧妙的邻接表</a></li><li ><a href=\"http://blog.jobbole.com/100081/\" class=\"wp_rp_title\">MySQL 读写分离介绍及搭建</a></li><li ><a href=\"http://blog.jobbole.com/100346/\" class=\"wp_rp_title\">浅谈并发与并行（1）</a></li><li ><a href=\"http://blog.jobbole.com/100361/\" class=\"wp_rp_title\">最快最简单的排序算法：桶排序</a></li><li ><a href=\"http://blog.jobbole.com/100631/\" class=\"wp_rp_title\">坐在马桶上看算法（4）：小哼买书</a></li><li ><a href=\"http://blog.jobbole.com/103456/\" class=\"wp_rp_title\">八大排序算法</a></li><li ><a href=\"http://blog.jobbole.com/101231/\" class=\"wp_rp_title\">如何写出正确的二分法以及分析</a></li></ul></div></div><p><a href=\"http://blog.jobbole.com/100330/\">计算机程序的思维逻辑 (2) ：赋值</a>，首发于<a href=\"http://blog.jobbole.com\">文章 - 伯乐在线</a>。</p>") (wfw:commentRss nil "http://blog.jobbole.com/100330/feed/") (slash:comments nil "0")) (item nil (title nil "JDK8 Stream API中Collectors中toMap方法的问题以及解决方案") (link nil "http://blog.jobbole.com/104067/") (comments nil "http://blog.jobbole.com/104067/#comments") (pubDate nil "Mon, 01 Aug 2016 08:08:40 +0000") (dc:creator nil "theboboy") (category nil "开发") (category nil "java") (guid ((isPermaLink . "false")) "http://blog.jobbole.com/?p=104067") (description nil "<p>JDK8 Stream API中Collectors中toMap方法的问题
1、key不能重复
2、value不能是null</p><p><a href=\"http://blog.jobbole.com/104067/\">JDK8 Stream API中Collectors中toMap方法的问题以及解决方案</a>，首发于<a href=\"http://blog.jobbole.com\">文章 - 伯乐在线</a>。</p>") (content:encoded nil "<p>使用Collectors.toMap方法时的两个问题：</p><p>1、当key重复时，会抛出异常：java.lang.IllegalStateException: Duplicate key **<br />
2、当value为null时，会抛出异常：java.lang.NullPointerException</p><p>首先这个不是JDK的bug，只是不符合我们的预期。</p><p>大家通常希望这个方法是可以容错的，遇到重复的key就使用后者替换，而且HashMap的value可以是null。</p><p>下面举个小例子。</p><p>首先是元素类Emp：</p><pre class=\"crayon-plain-tag\">public class Emp {

	private Integer id;

	private String name;

	public Emp(Integer id, String name) {
		super();
		this.id = id;
		this.name = name;
		System.out.println(this);
	}

	public Integer getId() {
		return id;
	}

	public String getName() {
		return name;
	}

	@Override
	public String toString() {
		return \"id: \" + id + \", name: \" + name;
	}

}</pre><p>然后是测试类：</p><pre class=\"crayon-plain-tag\">import java.util.Map;
import java.util.stream.Collectors;
import java.util.stream.IntStream;
import java.util.stream.Stream;

public class Test {

	public static void main(String[] args) {
		Emp[] emps = IntStream.range(0, 10).mapToObj(x -&gt; new Emp(x % 3, \"name\" + x))
				.toArray(Emp[]::new);
		Map&lt;Integer, String&gt; map = Stream.of(emps).collect(Collectors.toMap(Emp::getId, Emp::getName));
		System.out.println(map);
	}

}</pre><p>生成10个对象，其中id只能为0，1，2，用id做key，name做value，运行结果如下：</p><pre class=\"crayon-plain-tag\">id: 0, name: name0
id: 1, name: name1
id: 2, name: name2
id: 0, name: name3
id: 1, name: name4
id: 2, name: name5
id: 0, name: name6
id: 1, name: name7
id: 2, name: name8
id: 0, name: name9
Exception in thread \"main\" java.lang.IllegalStateException: Duplicate key name0
	at java.util.stream.Collectors.lambda$throwingMerger$0(Collectors.java:133)
	at java.util.HashMap.merge(HashMap.java:1253)
	at java.util.stream.Collectors.lambda$toMap$58(Collectors.java:1320)
	at java.util.stream.ReduceOps$3ReducingSink.accept(ReduceOps.java:169)
	at java.util.Spliterators$ArraySpliterator.forEachRemaining(Spliterators.java:948)
	at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:481)
	at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:471)
	at java.util.stream.ReduceOps$ReduceOp.evaluateSequential(ReduceOps.java:708)
	at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)
	at java.util.stream.ReferencePipeline.collect(ReferencePipeline.java:499)
	at Test.main(Test.java:11)</pre><p>提示key重复了。</p><p>接下来看另一种情况：</p><pre class=\"crayon-plain-tag\">import java.util.Map;
import java.util.stream.Collectors;
import java.util.stream.IntStream;
import java.util.stream.Stream;

public class Test {

	public static void main(String[] args) {
		Emp[] emps = IntStream.range(0, 10).mapToObj(x -&gt; new Emp(x, x % 5 == 0 ? null : \"name\" + x))
				.toArray(Emp[]::new);
		Map&lt;Integer, String&gt; map = Stream.of(emps).collect(Collectors.toMap(Emp::getId, Emp::getName));
		System.out.println(map);
	}

}</pre><p>这个是让emps数组中出现两个value为null的元素，运行结果如下：</p><pre class=\"crayon-plain-tag\">id: 0, name: null
id: 1, name: name1
id: 2, name: name2
id: 3, name: name3
id: 4, name: name4
id: 5, name: null
id: 6, name: name6
id: 7, name: name7
id: 8, name: name8
id: 9, name: name9
Exception in thread \"main\" java.lang.NullPointerException
	at java.util.HashMap.merge(HashMap.java:1224)
	at java.util.stream.Collectors.lambda$toMap$58(Collectors.java:1320)
	at java.util.stream.ReduceOps$3ReducingSink.accept(ReduceOps.java:169)
	at java.util.Spliterators$ArraySpliterator.forEachRemaining(Spliterators.java:948)
	at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:481)
	at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:471)
	at java.util.stream.ReduceOps$ReduceOp.evaluateSequential(ReduceOps.java:708)
	at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)
	at java.util.stream.ReferencePipeline.collect(ReferencePipeline.java:499)
	at Test.main(Test.java:11)</pre><p>提示value是null。</p><p>这个是因为调用了HashMap的merge方法，方法不接受这种数据。因此需要手动实现，实现方式也很简单，只要调用map的put方法就可以了。</p><pre class=\"crayon-plain-tag\">import java.util.Collections;
import java.util.EnumSet;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;
import java.util.function.BiConsumer;
import java.util.function.BinaryOperator;
import java.util.function.Function;
import java.util.function.Supplier;
import java.util.stream.Collector;

public class ForceToMapCollector&lt;T, K, V&gt; implements Collector&lt;T, Map&lt;K, V&gt;, Map&lt;K, V&gt;&gt; {

	private Function&lt;? super T, ? extends K&gt; keyMapper;

	private Function&lt;? super T, ? extends V&gt; valueMapper;

	public ForceToMapCollector(Function&lt;? super T, ? extends K&gt; keyMapper,
			Function&lt;? super T, ? extends V&gt; valueMapper) {
		super();
		this.keyMapper = keyMapper;
		this.valueMapper = valueMapper;
	}

	@Override
	public BiConsumer&lt;Map&lt;K, V&gt;, T&gt; accumulator() {
		return (map, element) -&gt; map.put(keyMapper.apply(element), valueMapper.apply(element));
	}

	@Override
	public Supplier&lt;Map&lt;K, V&gt;&gt; supplier() {
		return HashMap::new;
	}

	@Override
	public BinaryOperator&lt;Map&lt;K, V&gt;&gt; combiner() {
		return null;
	}

	@Override
	public Function&lt;Map&lt;K, V&gt;, Map&lt;K, V&gt;&gt; finisher() {
		return null;
	}

	@Override
	public Set&lt;Characteristics&gt; characteristics() {
		return Collections.unmodifiableSet(EnumSet.of(Collector.Characteristics.IDENTITY_FINISH));
	}

}</pre><p></p><pre class=\"crayon-plain-tag\">import java.util.Map;
import java.util.function.Function;
import java.util.stream.Collector;

public final class MyCollectors {

	public static &lt;T, K, V&gt; Collector&lt;T, ?, Map&lt;K, V&gt;&gt; toMap(Function&lt;T, K&gt; f1, Function&lt;T, V&gt; f2) {
		return new ForceToMapCollector&lt;T, K, V&gt;(f1, f2);
	}

}</pre><p>测试类如下：</p><pre class=\"crayon-plain-tag\">import java.util.Map;
import java.util.stream.IntStream;
import java.util.stream.Stream;

public class Test {

	public static void main(String[] args) {
		Emp[] emps = IntStream.range(0, 10).mapToObj(x -&gt; new Emp(x % 3, x % 5 == 0 ? null : \"name\" + x))
				.toArray(Emp[]::new);
		Map&lt;Integer, String&gt; map = Stream.of(emps).collect(MyCollectors.toMap(Emp::getId, Emp::getName));
		System.out.println(map);
	}

}</pre><p>包含了上面两种可能产生异常的情况，运行结果如下：</p><pre class=\"crayon-plain-tag\">id: 0, name: null
id: 1, name: name1
id: 2, name: name2
id: 0, name: name3
id: 1, name: name4
id: 2, name: null
id: 0, name: name6
id: 1, name: name7
id: 2, name: name8
id: 0, name: name9
{0=name9, 1=name7, 2=name8}</pre><p>解决了上面的问题，满足了容错需求。</p><p>由于Stream API用的不是很广泛，如果网友们有更好的实现方案，希望告知，多谢！</p><div class=\"wp_rp_wrap  wp_rp_plain\" ><div class=\"wp_rp_content\"><h3 class=\"related_post_title\">相关文章</h3><ul class=\"related_post wp_rp\" style=\"visibility: visible\"><li ><a href=\"http://blog.jobbole.com/90693/\" class=\"wp_rp_title\">ASP.NET MVC随想录（3）：创建自定义的Middleware中间件</a></li><li ><a href=\"http://blog.jobbole.com/79421/\" class=\"wp_rp_title\">Eric Raymond对于几大开发语言的评价</a></li><li ><a href=\"http://blog.jobbole.com/20400/\" class=\"wp_rp_title\">理解ThreadLocal</a></li><li ><a href=\"http://blog.jobbole.com/103325/\" class=\"wp_rp_title\">ThreadLocal 那点事儿</a></li><li ><a href=\"http://blog.jobbole.com/92815/\" class=\"wp_rp_title\">.NET 基础拾遗（3）: 字符串、集合和流</a></li><li ><a href=\"http://blog.jobbole.com/66078/\" class=\"wp_rp_title\">Java 8 中 HashMap 的性能提升 </a></li><li ><a href=\"http://blog.jobbole.com/77812/\" class=\"wp_rp_title\">空指针的救星</a></li><li ><a href=\"http://blog.jobbole.com/102378/\" class=\"wp_rp_title\">深入探索Java 8 Lambda表达式</a></li><li ><a href=\"http://blog.jobbole.com/16474/\" class=\"wp_rp_title\">Java编程提高性能时需注意的地方</a></li><li ><a href=\"http://blog.jobbole.com/37273/\" class=\"wp_rp_title\">Java的内存回收机制</a></li></ul></div></div><p><a href=\"http://blog.jobbole.com/104067/\">JDK8 Stream API中Collectors中toMap方法的问题以及解决方案</a>，首发于<a href=\"http://blog.jobbole.com\">文章 - 伯乐在线</a>。</p>") (wfw:commentRss nil "http://blog.jobbole.com/104067/feed/") (slash:comments nil "2")) (item nil (title nil "“懒惰” Linux 管理员的 10 个关键技巧") (link nil "http://blog.jobbole.com/104056/") (pubDate nil "Mon, 01 Aug 2016 05:24:38 +0000") (dc:creator nil "伯小乐") (category nil "IT技术") (category nil "Linux") (category nil "系统管理员") (guid ((isPermaLink . "false")) "http://blog.jobbole.com/?p=104056") (description nil "<p>如何成为一名效率更高的系统管理员

学会这 10 个技巧后，您将成为世界上最强大的 Linux® 系统管理员，整个世界是有点夸张，但要在一个大团队中工作，这些技巧是十分必要的。学习 SHH 通道、VNC、密码恢复、控制台侦察等等。各个技巧都附有例子，可以将这些例子复制到自己的系统中。</p><p><a href=\"http://blog.jobbole.com/104056/\">“懒惰” Linux 管理员的 10 个关键技巧</a>，首发于<a href=\"http://blog.jobbole.com\">文章 - 伯乐在线</a>。</p>") (content:encoded nil "<p>好的系统管理员区分在效率上。如果一位高效的系统管理员能在 10 分钟内完成一件他人需要 2 个小时才能完成的任务，那么他应该受到奖励（得到更多报酬），因为他为公司节约了时间，而时间就是金钱，不是吗？</p><p>技巧是为了提高管理效率。虽然本文不打算对<em>所有</em> 技巧进行讨论，但是我会介绍 “懒惰” 管理员所用的 10 个基本法宝。这些技巧可以节约时间 —— 即使没有因为高效而得到更多的报酬，但至少可以有更多的时间去玩。</p><h2 id=\"T1\">技巧 1：卸载无响应的 DVD 驱动器</h2><p>网络新手的经历：按下服务器（运行基于 Redmond 的操作系统）DVD 驱动器上的 Eject 按钮时，它会立即弹出。他然后抱怨说，在大多数企业 Linux 服务器中，如果在那个目录中运行某个进程，弹出就不会发生。作为一名长期的 Linux 管理员，我会重启机器。如果我不清楚正在运行什么，以及为何不释放 DVD 驱动器，我则会弹出磁盘。但这样效率很低。</p><p>下面介绍如何找到保持 DVD 驱动器的进程，并轻松弹出 DVD 驱动器：首先进行模拟。在 DVD 驱动器中放入磁盘，打开一个终端，装载 DVD 驱动器：</p><pre class=\"crayon-plain-tag\"># mount /media/cdrom
# cd /media/cdrom
# while [ 1 ]; do echo \"All your drives are belong to us!\"; sleep 30; done</pre><p>现在打开第二个终端并试着弹出 DVD 驱动器：</p><pre class=\"crayon-plain-tag\"># eject</pre><p>将得到以下消息：</p><p><code>umount: /media/cdrom: device is busy</code></p><p>在释放该设备之前，让我们找出谁在使用它。</p><pre class=\"crayon-plain-tag\"># fuser /media/cdrom</pre><p>进程正在运行，无法弹出磁盘其实是我们的错误。</p><p>现在，如果您是根用户，可以随意终止进程：</p><pre class=\"crayon-plain-tag\"># fuser -k /media/cdrom</pre><p>现在终于可以卸载驱动器了：</p><pre class=\"crayon-plain-tag\"># eject</pre><p><code>fuser</code> 很正常。</p><h2 id=\"T2\">技巧 2：恢复出现问题的屏幕</h2><p>尝试以下操作：</p><pre class=\"crayon-plain-tag\"># cat /bin/cat</pre><p>注意！终端就想垃圾一样。输入的所有内容非常零乱。那么该怎么做呢？</p><p>输入 <code>reset</code>。但是，输入 <code>reset</code> 与 输入 <code>reboot</code> 或 <code>shutdown</code> 太接近了。吓得手心冒汗了吧 — 特别是在生产机器上执行这个操作时。</p><p>放心吧，在进行此操作时，机器不会重启。继续操作：</p><pre class=\"crayon-plain-tag\"># reset</pre><p>现在屏幕恢复正常了。这比关闭窗口后再次登陆好多了，特别是必须经过 5 台机器和 SSH 才能到达这台机器时。</p><h2 id=\"T3\">技巧 3：屏幕协作</h2><p>来自产品工程的高级维护用户 David 打电话说：“为什么我不能在您部署的这些新机器上编译 supercode.c”。</p><p>您会问他：“您运行的是什么机器？”</p><p>David 答道：“ Posh”。（这个虚够的公司将它的 5 台生产服务器以纪念 Spice Girls 的方式命名）。这下您可以大显身手了，另一台机器由 David 操作：</p><pre class=\"crayon-plain-tag\"># su - david</pre><p>转到 posh：</p><pre class=\"crayon-plain-tag\"># ssh posh</pre><p>到达之后，运行以下代码：</p><pre class=\"crayon-plain-tag\"># screen -S foo</pre><p>然后呼叫 David：</p><p>“David，在终端运行命令 <code># screen -x foo</code>”。</p><p>这使您和 David 的会话在 Linux shell 中联接在一起。您可以输入，他也可以输入，但彼此可以看到对方所做的事情。这避免了进入其他层次，而且双方都有相同的控制权。这样做的好处是 David 可以观察到您的故障诊断技巧，并能准确了解如何解决问题。</p><p>最后大家都能看到问题所在：David 的编译脚本对一个不在此新服务器上的旧目录进行了硬编码。将它装载后再次编译即可解决问题，然后 David 继续工作。您则可以继续之前的娱乐活动。</p><p>关于此技巧需要注意的一点是，双方需要以同一用户登录。<code>screen</code> 命令还可以：实现多个窗口和拆分屏幕。请阅读手册页获取更多相关信息。</p><p>对于 <code>screen</code> 会话，我还有最后一个技巧。要从中分离并让它打开，请输入</p><pre class=\"crayon-plain-tag\">Ctrl-A D</pre><p>（即按住 <strong>Ctrl</strong> 键并点击 <strong>A</strong> 键。然后按 <strong>D</strong> 键）。</p><p>然后通过再次运行 <code>screen -x foo</code> 命令可以重新拼接起来。</p><h2 id=\"T4\">技巧 4：找回根密码</h2><p>如果忘记根密码，就必须重新安装整台机器。更惨的是，许多人都会这样做。但是启动机器并更改密码却十分简单。这并非在所有情况下都适用（比如设置了一个 GRUB 密码，但也忘记了），但这里介绍一个 Cent OS Linux 示例，说明一般情况下的操作。</p><p>首先重启系统。重启时会跳出如图 1 所示的 GRUB 屏幕。移动箭头键，这样可以保留在此屏幕上，而不是进入正常启动。</p><h5 id=\"fig1\">图 1. 重启后的 GRUB 屏幕</h5><p><img class=\"alignnone size-full wp-image-104057\" src=\"http://jbcdn2.b0.upaiyun.com/2016/08/908274ca8bae11a3d0ee929945bed136.jpg\" alt=\"figure1\" /></p><p>然后，使用箭头键选择要启动的内核，并输入 <strong>E</strong> 编辑内核行。然后便可看到如图 2 所示的屏幕：</p><h5 id=\"fig2\">图 2：准备编辑内核行</h5><p><img class=\"alignnone size-full wp-image-104058\" src=\"http://jbcdn2.b0.upaiyun.com/2016/08/0ffb52eba45605e896a7b78cb83739c7.jpg\" alt=\"figure2\" /></p><p>再次使用箭头键突出显示以 <code>kernel</code> 开始的行，按 <strong>E</strong> 编辑内核参数。到达如图 3 所示的屏幕时，在图 3 中所示的参数后追加数字 1 即可：</p><h5 id=\"fig3\">图 3. 在参数后追加数字 1</h5><p><img class=\"alignnone size-full wp-image-104059\" src=\"http://jbcdn2.b0.upaiyun.com/2016/08/0529dad8172eae86f9194b573b5500b1.jpg\" alt=\"figure3\" /></p><p>然后按 <strong>Enter</strong> 和 <strong>B</strong>，内核会启动到单用户模式。然后运行 <code>passwd</code> 命令，更改用户根密码：</p><pre class=\"crayon-plain-tag\">sh-3.00# passwd
New UNIX password:
Retype new UNIX password:
passwd: all authentication tokens updated successfully

现在可以重启了，机器将使用新密码启动。</pre><p>&nbsp;</p><h2 id=\"T5\">技巧 5：SSH 后门</h2><p>有很多次，我所在的站点需要某人的远程支持，而他却被公司防火强阻挡在外。很少有人意识到，如果能通过防火墙到达外部，那么也能轻松实现让外部的信息进来。 从本意讲，这称为 “在防火墙上砸一个洞”。我称之为 <em>SSH 后门</em>。为了使用它，必须有一台作为中介的连接到 Internet 的机器。 在本例中，将这样台机器称为 blackbox.example.com。公司防火墙后面的机器称为 ginger。此技术支持的机器称为 tech。图 4 解释了设置过程。</p><h5 id=\"fig4\">图 4. 在防火墙上砸一个洞</h5><p><img class=\"alignnone size-full wp-image-104060\" src=\"http://jbcdn2.b0.upaiyun.com/2016/08/bffe845bc378958de3345dd580a59ecc.gif\" alt=\"figure4\" /></p><p>以下是操作步骤：</p><ol><ol><li>检查什么是允许做的，但要确保您问对了人。大多数人都担心您打开了防火墙，但他们不明白这是完全加密的。而且，必须破解外部机器才能进入公司内部。不过，您可能属于 “敢作敢为” 型的人物。自己进行判断应该选择的方式，但不如意时不抱怨别人。</li></ol></ol><ul><li>使用 <code>-R</code> 标记通过 SSH 从 ginger 连接到 blackbox.example.com。假设您是 ginger 上的根用户，tech 需要根用户 ID 来帮助使用系统。使用 <code>-R</code> 标记将 blackbox 上端口 2222 的说明转发到 ginger 的端口 22 上。这就设置了 SSH 通道。注意，只有 SSH 通信可以进入 ginger：您不会将 ginger 放在无保护的 Internet 上。可以使用以下语法实现此操作：<br /><pre class=\"crayon-plain-tag\">~# ssh -R 2222:localhost:22 thedude@blackbox.example.com</pre><br />
进入 blackbox 后，只需一直保持登录状态。我总是输入以下命令：<br /><pre class=\"crayon-plain-tag\">thedude@blackbox:~$ while [ 1 ]; do date; sleep 300; done</pre><br />
使机器保持忙碌状态。然后最小化窗口。</li><li>现在指示 tech 上的朋友使用 SSH 连接到 blackbox，而不需要使用任何特殊的 SSH 标记。但必须把密码给他们：<br /><pre class=\"crayon-plain-tag\">root@tech:~# ssh thedude@blackbox.example.com</pre></li><li>tech 位于 blackbox 上后，可以使用以下命令从 SSH 连接到 ginger：<br /><pre class=\"crayon-plain-tag\">thedude@blackbox:~$: ssh -p 2222 root@localhost</pre></li><li>Tech 将提示输入密码。应该输入 ginger 的根密码。</li><li>现在您和来自 tech 的支持可以一起工作并解决问题。甚至需要一起使用屏幕！（参见 技巧 4）。</li></ul><h2 id=\"T6\">技巧 6：通过 SSH 通道进行远程 VNC 会话</h2><p>VNC 或虚拟网络计算已经存在很长时间了。通常，当远程服务器上的某类图形程序只能在此服务器上使用时，我才需要 VNC。</p><p>例如，假设在 <a href=\"#T5\">技巧 5</a> 中，ginger 是一台存储服务器。许多设备都使用 GUI 程序来管理存储控制器。这些 GUI 管理工具通常需要通过一个网络直接连接到存储服务器，而这个网络有时保存在专用的子网络中。因此，只能通过 ginger 访问这个 GUI。</p><p>可以尝试使用 <code>-X</code> 选项通过 SSH 连接到 ginger 并启动它，但这对带宽要求很高，您需要忍受等待的痛苦。VNC 是一个网络友好的工具，几乎适用于所有操作系统。</p><p>假设设置与技巧 5 中的一样，但希望 tech 能访问 VNC 而不是 SSH。对于这种情况，需要进行一些类似的操作，不过转发的是 VNC 端口。执行以下操作步骤：</p><ol><li>在 ginger 上启动一个 VNC 服务器会话。运行以下命令：<br /><pre class=\"crayon-plain-tag\">root@ginger:~# vncserver -geometry 1024x768 -depth 24 :99</pre><br />
这些选项指示启动服务器，分辨率为 1024&#215;768，像素深度为每像素 24 位。如果使用较慢的连接设置，8 也许是更好的选项。使用 <code>:99</code> 指定可访问 VNC 服务器的端口。VNC 协议在 5900 处启动，因此 <code>:99</code> 表示服务器可从端口 5999 访问。</p><p>启动该会话时，要求您指定密码。用户 ID 与启动 VNC 服务器时的用户相同（本例中就是根用户）。</li><li>从 ginger 连接到 blackbox.example.com 的 SSH 将 blackbox 上的端口 5999 转发到 ginger。这通过运行以下命令在 ginger 中完成：</p><pre class=\"crayon-plain-tag\">root@ginger:~# ssh -R 5999:localhost:5999 thedude@blackbox.example.com</pre><p>运行此命令后，需要将此 SSH 会话保持为打开状态，以便保留转发到 ginger 的端口。此时，如果在 blackbox 上，那么运行以下命令即可访问 ginger 上的 VNC 会话：</p><pre class=\"crayon-plain-tag\">thedude@blackbox:~$ vncviewer localhost:99</pre><p>这将通过 SSH 将端口转发给 ginger，但我们希望通过 tech 让 VNC 访问 ginger。为此，需要另一个通道。</li><li>在 tech 中，打开一个通道，通过 SHH 将端口 5999 转发到 blackbox 上的端口 5999。这通过运行以下命令完成：</p><pre class=\"crayon-plain-tag\">root@tech:~# ssh -L 5999:localhost:5999 thedude@blackbox.example.com</pre><p>这次使用的 SSH 标记为 <code>-L</code>，它不是将 5999 放到 blackbox，而是从中获取。到达 blackbox 后，需要保持此会话为打开状态。现在即可在 tech 中使用 VNC 了！</li><li>在 tech 中，运行以下命令使 VNC 连接到 ginger：</p><pre class=\"crayon-plain-tag\">root@tech:~# vncviewer localhost:99</pre><p>.Tech 现在将拥有一个直接到 ginger 的 VNC 会话。</li></ol><p>设置虽然有点麻烦，但比为修复存储阵列而四处奔波强多了。不过多实践几次这就变得容易了。</p><p>对此技巧我还要补充一点：如果 tech 运行的是 Windows® 操作系统，并且没有命令行 SSH 客户端，那么 tech 可以运行 Putty。Putty 可以设置为通过查找侧栏中的选项来转发 SSH 端口。如果端口是 5902 而不是本例中的 5999，则可以输入图 5 中的内容。</p><h5 id=\"fig5\">图 5. Putty 可以转发用作通道的 SSH</h5><p><img class=\"alignnone size-full wp-image-104061\" src=\"http://jbcdn2.b0.upaiyun.com/2016/08/c81a100ab2da1fef06474283f5e4e771.jpg\" alt=\"figure5\" /></p><p>如果进行了此设置，那么 tech 就可以使用 VNC 连接到 localhost:2，如同 tech 正在 Linux 操作系统上运行一样。</p><h2 id=\"T7\">技巧 7：检查带宽</h2><p>设想：公司 A 有一个名为 ginger 的存储服务器，并通过名为 beckham 的客户端节点装载 NFS。公司 A 确定他们需要从 ginger 得到更多的带宽，因为有大量的节点需要 NFS 装载 ginger 的共享文件系统。</p><p>实现此操作的最常用和最便宜的方式是将两个吉比特以太网 NIC 组合在一起。这是最便宜的，因为您通常会有一个额外的可用 NIC 和一个额外的端口。</p><p>所以采取此这个方法。不过现在的问题是：到底需要多少带宽？</p><p>吉比特以太网理论上的限制是 128MBit/s。这个数字从何而来？看看这些计算：</p><p><em>1Gb = 1024Mb</em>；<em>1024Mb/8 = 128MB</em>；&#8221;b&#8221; = &#8220;bits,&#8221;、&#8221;B&#8221; = &#8220;bytes&#8221;</p><p>但实际看到的是什么呢，有什么好的测量方法呢？我推荐一个工具 iperf。可以按照以下方法获得 iperf：</p><pre class=\"crayon-plain-tag\"># wget http://dast.nlanr.net/Projects/Iperf2.0/iperf-2.0.2.tar.gz</pre><p>需要在 ginger 和 beckham 均可见的共享文件系统上安装此工具，或者在两个节点上编译并安装。我将在两个节点均可见的 bob 用户的主目录中编译它：</p><pre class=\"crayon-plain-tag\">tar zxvf iperf*gz
cd iperf-2.0.2
./configure -prefix=/home/bob/perf
make
make install</pre><p>在 ginger 上，运行：</p><pre class=\"crayon-plain-tag\"># /home/bob/perf/bin/iperf -s -f M</pre><p>这台机器将用作服务器并以 MBit/s 为单位输出执行速度。</p><p>在 beckham 节点上，运行：</p><pre class=\"crayon-plain-tag\"># /home/bob/perf/bin/iperf -c ginger -P 4 -f M -w 256k -t 60</pre><p>两个屏幕上的结果都指示了速度是多少。在使用吉比特适配器的普通服务器上，可能会看到速度约为 112MBit/s。这是 TCP 堆栈和物理电缆中的常用带宽。通过以端到端的方式连接两台服务器，每台服务器使用两个联结的以太网卡，我获得了约 220MBit/s 的带宽。</p><p>事实上，在联结的网络上看到的 NFS 约为 150-160MBit/s。这仍然表示带宽可以达到预期效果。如果看到更小的值，则应该检查是否有问题。</p><p>我最近碰到一种情况，即通过连接驱动程序连接两个使用了不同驱动程序的 NIC。这导致性能非常低，带宽约为 20MBit/s，比不连接以太网卡时的带宽还小！</p><h2 id=\"T8\">技巧 8：命令行脚本和实用程序</h2><p>Linux 系统管理员通过使用权威的命令行脚本会变得更高效。这包括巧妙使用循环和知道如何使用 <code>awk</code>、<code>grep</code> 和 <code>sed</code> 等的实用程序解析数据。通常这可以减少击键次数，降低用户出错率。</p><p>例如，假设需要为即将安装的 Linux 集群生成一个新的 /etc/hosts 文件。一般的做法是在 vi 或文本编辑器中添加 IP 地址。不过，可以通过使用现有 /etc/hosts 文件并将以下内容追加到此文件来实现。在命令行上运行：</p><pre class=\"crayon-plain-tag\"># P=1; for i in $(seq -w 200); do echo \"192.168.99.$P n$i\"; P=$(expr $P + 1);
done &gt;&gt;/etc/hosts</pre><p>200 个主机名（n001 到 n200）将由 IP 地址（192.168.99.1 到 192.168.99.200）来创建。手动填充这样的文件有可能会创建重复的 IP 地址或主机名，因此这是使用内置命令行消除用户错误的好例子。请注意，这是在 bash shell（大多数 Linux 发行版的默认值）内完成的。</p><p>再举一个例子，假设要检查 Linux 集群中的各个计算节点中的内存大小是否一样。通常，拥有一个发行版或类似的 shell 是最好的。但是为了演示，以下使用 SSH。</p><p>假设 SSH 设置为不使用密码验证。然后运行：</p><pre class=\"crayon-plain-tag\"># for num in $(seq -w 200); do ssh n$num free -tm | grep Mem | awk '{print $2}';
done | sort | uniq</pre><p>这样的命令行相当简洁。（如果在其中放入正则表达式情况会更糟）。让我们对它进行细分，详细讨论各部分。</p><p>首先从 001 循环到 200。使用 <code>seq</code> 命令的 <code>-w</code> 选项在前面填充 0。 然后替换 <code>num</code> 变量，创建通过 SSH 连接的主机。有了目标主机后，向它发出命令。本例中是：</p><pre class=\"crayon-plain-tag\">free -m | grep Mem | awk '{print $2}'</pre><p>这个命令的意思是：</p><ul><li>使用 <code>free</code> 命令获取以兆字节为单位的内存大小。</li><li>获取这个命令的结果，并使用 <code>grep</code> 获取包含字符串 <code>Mem</code> 的行。</li><li>获取那一行并使用 <code>awk</code> 输出第二个字段，它是节点中的总内存。</li></ul><p>在每个节点上执行这个操作。</p><p>在每个节点上执行命令后，200 个节点的整个输出就传送（<code>|</code>d）到 <code>sort</code> 命令，以对所有内存值进行排序。</p><p>最后，使用 <code>uniq</code> 命令消除重复项。这个命令会导致以下情况中的一种：</p><ul><li>如果所有节点（n001 到 n200）拥有相同的内存大小，则只显示一个数字。这个数字就是每个操作系统看到的内存大小。</li><li>如果节点内存大小不同，将会看到几个内存大小的值。</li><li>最后，如果某个节点上的 SSH 出现故障，则会看到一些错误消息。</li></ul><p>这个命令并不是完美无缺的。如果发现与预期不同的内存值，您就不知道是哪一个节点出了问题，或者有多少个节点。为此需要发出另一个命令。</p><p>这个技巧提供了一种查看某些内容的快速方式，而且如果发生错误，您可以立刻知道。其价值在于快速检查。</p><h2 id=\"T9\">技巧 9：控制台侦察</h2><p>有些软件会向控制台输出错误消息，而控制台不一定会显示在 SHH 会话中。使用 vcs 设备可以进行检查。在 SSH 会话中，在远程服务器 <code># cat /dev/vcs1</code> 上运行以下命令。这将显示第一个控制台中的内容。也可以使用 2、3 等查看其他虚拟终端。如果某个用户在远程系统上输入，您将看到他输入的内容。</p><p>在大多数数据场中，使用远程终端服务器、KVM 甚至 Serial Over LAN 是查看这类信息的最好方式；它也提供了带外查看功能的一些好处。使用 vcs 设备能够提供一种快速带内方法，这能节省去机房查看控制台的时间。</p><h2 id=\"T10\">技巧 10：随机系统信息收集</h2><p>在 <a href=\"#T8\">技巧 8</a> 中，介绍了一个使用命令行获取有关系统中总内存信息的例子。在这个技巧中，我将介绍几个其他方法，用于从需要进行验证、故障诊断或给予远程支持的系统收集重要信息。</p><p>首先，收集关于处理器的信息。通过以下命令很容易实现：</p><pre class=\"crayon-plain-tag\"># cat /proc/cpuinfo</pre><p>这个命令给出关于处理器的速度、数量和型号的信息。在许多情况下使用 <code>grep</code> 可以得到需要的值。</p><p>我经常做的检查是确定系统中处理器的数量。因此，如果我买了一台带双核处理器的四核服务器，我可以运行以下命令：</p><pre class=\"crayon-plain-tag\"># cat /proc/cpuinfo | grep processor | wc -l</pre><p>然后我看到值应该是 8。如果不是，我会打电话给供应商，让他们给我派送另一台处理器。</p><p>我需要的另一条信息是磁盘信息。可以使用 <code>df</code> 命令获得。我总是添加 <code>-h</code> 标记，以便看到以十亿字节或兆字节为单位的输出。<code># df -h</code> 还会显示磁盘的分区情况。</p><p>列表最后是查看系统固件的方式 —— 一个获取 BIOS 级别和 NIC 上的固件信息的方法。</p><p>要检查 BIOS 版本，可以运行 <code>dmidecode</code> 命令。遗憾的是，不能轻易使用 <code>grep</code> 获取信息，所以这不是一个很有效的方法。对于我的 Lenovo T61 laptop，输出如下：</p><pre class=\"crayon-plain-tag\">#dmidecode | less
...
BIOS Information
Vendor: LENOVO
Version: 7LET52WW (1.22 )
Release Date: 08/27/2007
...</pre><p>这比重启机器并查看 POST 输出有效得多。</p><p>要检查以太网适配器的驱动程序和固件版本，请运行 <code>ethtool</code>：</p><pre class=\"crayon-plain-tag\"># ethtool -i eth0
driver: e1000
version: 7.3.20-k2-NAPI
firmware-version: 0.3-0</pre><p></p><h2 id=\"N102CC\">结束语</h2><p>可以从精通命令行的人那里学习很多技巧。最好的学习方式是：</p><ul><li>与其他人一起工作。共享屏幕会话并观察其他人是如何工作的 —— 您会发现新的做事方法。可能需要谦虚一点，让其他人引导，不过通常可以学到很多东西。</li><li>阅读手册页。认真阅读手册页，即使是熟知的命令，也能获得更深的见解。例如，您以前可能根本不知道可以使用 <code>awk</code> 进行网络编程。</li><li>解决问题。作为系统管理员，总是要解决问题，不管是您还是其他人引起的问题。这就是经验，经验可以使您更优秀、更高效。</li></ul><p>我希望至少有一个技巧能帮助您学习到您不知道的知识。像这样的基本技巧可以使您更高效，并且能增长经验，但最重要的是，技巧可以让您有更多的空闲时间去做自己感兴趣的事情，比如玩电子游戏。最好的管理员比较悠闲，因为他们不喜欢工作。他们能找到完成任务的最快方法，并且能快速完成任务，从而保持休闲的生活。</p><div class=\"wp_rp_wrap  wp_rp_plain\" ><div class=\"wp_rp_content\"><h3 class=\"related_post_title\">相关文章</h3><ul class=\"related_post wp_rp\" style=\"visibility: visible\"><li ><a href=\"http://blog.jobbole.com/97676/\" class=\"wp_rp_title\">基于 JavaScript 的操作系统你听说过吗？</a></li><li ><a href=\"http://blog.jobbole.com/53821/\" class=\"wp_rp_title\">写给系统管理员的25个PHP安全实践</a></li><li ><a href=\"http://blog.jobbole.com/93132/\" class=\"wp_rp_title\">Linux Shell 管道命令(pipe)使用及与 Shell 重定向区别</a></li><li ><a href=\"http://blog.jobbole.com/36375/\" class=\"wp_rp_title\">在服务器上排除问题的头五分钟</a></li><li ><a href=\"http://blog.jobbole.com/76103/\" class=\"wp_rp_title\">SysAdmim 必备：系统性能大牛 Brendan Gregg 分享的 Linux 性能工具</a></li><li ><a href=\"http://blog.jobbole.com/80575/\" class=\"wp_rp_title\">18款开源/商用的Linux服务器控制面板</a></li><li ><a href=\"http://blog.jobbole.com/33790/\" class=\"wp_rp_title\">高效使用 SSH 的 16 个技巧</a></li><li ><a href=\"http://blog.jobbole.com/92792/\" class=\"wp_rp_title\">Linux Shell 创建序列数组</a></li><li ><a href=\"http://blog.jobbole.com/103561/\" class=\"wp_rp_title\">从业 30 年的女系统管理员的经验分享</a></li><li ><a href=\"http://blog.jobbole.com/49497/\" class=\"wp_rp_title\">给 Linux 系统“减肥”</a></li></ul></div></div><p><a href=\"http://blog.jobbole.com/104056/\">“懒惰” Linux 管理员的 10 个关键技巧</a>，首发于<a href=\"http://blog.jobbole.com\">文章 - 伯乐在线</a>。</p>")) (item nil (title nil "Linux 系统中一些针对文件系统的节能技巧") (link nil "http://blog.jobbole.com/104051/") (comments nil "http://blog.jobbole.com/104051/#respond") (pubDate nil "Mon, 01 Aug 2016 05:04:38 +0000") (dc:creator nil "黄山松") (category nil "IT技术") (category nil "Linux") (guid ((isPermaLink . "false")) "http://blog.jobbole.com/?p=104051") (description nil "<p>文件系统是 Linux 系统的重要组成部分，文件系统的配置和使用对整个系统的运行有着重要的影响。本文介绍了一些 Linux 系统上对文件系统的配置技巧，达到节省能耗并目的，有的技巧还可以提高系统的性能。虽然文件系统的节能成效比起 CPU 和显示器的节能来显得比较轻微，但是积少成多，绿色的地球将靠我们一点一滴来完成。</p><p><a href=\"http://blog.jobbole.com/104051/\">Linux 系统中一些针对文件系统的节能技巧</a>，首发于<a href=\"http://blog.jobbole.com\">文章 - 伯乐在线</a>。</p>") (content:encoded nil "<p>文件系统是 Linux 系统的重要组成部分，文件系统的配置和使用对整个系统的运行有着重要的影响。本文介绍了一些 Linux 系统上对文件系统的配置技巧，达到节省能耗并目的，有的技巧还可以提高系统的性能。虽然文件系统的节能成效比起 CPU 和显示器的节能来显得比较轻微，但是积少成多，绿色的地球将靠我们一点一滴来完成。</p><p>本文假设用户的主要文件系统驻留在硬盘之上。硬盘是系统 中相对于 CPU、内存等设备来说活动时间比较少的部件。如果硬盘处于空闲状态时，耗电量是很少的；而在启动进行读写的时候，耗电量会大大增加。所以通过文件系统节 能的核心思想就是，尽量减少磁盘 I/O，使硬盘更多的处于空闲状态。</p><h2 id=\"major1\">对 atime 的处理</h2><p>根 据 POSIX 的规定，Linux 以及 Unix 等系统都要为系统中的所有文件记录文件的最后访问时间，叫做 atime。对于某些应用来说，atime 是很重要的信息。比如一些邮件程序会通过邮件文件的 atime 来判断此邮件是否已读；一些备份和清理程序会根据文件在多长时间内没有被访问，来决定是否对文件进行清理和归档。</p><p>但是对于大部分应用来 说，atime 信息并不重要，而系统更新 atime 所带来的开销却是巨大的。因为系统每访问一次某个文件，就要对这个文件更新一个新的 atime 时间值。我这里所说的访问，并不是从用户角度来看的打开一个文件，而是系统底层的每一次 open 和 read 等操作。设想一下，我们每对文件进行一次读操作，都要引起一个对磁盘的写操作，即使我们要读的内容已经存在于内存的 Page Cache 中，还是要对磁盘进行一个写操作。这样引起的开销确实是巨大的，这些写操作会使磁盘更多的处于忙碌状态，这对系统性能（因为磁盘在完成一个写操作的时候会 暂时阻止其他的写操作）以及电量消耗都是不利的。</p><p>所以，如果用户可以确定自己的应用不会使用到文件的 atime 信息，则可以禁止 atime 的更新。对于整个文件系统，mount 命令的 noatime 选项可以使整个文件系统下的文件都不会进行 atime 的更新。可以使用如下命令：</p><div class=\"codesection\"><pre class=\"crayon-plain-tag\">mount -o remount,noatime  /</pre></div><p>也可以将 noatime 选项写在 /etc/fstab 文件里。</p><p>如果不想对整个文件系统禁止 atime 更新，而只是想针对某些文件或目录禁止，则可以通过 chattr 命令来完成，如下面的命令：</p><div class=\"codesection\"><pre class=\"crayon-plain-tag\">chattr -R +A /some/dir</pre></div><p>可以对某个目录及其下面的所有文件禁止 atime 更新。</p><p>除了 noatime，还有两个和 atime 相关的文件系统选项。一个是 nodiratime，此选项只针对目录禁止进行 atime 更新（注意 noatime 对文件和目录都生效，是 nodiratime 的超集）。这样就可以使 <code>ls</code>这样的命令不会更新目录的 atime 值。</p><p>对 于某些用户某些应用，atime 信息可能是必要的，比如本节一开始提到的邮件程序和备份工具。如果完全禁止 atime 更新会使这些程序无法正常工作。针对这种情况，Linux 在内核 2.6.20 中添加了一个新的 mount 选项 relatime（relative atime 的意思）。relatime 的意思是访问文件时，仅在 atime 早于文件的更改时间时对 atime 进行更新。在内核 2.6.24 中，又对 relatime 进行了扩展，在访问文件时，当 atime 已经超过某个时间（例如一天）没有更新，就对 atime 进行更新。这个扩展的意思就是调整 atime 的更新粒度。</p><p>目前 relatime 还没有被广泛的应用，因为许多 Linux 发行版的内核版本和 mount 命令还没有支持这个选项。如果你的系统支持 relatime，可以使用如下命令启用：</p><div class=\"codesection\"><pre class=\"crayon-plain-tag\">mount -o remount,relatime  /</pre></div><h2 id=\"major2\">调节 Page Cache 和 VM 系统</h2><h3 id=\"minor2.1\">调节 Page Cache</h3><p>在 Linux 的内核中，对文件的读写提供一个页面缓冲的机制（Page Cache）。Page Cache 存在于内存中，当要读取一个磁盘文件的内容时，内核首先在 Page Cache 中进行查找，如果要读取的内容已经存在 Page Cache 中，则无需在对磁盘发起实际的读操作。同样在需要写文件时，写操作也只是将内容存放于 Page Cache 中，而 Page Cache 中的更改内容由内核进程 pdflush 周期性的写回磁盘。在默认情况下，pdflush 进程每 5 秒钟醒来一次，进行数据写回操作。这个写回时间值定义在参数 <strong>/proc/sys/vm/dirty_writeback_centisecs</strong>中。如果在这 5 秒钟之间，发生电源故障或者系统崩溃，可能会引起数据丢失。如果用户的电源供应比较可靠，或者丢数据丢失的风险不是非常在意，可以适当的提高这个数据写回时间。使用如下命令查看系统当前的写回时间值：</p><div class=\"codesection\"><pre class=\"crayon-plain-tag\">cat /proc/sys/vm/dirty_writeback_centisecs 
 500</pre></div><p>此时间值的单位为 1/100 秒。使用如下命令可以更改此值：</p><div class=\"codesection\"><pre class=\"crayon-plain-tag\">echo 2000 &amp;gt; /proc/sys/vm/dirty_writeback_centisecs</pre></div><p>这样，就可以使 pdflush 进程 20 秒才醒来一次，从而减少对磁盘的访问频率。</p><p>还有一个参数 <strong>/proc/sys/vm/dirty_expire_centisecs</strong>控制一个更改过的页面经过多长时间后被认为是过期的、必须被写回的页面，其默认值是 3000（单位也是 1/100 秒）。用户也可以适当的增加此值，使页面更长时间的驻留在内存中。如下命令：</p><div class=\"codesection\"><pre class=\"crayon-plain-tag\">echo 4000 &amp;gt; /proc/sys/vm/dirty_expire_centisecs</pre></div><p>pdflush 进程处理的另一种情况是当可用内存量降低的时候，会将一些缓冲页面写回磁盘，释放内存。这个行为是受 <strong>/proc/sys/vm/dirty_background_ratio</strong>参数控制的，此参数的默认值为 10，意思是当所有被更改页面总大小占工作内存超过 10% 时，pdflush 会开始写回工作。用户可以增加这个比例，以增加页面驻留在内存的时间。此参数的更改方法同上面两个参数。</p><h3 id=\"minor2.2\">Swap 分区或文件</h3><p>在 默认情况下，Linux 内核并不是只有在物理内存不够用的时候才进行交换，而是为了保证尽量大的磁盘缓冲以及其他一些原因，会尽可能的将非活动的进程及内存页面交换出内存，放在 磁盘上的交换分区中。这种默认行为使得在还有大量内存可用的情况下，就会发生交换操作，而释放出的物理内存并没有被利用起来，显然这些交换操作是不必要 的。为了减少因交换引起的磁盘读写，在用户内存足够大的时候，可以考虑禁用 swap 分区。</p><h2 id=\"major3\">使用“笔记本模式”（laptop mode）</h2><p>在 2.6.6 以后，Linux 内核在 I/O 系统上支持一种“笔记本模式”。在“笔记本模式”下，内核更智能的使用 I/O 系统，它会尽量使磁盘处于低能耗的状态下。“笔记本模式”会将许多的 I/O 操作组织在一起，一次完成，而在每次的磁盘 I/O 之间是默认长达 10 分钟的非活动期，这样会大大减少磁盘启动的次数。为了完成这么长时间的非活动期，内核就要在一次活动期时完成尽可能多的 I/O 任务。在一次活动期间，要完成大量的预读，然后将所有的缓冲同步。在非活动期间，写操作会被阻挡在内存中（读操作如果无法在 Cache 中满足，则无法阻挡，因为用户无法忍受这么长时间的延迟）。“笔记本模式”会根据需要设置上节介绍的参数来达到适当的目的。</p><p>使用如下命令查看“笔记本模式”是否启用：</p><div class=\"codesection\"><pre class=\"crayon-plain-tag\">cat /proc/sys/vm/laptop_mode 
 0</pre></div><p>0 表示没有启用，可以使用如下命令启用：</p><div class=\"codesection\"><pre class=\"crayon-plain-tag\">echo 5 &amp;gt; /proc/sys/vm/laptop_mode</pre></div><h2 id=\"major4\">配置 syslog</h2><p>Linux 使用 syslog 记录内核和各种应用程序的日志信息。Linux 系统里存在一个 Daemon 进程 syslogd 或 sysklogd 来完成 syslog 的功能。默认设置下，syslogd 在每次记录一条日志后，都会使用同步（sync）操作强制将页面缓存同步到磁盘上。这样做是为了保证日志信息得到最大的保护，即使系统崩溃或电源故障，日 志信息可以最大可能的被写到了磁盘上。</p><p>但是在个人电脑等对日志信息要求不是如此严格的系统上，这些 sync 操作很耗费磁盘 I/O，同时耗费更多的电量。如果想禁止 syslog 的这种 sync 行为，需要修改 syslog 配置文件 /etc/syslog.conf，在不想进行 sync 操作的项目前添加一个“-”（减号）。</p><p>如将下面这一行：</p><div class=\"codesection\"><pre class=\"crayon-plain-tag\">*.info;mail.none;authpriv.none;cron.none      /var/log/messages</pre></div><p>改为：</p><div class=\"codesection\"><pre class=\"crayon-plain-tag\">*.info;mail.none;authpriv.none;cron.none      -/var/log/messages</pre></div><p>对于不是特别重要的日志信息，都可以采用以上方法禁止 sync 行为。</p><p>用户也可以根据自己的需要，将 /etc/syslog.conf 里不必要的日志项去掉，甚至可以将 syslogd 停掉，以节省磁盘 I/O。</p><h2 id=\"major5\">使用 tmpfs</h2><p>tmpfs（temporary file system）是一种基于内存的文件系统，类似于虚拟磁盘 ramdisk，但还是有很大不同。传统的 ramdisk 是一个块设备，而 tmpfs 是一个文件系统，并不是块设备，只是安装它，就可以使用。tmpfs 一开始使用很小的空间，但随着文件的复制和创建，tmpfs 文件系统会分配更多的内存，并按照需求动态地增加文件系统的空间。而且，当 tmpfs 中的文件被删除时，tmpfs 文件系统会动态地减小文件系统并释放内存资源。但是 tmpfs 中的内容会在文件系统卸载后丢失。</p><p>用户可以将 tmpfs 应用于 /tmp 目录，这样在系统运行时产生的临时文件，以及对这些临时文件的读写都只发生在内存里，而不会引起任何的磁盘 I/O。</p><p>如要使用最大为 100M 的 tmpfs 在 /tmp 目录上，可以将以下这行添加到 /etc/fstab 中：</p><div class=\"codesection\"><pre class=\"crayon-plain-tag\">tmpfs 	 /tmp 	 tmpfs 	 size=100m,mode=1777 	 0 0</pre></div><div class=\"wp_rp_wrap  wp_rp_plain\" ><div class=\"wp_rp_content\"><h3 class=\"related_post_title\">相关文章</h3><ul class=\"related_post wp_rp\" style=\"visibility: visible\"><li ><a href=\"http://blog.jobbole.com/93132/\" class=\"wp_rp_title\">Linux Shell 管道命令(pipe)使用及与 Shell 重定向区别</a></li><li ><a href=\"http://blog.jobbole.com/92792/\" class=\"wp_rp_title\">Linux Shell 创建序列数组</a></li><li ><a href=\"http://blog.jobbole.com/104042/\" class=\"wp_rp_title\">如何在 Linux 下检测内存泄漏</a></li><li ><a href=\"http://blog.jobbole.com/97676/\" class=\"wp_rp_title\">基于 JavaScript 的操作系统你听说过吗？</a></li><li ><a href=\"http://blog.jobbole.com/104056/\" class=\"wp_rp_title\">“懒惰” Linux 管理员的 10 个关键技巧</a></li><li ><a href=\"http://blog.jobbole.com/89886/\" class=\"wp_rp_title\">linux内核动态加载模块 </a></li><li ><a href=\"http://blog.jobbole.com/71671/\" class=\"wp_rp_title\">Linux 网络文件系统的数据备份及恢复机制实现</a></li><li ><a href=\"http://blog.jobbole.com/93375/\" class=\"wp_rp_title\">Linux /dev 常见特殊设备介绍与应用</a></li><li ><a href=\"http://blog.jobbole.com/93404/\" class=\"wp_rp_title\">Linux Shell man 命令详细介绍</a></li><li ><a href=\"http://blog.jobbole.com/22318/\" class=\"wp_rp_title\">使用Shell脚本对Linux系统和进程资源进行监控</a></li></ul></div></div><p><a href=\"http://blog.jobbole.com/104051/\">Linux 系统中一些针对文件系统的节能技巧</a>，首发于<a href=\"http://blog.jobbole.com\">文章 - 伯乐在线</a>。</p>") (wfw:commentRss nil "http://blog.jobbole.com/104051/feed/") (slash:comments nil "0")) (item nil (title nil "计算机程序的思维逻辑 (1)：数据和变量") (link nil "http://blog.jobbole.com/100329/") (comments nil "http://blog.jobbole.com/100329/#respond") (pubDate nil "Mon, 01 Aug 2016 03:45:59 +0000") (dc:creator nil "老马") (category nil "IT技术") (category nil "变量") (category nil "数据") (category nil "计算机") (guid ((isPermaLink . "false")) "http://blog.jobbole.com/?p=100329") (description nil "<p>计算机就是个机器，这个机器主要由CPU、内存、硬盘和输入输出设备组成。计算机上跑着操作系统，如Windows或Linux，操作系统上运行着各种应用程序，如Word, QQ等。</p><p><a href=\"http://blog.jobbole.com/100329/\">计算机程序的思维逻辑 (1)：数据和变量</a>，首发于<a href=\"http://blog.jobbole.com\">文章 - 伯乐在线</a>。</p>") (content:encoded nil "<h1>程序大概是怎么回事</h1><p>计算机就是个机器，这个机器主要由CPU、内存、硬盘和输入输出设备组成。计算机上跑着操作系统，如Windows或Linux，操作系统上运行着各种应用程序，如Word, QQ等。</p><p>操作系统将时间分成很多细小的时间片，一个时间片给一个程序用，另一个时间片给另一个程序用，并频繁地在程序间切换。不过，在应用程序看来，整个机器资源好像都归他使，操作系统给他提供了这种假象。 对程序员而言，我们写程序，基本不用考虑其他应用程序，我们想好怎么做自己的事就可以了。</p><p>应用程序看上去能做很多事情，能读写文档，能播放音乐，能聊天，能玩游戏，能下围棋 &#8230;&#8230; 但本质上，计算机只会执行预先写好的指令而已，这些指令也只是操作数据或者设备。所谓程序，基本上就是告诉计算机要操作的数据和执行的指令序列， 即对什么数据做什么操作。</p><p>比如说：</p><ul><li>读文档，就是将数据从磁盘加载到内存，然后输出到显示器上</li><li>写文档，就是将数据从内存写回磁盘。</li><li>播放音乐，就是将音乐的数据加载到内存，然后写到声卡上。</li><li>聊天，就是从键盘接收聊天数据，放到内存，然后传给网卡，通过网络传给另一个人的网卡，再从网卡传到内存，显示在显示器上。</li></ul><p>基本上，所有数据都需要放到内存进行处理，程序的很大一部分工作就是操作在内存中的数据。</p><p>本文主要就说说这个&#8221;数据&#8221;。（以Java为例）</p><h1>数据</h1><p>数据是什么？数据在计算机内部都是二进制，不方便操作，为了方便操作数据，高级语言引入了&#8221;数据类型&#8221;和&#8221;变量&#8221;的概念。</p><h3>数据类型</h3><p>数据类型用于对数据归类，方便理解和操作，对Java语言而言，有如下基本数据类型：</p><ul><li>整数类型：有四种整型 byte/short/int/long，分别有不同的取值范围</li><li>小数类型 ：有两种类型 float/double，有不同的取值范围和精度</li><li>字符类型：char，表示单个字符</li><li>真假类型：boolean，表示真假</li></ul><p>基本数据类型都有对应的数组类型，数组表示固定长度的同种数据类型的多条记录，这些数据在内存中挨在一起存放。 比如说，一个自然数可以用一个整数类型数据表示，100个连续的自然数可以用一个长度为100的整数数组表示。一个字符用一个char表示，一段文字可以用一个char数组表示。</p><p>Java是一个面向对象的语言，除了基本数据类型，其他都是对象类型 ，对象到底是什么呢？简单的说，对象是由基本数据类型、数组和其他对象组合而成的一个东西，以方便对其整体进行操作。</p><p>比如说，一个学生对象，可以由如下信息组成：</p><ul><li>姓名：一个字符数组</li><li>年龄：一个整数</li><li>性别：一个字符</li><li>入学分数：一个小数</li></ul><p>日期在Java中也是一个对象，内部表示为整形long。</p><p>就像世界万物的组成，都是由元素周期表中的108个基本元素组成的，基本数据类型就相当于化学中的基本元素，而对象就相当于世界万物。</p><h3>变量</h3><p>为了操作数据，需要把数据存放到内存中，所谓内存在程序看来就是一块有地址编号的连续的空间，放到内存中的某个位置后，为了方便地找到和操作这个数据，需要给这个位置起一个名字。编程语言通过<strong>变量</strong>这个概念来表示这个过程。</p><p>声明一个变量，比如 int a其实就是在内存中分配了一个空间，这个空间存放int数据类型，a指向这个内存空间所在的位置，通过对a操作即可操作a指向的内存空间，比如a=5这个操作即可将a指向的内存空间的值改为5。</p><p>之所以叫<strong>变</strong>量，是因为它表示的是内存中的位置，这个位置存放的值是可以变化的。</p><p>虽然变量的值是可以变化的，但名字是不变的，这个名字应该代表程序员心目中这块内存位置的意义，这个意义应该是不变的，比如说这个变量int second表示时钟秒数，在不同时间可以被赋予不同的值，但它表示的就是时钟秒数。之所以说<strong>应该</strong>是因为这不是必须的，如果你非要起一个变量名叫age但赋予它身高的值，计算机也拿你没办法。</p><p>重要的话再说一遍！变量就是给数据起名字，方便找不同的数据，它的值可以变，但含义不应变。再比如说一个合同，可以有四个变量：</p><ul><li>first_party: 含义是甲方</li><li>second_party: 含义是乙方</li><li>contract_body: 含义是合同内容</li><li>contract_sign_date: 含义是合同签署日期</li></ul><p>这些变量表示的含义是确定的，但对不同的合同，他们的值是不同的。</p><p>初学编程的人经常使用像a,b,c,hehe,haha这种无意义的名字，给变量起一个有意义的名字吧！</p><p>通过声明变量，每个变量赋予一个数据类型和一个有意义的名字，我们就告诉了计算机我们要操作的数据。</p><p>有了数据，怎么对数据进行操作呢？</p><div class=\"wp_rp_wrap  wp_rp_plain\" ><div class=\"wp_rp_content\"><h3 class=\"related_post_title\">相关文章</h3><ul class=\"related_post wp_rp\" style=\"visibility: visible\"><li ><a href=\"http://blog.jobbole.com/103192/\" class=\"wp_rp_title\">如何给变量取个简短且无歧义的名字</a></li><li ><a href=\"http://blog.jobbole.com/98633/\" class=\"wp_rp_title\">StackOverflow 这么大，它的架构是怎么样的？</a></li><li ><a href=\"http://blog.jobbole.com/93932/\" class=\"wp_rp_title\">你知道计算机在一秒内可以做多少事情吗？</a></li><li ><a href=\"http://blog.jobbole.com/50708/\" class=\"wp_rp_title\">程序员最头疼的事：命名</a></li><li ><a href=\"http://blog.jobbole.com/13593/\" class=\"wp_rp_title\">15 个变量和方法命名的最佳实践</a></li><li ><a href=\"http://blog.jobbole.com/50378/\" class=\"wp_rp_title\">变量教学：类比与方法</a></li><li ><a href=\"http://blog.jobbole.com/85891/\" class=\"wp_rp_title\">实战：上亿数据如何秒查</a></li><li ><a href=\"http://blog.jobbole.com/23274/\" class=\"wp_rp_title\">神舟飞天的秘密：揭秘神舟九号的太空计算机</a></li><li ><a href=\"http://blog.jobbole.com/32268/\" class=\"wp_rp_title\">如何编写计算机模拟器</a></li><li ><a href=\"http://blog.jobbole.com/33224/\" class=\"wp_rp_title\">计算机是如何启动的？</a></li></ul></div></div><p><a href=\"http://blog.jobbole.com/100329/\">计算机程序的思维逻辑 (1)：数据和变量</a>，首发于<a href=\"http://blog.jobbole.com\">文章 - 伯乐在线</a>。</p>") (wfw:commentRss nil "http://blog.jobbole.com/100329/feed/") (slash:comments nil "0")) (item nil (title nil "如何在 Linux 下检测内存泄漏") (link nil "http://blog.jobbole.com/104042/") (comments nil "http://blog.jobbole.com/104042/#respond") (pubDate nil "Mon, 01 Aug 2016 03:17:32 +0000") (dc:creator nil "中二饼") (category nil "C/C++") (category nil "开发") (category nil "C++") (category nil "Linux") (category nil "内存泄漏") (guid ((isPermaLink . "false")) "http://blog.jobbole.com/?p=104042") (description nil "<p>本文针对 linux 下的 C++ 程序的内存泄漏的检测方法及其实现进行探讨。其中包括 C++ 中的 new 和 delete 的基本原理，内存检测子系统的实现原理和具体方法，以及内存泄漏检测的高级话题。作为内存检测子系统实现的一部分，提供了一个具有更好的使用特性的互斥体（Mutex）类。</p><p><a href=\"http://blog.jobbole.com/104042/\">如何在 Linux 下检测内存泄漏</a>，首发于<a href=\"http://blog.jobbole.com\">文章 - 伯乐在线</a>。</p>") (content:encoded nil "<div><h1>1．开发背景</h1></div><div><p style=\"text-align: justify\">在 windows 下使用 VC 编程时，我们通常需要 DEBUG 模式下运行程序，而后调试器将在退出程序时，打印出程序运行过程中在堆上分配而没有释放的内存信息，其中包括代码文件名、行号以及内存大小。该功能是 MFC Framework 提供的内置机制，封装在其类结构体系内部。</p><p style=\"text-align: justify\">在 linux 或者 unix 下，我们的 C++ 程序缺乏相应的手段来检测内存信息，而只能使用 top 指令观察进程的动态内存总额。而且程序退出时，我们无法获知任何内存泄漏信息。为了更好的辅助在 linux 下程序开发，我们在我们的类库项目中设计并实现了一个内存检测子系统。下文将简述 C++ 中的 new 和 delete 的基本原理，并讲述了内存检测子系统的实现原理、实现中的技巧，并对内存泄漏检测的高级话题进行了讨论。</p><h1 id=\"N10035\">2．New和delete的原理</h1><p style=\"text-align: justify\">当我们在程序中写下 new 和 delete 时，我们实际上调用的是 C++ 语言内置的 new operator 和 delete operator。所谓语言内置就是说我们不能更改其含义，它的功能总是一致的。以 new operator 为例，它总是先分配足够的内存，而后再调用相应的类型的构造函数初始化该内存。而 delete operator 总是先调用该类型的析构函数，而后释放内存（图1）。我们能够施加影响力的事实上就是 new operator 和 delete operator 执行过程中分配和释放内存的方法。</p><p style=\"text-align: justify\">new operator 为分配内存所调用的函数名字是 operator new，其通常的形式是 void * operator new(size_t size); 其返回值类型是 void*，因为这个函数返回一个未经处理（raw）的指针，未初始化的内存。参数 size 确定分配多少内存，你能增加额外的参数重载函数 operator new，但是第一个参数类型必须是 size_t。</p><p style=\"text-align: justify\">delete operator 为释放内存所调用的函数名字是 operator delete，其通常的形式是 void operator delete(void *memoryToBeDeallocated)；它释放传入的参数所指向的一片内存区。</p><p style=\"text-align: justify\">这里有一个问题，就是当我们调用 new operator 分配内存时，有一个 size 参数表明需要分配多大的内存。但是当调用 delete operator 时，却没有类似的参数，那么 delete operator 如何能够知道需要释放该指针指向的内存块的大小呢？答案是：对于系统自有的数据类型，语言本身就能区分内存块的大小，而对于自定义数据类型（如我们自定义的类），则 operator new 和 operator delete 之间需要互相传递信息。</p><p style=\"text-align: justify\">当我们使用 operator new 为一个自定义类型对象分配内存时，实际上我们得到的内存要比实际对象的内存大一些，这些内存除了要存储对象数据外，还需要记录这片内存的大小，此方法称为 cookie。这一点上的实现依据不同的编译器不同。（例如 MFC 选择在所分配内存的头部存储对象实际数据，而后面的部分存储边界标志和内存大小信息。g++ 则采用在所分配内存的头 4 个自己存储相关信息，而后面的内存存储对象实际数据。）当我们使用 delete operator 进行内存释放操作时，delete operator 就可以根据这些信息正确的释放指针所指向的内存块。</p><p style=\"text-align: justify\">以上论述的是对于单个对象的内存分配/释放，当我们为数组分配/释放内存时，虽然我们仍然使用 new operator 和 delete operator，但是其内部行为却有不同：new operator 调用了operator new 的数组版的兄弟－ operator new[]，而后针对每一个数组成员调用构造函数。而 delete operator 先对每一个数组成员调用析构函数，而后调用 operator delete[] 来释放内存。需要注意的是，当我们创建或释放由自定义数据类型所构成的数组时，编译器为了能够标识出在 operator delete[] 中所需释放的内存块的大小，也使用了编译器相关的 cookie 技术。</p><p style=\"text-align: justify\">综上所述，如果我们想检测内存泄漏，就必须对程序中的内存分配和释放情况进行记录和分析，也就是说我们需要重载 operator new/operator new[];operator delete/operator delete[] 四个全局函数，以截获我们所需检验的内存操作信息。</p><h1 id=\"N10048\">3．内存检测的基本实现原理</h1><p style=\"text-align: justify\">上文提到要想检测内存泄漏，就必须对程序中的内存分配和释放情况进行记录，所能够采取的办法就是重载所有形式的operator new 和 operator delete，截获 new operator 和 delete operator 执行过程中的内存操作信息。下面列出的就是重载形式</p><div><pre class=\"crayon-plain-tag\">void* operator new( size_t nSize, char* pszFileName, int nLineNum )
void* operator new[]( size_t nSize, char* pszFileName, int nLineNum )
void operator delete( void *ptr )
void operator delete[]( void *ptr )</pre></div><p style=\"text-align: justify\">我们为 operator new 定义了一个新的版本，除了必须的 size_t nSize 参数外，还增加了文件名和行号，这里的文件名和行号就是这次 new operator 操作符被调用时所在的文件名和行号，这个信息将在发现内存泄漏时输出，以帮助用户定位泄漏具体位置。对于 operator delete，因为无法为之定义新的版本，我们直接覆盖了全局的 operator delete 的两个版本。</p><p style=\"text-align: justify\">在重载的 operator new 函数版本中，我们将调用全局的 operator new 的相应的版本并将相应的 size_t 参数传入，而后，我们将全局 operator new 返回的指针值以及该次分配所在的文件名和行号信息记录下来，这里所采用的数据结构是一个 STL 的 map，以指针值为 key 值。当 operator delete 被调用时，如果调用方式正确的话（调用方式不正确的情况将在后面详细描述），我们就能以传入的指针值在 map 中找到相应的数据项并将之删除，而后调用 free 将指针所指向的内存块释放。当程序退出的时候，map 中的剩余的数据项就是我们企图检测的内存泄漏信息－－已经在堆上分配但是尚未释放的分配信息。</p><p style=\"text-align: justify\">以上就是内存检测实现的基本原理，现在还有两个基本问题没有解决：</p><p style=\"text-align: justify\">1) 如何取得内存分配代码所在的文件名和行号，并让 new operator 将之传递给我们重载的 operator new。</p><p style=\"text-align: justify\">2) 我们何时创建用于存储内存数据的 map 数据结构，如何管理，何时打印内存泄漏信息。</p><p style=\"text-align: justify\">先解决问题1。首先我们可以利用 C 的预编译宏 __FILE__ 和 __LINE__，这两个宏将在编译时在指定位置展开为该文件的文件名和该行的行号。而后我们需要将缺省的全局 new operator 替换为我们自定义的能够传入文件名和行号的版本，我们在子系统头文件 MemRecord.h 中定义：</p><div><pre class=\"crayon-plain-tag\">#define DEBUG_NEW new(__FILE__, __LINE__ )</pre></div><p style=\"text-align: justify\">而后在所有需要使用内存检测的客户程序的所有的 cpp 文件的开头加入</p><div><pre class=\"crayon-plain-tag\">#include \"MemRecord.h\"
#define new DEBUG_NEW</pre></div><p style=\"text-align: justify\">就可以将客户源文件中的对于全局缺省的 new operator 的调用替换为 new (__FILE__,__LINE__) 调用，而该形式的new operator将调用我们的operator new (size_t nSize, char* pszFileName, int nLineNum)，其中 nSize 是由 new operator 计算并传入的，而 new 调用点的文件名和行号是由我们自定义版本的 new operator 传入的。我们建议在所有用户自己的源代码文件中都加入上述宏，如果有的文件中使用内存检测子系统而有的没有，则子系统将可能因无法监控整个系统而输出一些泄漏警告。</p><p style=\"text-align: justify\">再说第二个问题。我们用于管理客户信息的这个 map 必须在客户程序第一次调用 new operator 或者 delete operator 之前被创建，而且在最后一个 new operator 和 delete operator 调用之后进行泄漏信息的打印，也就是说它需要先于客户程序而出生，而在客户程序退出之后进行分析。能够包容客户程序生命周期的确有一人&#8211;全局对象（appMemory）。我们可以设计一个类来封装这个 map 以及这对它的插入删除操作，然后构造这个类的一个全局对象（appMemory），在全局对象（appMemory）的构造函数中创建并初始化这个数据结构，而在其析构函数中对数据结构中剩余数据进行分析和输出。Operator new 中将调用这个全局对象（appMemory）的 insert 接口将指针、文件名、行号、内存块大小等信息以指针值为 key 记录到 map 中，在 operator delete 中调用 erase 接口将对应指针值的 map 中的数据项删除，注意不要忘了对 map 的访问需要进行互斥同步，因为同一时间可能会有多个线程进行堆上的内存操作。</p><p style=\"text-align: justify\">好啦，内存检测的基本功能已经具备了。但是不要忘了，我们为了检测内存泄漏，在全局的 operator new 增加了一层间接性，同时为了保证对数据结构的安全访问增加了互斥，这些都会降低程序运行的效率。因此我们需要让用户能够方便的 enable 和 disable 这个内存检测功能，毕竟内存泄漏的检测应该在程序的调试和测试阶段完成。我们可以使用条件编译的特性，在用户被检测文件中使用如下宏定义：</p><div><pre class=\"crayon-plain-tag\">#include \"MemRecord.h\"
#if defined( MEM_DEBUG )
#define new DEBUG_NEW
#endif</pre></div><p style=\"text-align: justify\">当用户需要使用内存检测时，可以使用如下命令对被检测文件进行编译</p><div><pre class=\"crayon-plain-tag\">g++ -c -DMEM_DEBUG xxxxxx.cpp</pre></div><p style=\"text-align: justify\">就可以 enable 内存检测功能，而用户程序正式发布时，可以去掉 -DMEM_DEBUG 编译开关来 disable 内存检测功能，消除内存检测带来的效率影响。</p><p>图2所示为使用内存检测功能后，内存泄漏代码的执行以及检测结果</p><p style=\"text-align: center\"><img class=\"aligncenter\" src=\"http://www.ibm.com/developerworks/cn/linux/l-mleak/images/image002.jpg\" /><br />
图2</p><h1 id=\"N10088\">4．错误方式删除带来的问题</h1><p style=\"text-align: justify\">以上我们已经构建了一个具备基本内存泄漏检测功能的子系统，下面让我们来看一下关于内存泄漏方面的一些稍微高级一点的话题。</p><p style=\"text-align: justify\">首先，在我们编制 c++ 应用时，有时需要在堆上创建单个对象，有时则需要创建对象的数组。关于 new 和 delete 原理的叙述我们可以知道，对于单个对象和对象数组来说，内存分配和删除的动作是大不相同的，我们应该总是正确的使用彼此搭配的 new 和 delete 形式。但是在某些情况下，我们很容易犯错误，比如如下代码：</p><div><pre class=\"crayon-plain-tag\">class Test {};
		……
		Test* pAry = new Test[10];//创建了一个拥有 10 个 Test 对象的数组
		Test* pObj = new Test;//创建了一个单对象
		……
		delete []pObj;//本应使用单对象形式 delete pObj 进行内存释放，却错误的使用了数
//组形式
		delete pAry;//本应使用数组形式 delete []pAry 进行内存释放，却错误的使用了单对
//象的形式</pre></div><p style=\"text-align: justify\">不匹配的 new 和 delete 会导致什么问题呢？C++ 标准对此的解答是&#8221;未定义&#8221;，就是说没有人向你保证会发生什么，但是有一点可以肯定：大多不是好事情&#8211;在某些编译器形成的代码中，程序可能会崩溃，而另外一些编译器形成的代码中，程序运行可能毫无问题，但是可能导致内存泄漏。</p><p style=\"text-align: justify\">既然知道形式不匹配的 new 和 delete 会带来的问题，我们就需要对这种现象进行毫不留情的揭露，毕竟我们重载了所有形式的内存操作 operator new，operator new[]，operator delete，operator delete[]。</p><p style=\"text-align: justify\">我们首先想到的是，当用户调用特定方式（单对象或者数组方式）的 operator new 来分配内存时，我们可以在指向该内存的指针相关的数据结构中，增加一项用于描述其分配方式。当用户调用不同形式的 operator delete 的时候，我们在 map 中找到与该指针相对应的数据结构，然后比较分配方式和释放方式是否匹配，匹配则在 map 中正常删除该数据结构，不匹配则将该数据结构转移到一个所谓 &#8220;ErrorDelete&#8221; 的 list 中，在程序最终退出的时候和内存泄漏信息一起打印。</p><p style=\"text-align: justify\">上面这种方法是最顺理成章的，但是在实际应用中效果却不好。原因有两个，第一个原因我们上面已经提到了：当 new 和 delete 形式不匹配时，其结果&#8221;未定义&#8221;。如果我们运气实在太差&#8211;程序在执行不匹配的 delete 时崩溃了，我们的全局对象（appMemory）中存储的数据也将不复存在，不会打印出任何信息。第二个原因与编译器相关，前面提到过，当编译器处理自定义数据类型或者自定义数据类型数组的 new 和 delete 操作符的时候，通常使用编译器相关的 cookie 技术。这种 cookie 技术在编译器中可能的实现方式是：new operator 先计算容纳所有对象所需的内存大小，而后再加上它为记录 cookie 所需要的内存量，再将总容量传给operator new 进行内存分配。当 operator new 返回所需的内存块后，new operator 将在调用相应次数的构造函数初始化有效数据的同时，记录 cookie 信息。而后将指向有效数据的指针返回给用户。也就是说我们重载的 operator new 所申请到并记录下来的指针与 new operator 返回给调用者的指针不一定一致（图3）。当调用者将 new operator 返回的指针传给 delete operator 进行内存释放时，如果其调用形式相匹配，则相应形式的 delete operator 会作出相反的处理，即调用相应次数的析构函数，再通过指向有效数据的指针位置找出包含 cookie 的整块内存地址，并将其传给 operator delete 释放内存。如果调用形式不匹配，delete operator 就不会做上述运算，而直接将指向有效数据的指针（而不是真正指向整块内存的指针）传入 operator delete。因为我们在 operator new 中记录的是我们所分配的整块内存的指针，而现在传入 operator delete 的却不是，所以就无法在全局对象（appMemory）所记录的数据中找到相应的内存分配信息。</p><p style=\"text-align: center\"><img class=\"aligncenter\" src=\"http://www.ibm.com/developerworks/cn/linux/l-mleak/images/image005.jpg\" /><br />
图3</p><p style=\"text-align: justify\">综上所述，当 new 和 delete 的调用形式不匹配时，由于程序有可能崩溃或者内存子系统找不到相应的内存分配信息，在程序最终打印出 &#8220;ErrorDelete&#8221; 的方式只能检测到某些&#8221;幸运&#8221;的不匹配现象。但我们总得做点儿什么，不能让这种危害极大的错误从我们眼前溜走，既然不能秋后算帐，我们就实时输出一个 warning 信息来提醒用户。什么时候抛出一个 warning 呢？很简单，当我们发现在 operator delete 或 operator delete[] 被调用的时候，我们无法在全局对象（appMemory）的 map 中找到与传入的指针值相对应的内存分配信息，我们就认为应该提醒用户。</p><p style=\"text-align: justify\">既然决定要输出warning信息，那么现在的问题就是：我们如何描述我们的warning信息才能更便于用户定位到不匹配删除错误呢？答案：在 warning 信息中打印本次 delete 调用的文件名和行号信息。这可有点困难了，因为对于 operator delete 我们不能向对象 operator new 一样做出一个带附加信息的重载版本，我们只能在保持其接口原貌的情况下，重新定义其实现，所以我们的 operator delete 中能够得到的输入只有指针值。在 new/delete 调用形式不匹配的情况下，我们很有可能无法在全局对象（appMemory）的 map 中找到原来的 new 调用的分配信息。怎么办呢？万不得已，只好使用全局变量了。我们在检测子系统的实现文件中定义了两个全局变量（DELETE_FILE,DELETE_LINE）记录 operator delete 被调用时的文件名和行号，同时为了保证并发的 delete 操作对这两个变量访问同步，还使用了一个 mutex（至于为什么是 CCommonMutex 而不是一个 pthread_mutex_t，在&#8221;实现上的问题&#8221;一节会详细论述，在这里它的作用就是一个 mutex）。</p><div><pre class=\"crayon-plain-tag\">char DELETE_FILE[ FILENAME_LENGTH ] = {0};
int DELETE_LINE = 0;
CCommonMutex globalLock;</pre></div><p style=\"text-align: justify\">而后，在我们的检测子系统的头文件中定义了如下形式的 DEBUG_DELETE</p><div><pre class=\"crayon-plain-tag\">extern char DELETE_FILE[ FILENAME_LENGTH ];
extern int DELETE_LINE;
extern CCommonMutex globalLock;//在后面解释
#define DEBUG_DELETE 	globalLock.Lock(); 
			if (DELETE_LINE != 0) BuildStack(); （//见第六节解释）
			strncpy( DELETE_FILE, __FILE__,FILENAME_LENGTH - 1 );
			DELETE_FILE[ FILENAME_LENGTH - 1 ]= ''; 
			DELETE_LINE = __LINE__; 
			delete</pre></div><p style=\"text-align: justify\">在用户被检测文件中原来的宏定义中添加一条：</p><div><pre class=\"crayon-plain-tag\">#include \"MemRecord.h\"
#if defined( MEM_DEBUG )
#define new DEBUG_NEW
#define delete DEBUG_DELETE
#endif</pre></div><p style=\"text-align: justify\">这样，在用户被检测文件调用 delete operator 之前，将先获得互斥锁，然后使用调用点文件名和行号对相应的全局变量（DELETE_FILE,DELETE_LINE）进行赋值，而后调用 delete operator。当 delete operator 最终调用我们定义的 operator delete 的时候，在获得此次调用的文件名和行号信息后，对文件名和行号全局变量（DELETE_FILE,DELETE_LINE）重新初始化并打开互斥锁，让下一个挂在互斥锁上的 delete operator 得以执行。</p><p style=\"text-align: justify\">在对 delete operator 作出如上修改以后，当我们发现无法经由 delete operator 传入的指针找到对应的内存分配信息的时候，就打印包括该次调用的文件名和行号的 warning。</p><p style=\"text-align: justify\">天下没有十全十美的事情，既然我们提供了一种针对错误方式删除的提醒方法，我们就需要考虑以下几种异常情况：</p><p style=\"text-align: justify\">1． 用户使用的第三方库函数中有内存分配和释放操作。或者用户的被检测进程中进行内存分配和释放的实现文件没有使用我们的宏定义。 由于我们替换了全局的 operator delete，这种情况下的用户调用的 delete 也会被我们截获。用户并没有使用我们定义的DEBUG_NEW 宏，所以我们无法在我们的全局对象（appMemory）数据结构中找到对应的内存分配信息，但是由于它也没有使用DEBUG_DELETE，我们为 delete 定义的两个全局 DELETE_FILE 和 DELETE_LINE 都不会有值，因此可以不打印 warning。</p><p style=\"text-align: justify\">2． 用户的一个实现文件调用了 new 进行内存分配工作，但是该文件并没有使用我们定义的 DEBUG_NEW 宏。同时用户的另一个实现文件中的代码负责调用 delete 来删除前者分配的内存，但不巧的是，这个文件使用了 DEBUG_DELETE 宏。这种情况下内存检测子系统会报告 warning，并打印出 delete 调用的文件名和行号。</p><p style=\"text-align: justify\">3． 与第二种情况相反，用户的一个实现文件调用了 new 进行内存分配工作，并使用我们定义的 DEBUG_NEW 宏。同时用户的另一个实现文件中的代码负责调用 delete 来删除前者分配的内存，但该文件没有使用 DEBUG_DELETE 宏。这种情况下，因为我们能够找到这个内存分配的原始信息，所以不会打印 warning。</p><p style=\"text-align: justify\">4． 当出现嵌套 delete（定义可见&#8221;实现上的问题&#8221;）的情况下，以上第一和第三种情况都有可能打印出不正确的 warning 信息，详细分析可见&#8221;实现上的问题&#8221;一节。</p><p style=\"text-align: justify\">你可能觉得这样的 warning 太随意了，有误导之嫌。怎么说呢？作为一个检测子系统，对待有可能的错误我们所采取的原则是：宁可误报，不可漏报。请大家&#8221;有则改之，无则加勉&#8221;。</p><h1 id=\"N100CB\">5．动态内存泄漏信息的检测</h1><p style=\"text-align: justify\">上面我们所讲述的内存泄漏的检测能够在程序整个生命周期结束时，打印出在程序运行过程中已经在堆上分配但是没有释放的内存分配信息，程序员可以由此找到程序中&#8221;显式&#8221;的内存泄漏点并加以改正。但是如果程序在结束之前能够将自己所分配的所有内存都释放掉，是不是就可以说这个程序不存在内存泄漏呢？答案：否！在编程实践中，我们发现了另外两种危害性更大的&#8221;隐式&#8221;内存泄漏，其表现就是在程序退出时，没有任何内存泄漏的现象，但是在程序运行过程中，内存占用量却不断增加，直到使整个系统崩溃。</p><p style=\"text-align: justify\">1． 程序的一个线程不断分配内存，并将指向内存的指针保存在一个数据存储中（如 list），但是在程序运行过程中，一直没有任何线程进行内存释放。当程序退出的时候，该数据存储中的指针值所指向的内存块被依次释放。</p><p style=\"text-align: justify\">2． 程序的N个线程进行内存分配，并将指针传递给一个数据存储，由M个线程从数据存储进行数据处理和内存释放。由于 N 远大于M，或者M个线程数据处理的时间过长，导致内存分配的速度远大于内存被释放的速度。但是在程序退出的时候，数据存储中的指针值所指向的内存块被依次释放。</p><p style=\"text-align: justify\">之所以说他危害性更大，是因为很不容易这种问题找出来，程序可能连续运行几个十几个小时没有问题，从而通过了不严密的系统测试。但是如果在实际环境中 7×24 小时运行，系统将不定时的崩溃，而且崩溃的原因从 log 和程序表象上都查不出原因。</p><p style=\"text-align: justify\">为了将这种问题也挑落马下，我们增加了一个动态检测模块 MemSnapShot，用于在程序运行过程中，每隔一定的时间间隔就对程序当前的内存总使用情况和内存分配情况进行统计，以使用户能够对程序的动态内存分配状况进行监视。</p><p style=\"text-align: justify\">当客户使用 MemSnapShot 进程监视一个运行中的进程时，被监视进程的内存子系统将把内存分配和释放的信息实时传送给MemSnapShot。MemSnapShot 则每隔一定的时间间隔就对所接收到的信息进行统计，计算该进程总的内存使用量，同时以调用new进行内存分配的文件名和行号为索引值，计算每个内存分配动作所分配而未释放的内存总量。这样一来，如果在连续多个时间间隔的统计结果中，如果某文件的某行所分配的内存总量不断增长而始终没有到达一个平衡点甚至回落，那它一定是我们上面所说到的两种问题之一。</p><p style=\"text-align: justify\">在实现上，内存检测子系统的全局对象（appMemory）的构造函数中以自己的当前 PID 为基础 key 值创建一个消息队列，并在operator new 和 operator delete 被调用的时候将相应的信息写入消息队列。MemSnapShot 进程启动时需要输入被检测进程的 PID，而后通过该 PID 组装 key 值并找到被检测进程创建的消息队列，并开始读入消息队列中的数据进行分析统计。当得到operator new 的信息时，记录内存分配信息，当收到 operator delete 消息时，删除相应的内存分配信息。同时启动一个分析线程，每隔一定的时间间隔就计算一下当前的以分配而尚未释放的内存信息，并以内存的分配位置为关键字进行统计，查看在同一位置（相同文件名和行号）所分配的内存总量和其占进程总内存量的百分比。</p><p style=\"text-align: justify\">图4 是一个正在运行的 MemSnapShot 程序，它所监视的进程的动态内存分配情况如图所示：</p><p style=\"text-align: center\"><img class=\"aligncenter\" src=\"http://www.ibm.com/developerworks/cn/linux/l-mleak/images/image006.jpg\" /><br />
图四</p><p style=\"text-align: justify\">在支持 MemSnapShot 过程中的实现上的唯一技巧是&#8211;对于被检测进程异常退出状况的处理。因为被检测进程中的内存检测子系统创建了用于进程间传输数据的消息队列，它是一个核心资源，其生命周期与内核相同，一旦创建，除非显式的进行删除或系统重启，否则将不被释放。</p><p style=\"text-align: justify\">不错，我们可以在内存检测子系统中的全局对象（appMemory）的析构函数中完成对消息队列的删除，但是如果被检测进程非正常退出（CTRL+C，段错误崩溃等），消息队列可就没人管了。那么我们可以不可以在全局对象（appMemory）的构造函数中使用 signal 系统调用注册 SIGINT，SIGSEGV 等系统信号处理函数，并在处理函数中删除消息队列呢？还是不行，因为被检测进程完全有可能注册自己的对应的信号处理函数，这样就会替换我们的信号处理函数。最终我们采取的方法是利用 fork 产生一个孤儿进程，并利用这个进程监视被检测进程的生存状况，如果被检测进程已经退出（无论正常退出还是异常退出），则试图删除被检测进程所创建的消息队列。下面简述其实现原理：</p><p style=\"text-align: justify\">在全局对象（appMemory）构造函数中，创建消息队列成功以后，我们调用 fork 创建一个子进程，而后该子进程再次调用 fork 创建孙子进程，并退出，从而使孙子进程变为一个&#8221;孤儿&#8221;进程（之所以使用孤儿进程是因为我们需要切断被检测进程与我们创建的进程之间的信号联系）。孙子进程利用父进程（被检测进程）的全局对象（appMemory）得到其 PID 和刚刚创建的消息队列的标识，并传递给调用 exec 函数产生的一个新的程序映象&#8211;MemCleaner。</p><p style=\"text-align: justify\">MemCleaner 程序仅仅调用 kill(pid, 0);函数来查看被检测进程的生存状态，如果被检测进程不存在了（正常或者异常退出），则 kill 函数返回非 0 值，此时我们就动手清除可能存在的消息队列。</p><h1 id=\"N100F2\">6．实现上的问题：嵌套delete</h1><p style=\"text-align: justify\">在&#8221;错误方式删除带来的问题&#8221;一节中，我们对 delete operator 动了个小手术&#8211;增加了两个全局变量（DELETE_FILE,DELETE_LINE）用于记录本次 delete 操作所在的文件名和行号，并且为了同步对全局变量（DELETE_FILE,DELETE_LINE）的访问，增加了一个全局的互斥锁。在一开始，我们使用的是 pthread_mutex_t，但是在测试中，我们发现 pthread_mutex_t 在本应用环境中的局限性。</p><p style=\"text-align: justify\">例如如下代码：</p><div><pre class=\"crayon-plain-tag\">class B {…};
			class A {
			public:
				A() {m_pB = NULL};
				A(B* pb) {m_pB = pb;};
				~A() 
                                {
                                       if (m_pB != NULL)
       					delete m_pB;		//这句最要命
                                 };
			private:
				class B* m_pB;
				……
			}
		int main()
		{
			A* pA = new A(new B);
			……
   	                   delete pA;		
                }</pre></div><p style=\"text-align: justify\">在上述代码中，main 函数中的一句 delete pA 我们称之为&#8221;嵌套删除&#8221;，即我们 delete A 对象的时候，在A对象的析构执行了另一个 delete B 的动作。当用户使用我们的内存检测子系统时，delete pA 的动作应转化为以下动作：</p><div><pre class=\"crayon-plain-tag\">上全局锁
	        全局变量（DELETE_FILE,DELETE_LINE）赋值为文件名和行号2
                delete operator A
                  调用~A()
	            上全局锁
	            全局变量（DELETE_FILE,DELETE_LINE）赋值为文件名和行号1
	            delete operator B
		      调用~B()
                      返回~B()
		      调用operator delete B
			记录全局变量（DELETE_FILE,DELETE_LINE）值1并清除全局变量（DELETE_FILE,DELETE_LINE）值
			打开全局锁
		    返回operator delete B
	        返回delete operator B
             返回~A()
         调用 operator delete A
	   记录全局变量（DELETE_FILE,DELETE_LINE）值1并清除全局变量（DELETE_FILE,DELETE_LINE）值
	   打开全局锁
	 返回operator delete A
      返回 delete operator A</pre></div><p style=\"text-align: justify\">在这一过程中，有两个技术问题，一个是 <strong>mutex 的可重入问题</strong>，一个是嵌套删除时 <strong>对全局变量（DELETE_FILE,DELETE_LINE）</strong>现场保护的问题。</p><p style=\"text-align: justify\">所谓 <strong>mutex 的可重入问题</strong>，是指在同一个线程上下文中，连续对同一个 mutex 调用了多次 lock，然后连续调用了多次 unlock。这就是说我们的应用方式要求互斥锁有如下特性：</p><p style=\"text-align: justify\">1． 要求在同一个线程上下文中，能够多次持有同一个互斥体。并且只有在同一线程上下文中调用相同次数的 unlock 才能放弃对互斥体的占有。</p><p style=\"text-align: justify\">2． 对于不同线程上下文持有互斥体的企图，同一时间只有一个线程能够持有互斥体，并且只有在其释放互斥体之后，其他线程才能持有该互斥体。</p><p style=\"text-align: justify\">Pthread_mutex_t 互斥体不具有以上特性，即使在同一上下文中，第二次调用 pthread_mutex_lock 将会挂起。因此，我们必须实现出自己的互斥体。在这里我们使用 semaphore 的特性实现了一个符合上述特性描述的互斥体 CCommonMutex（源代码见附件）。</p><p style=\"text-align: justify\">为了支持特性 2，在这个 CCommonMutex 类中，封装了一个 semaphore，并在构造函数中令其资源值为 1，初始值为1。当调用 CCommonMutex::lock 接口时，调用 sem_wait 得到 semaphore，使信号量的资源为 0 从而让其他调用 lock 接口的线程挂起。当调用接口 CCommonMutex::unlock 时，调用 sem_post 使信号量资源恢复为 1，让其他挂起的线程中的一个持有信号量。</p><p style=\"text-align: justify\">同时为了支持特性 1，在这个 CCommonMutex 增加了对于当前线程 pid 的判断和当前线程访问计数。当线程第一次调用 lock 接口时，我们调用 sem_wait 的同时，记录当前的 Pid 到成员变量 m_pid，并置访问计数为 1，同一线程（m_pid == getpid()）其后的多次调用将只进行计数而不挂起。当调用 unlock 接口时，如果计数不为 1，则只需递减访问计数，直到递减访问计数为 1 才进行清除 pid、调用 sem_post。（具体代码可见附件）</p><p style=\"text-align: justify\"><strong>嵌套删除时对全局变量（DELETE_FILE,DELETE_LINE）</strong>现场保护的问题是指，上述步骤中在 A 的析构函数中调用 delete m_pB 时，对全局变量（DELETE_FILE,DELETE_LINE）文件名和行号的赋值将覆盖主程序中调用 delete pA 时对全局变量（DELETE_FILE,DELETE_LINE）的赋值，造成了在执行 operator delete A 时，delete pA 的信息全部丢失。</p><p style=\"text-align: justify\">要想对这些全局信息进行现场保护，最好用的就是堆栈了，在这里我们使用了 STL 提供的 stack 容器。在 DEBUG_DELETE 宏定义中，对全局变量（DELETE_FILE,DELETE_LINE）赋值之前，我们先判断是否前面已经有人对他们赋过值了&#8211;观察行号变量是否等于 0，如果不为 0，则应该将已有的信息压栈（调用一个全局函数 BuildStack() 将当前的全局文件名和行号数据压入一个全局堆栈globalStack），而后再对全局变量（DELETE_FILE,DELETE_LINE）赋值，再调用 delete operator。而在内存子系统的全局对象（appMemory）提供的 erase 接口里面，如果判断传入的文件名和行号为 0，则说明我们所需要的数据有可能被嵌套删除覆盖了，所以需要从堆栈中弹出相应的数据进行处理。</p><p style=\"text-align: justify\">现在嵌套删除中的问题基本解决了，但是当嵌套删除与 &#8220;错误方式删除带来的问题&#8221;一节的最后所描述的第一和第三种异常情况同时出现的时候，由于用户的 delete 调用没有通过我们定义的 DEBUG_DELETE 宏，上述机制可能出现问题。其根本原因是我们利用stack 保留了经由我们的 DEBUG_DELETE 宏记录的 delete 信息的现场，以便在 operator delete 和全局对象（appMemory）的 erase 接口中使用，但是用户的没经过 DEBUG_DELETE 宏的 delete 操作却未曾进行压栈操作而直接调用了 operator delete，有可能将不属于这次操作的 delete 信息弹出，破坏了堆栈信息的顺序和有效性。那么，当我们因为无法找到这次及其后续的 delete 操作所对应的内存分配信息的时候，可能会打印出错误的 warning 信息。</p><h1 id=\"N10124\">展望</h1><p style=\"text-align: justify\">以上就是我们所实现的内存泄漏检测子系统的原理和技术方案，第一版的源代码在附件中，已经经过了较严格的系统测试。但是限于我们的 C++ 知识水平和编程功底，在实现过程中肯定还有没有注意到的地方甚至是缺陷，希望能够得到大家的指正，我的 email 是 <a href=\"mailto:hcode@21cn.com\">hcode@21cn.com</a>。</p><p style=\"text-align: justify\">在我们所实现的内存检测子系统基础上，可以继续搭建内存分配优化子系统，从而形成一个完整的内存子系统。一种内存分配优化子系统的实现方案是一次性分配大块的内存，并使用特定的数据结构管理之，当内存分配请求到来时，使用特定算法从这块大内存中划定所需的一块给用户使用，而用户使用完毕，在将其划为空闲内存。这种内存优化方式将内存分配释放转换为简单的数据处理，极大的减少了内存申请和释放所耗费的时间。</p><p></p></div><div class=\"wp_rp_wrap  wp_rp_plain\" ><div class=\"wp_rp_content\"><h3 class=\"related_post_title\">相关文章</h3><ul class=\"related_post wp_rp\" style=\"visibility: visible\"><li ><a href=\"http://blog.jobbole.com/94497/\" class=\"wp_rp_title\">Linux 动态库相关知识整理</a></li><li ><a href=\"http://blog.jobbole.com/95375/\" class=\"wp_rp_title\">C/C++内存泄漏及检测</a></li><li ><a href=\"http://blog.jobbole.com/103640/\" class=\"wp_rp_title\">Linux 平台相关代码的 C++ 解决方案</a></li><li ><a href=\"http://blog.jobbole.com/104080/\" class=\"wp_rp_title\">编写高质量代码</a></li><li ><a href=\"http://blog.jobbole.com/103596/\" class=\"wp_rp_title\">Linux 下 C++ 异常处理技巧</a></li><li ><a href=\"http://blog.jobbole.com/80617/\" class=\"wp_rp_title\">C 语言中的指针和内存泄漏</a></li><li ><a href=\"http://blog.jobbole.com/88279/\" class=\"wp_rp_title\">Linux 内核里的“智能指针”</a></li><li ><a href=\"http://blog.jobbole.com/104032/\" class=\"wp_rp_title\">面向 C++ 的测试驱动开发</a></li><li ><a href=\"http://blog.jobbole.com/103669/\" class=\"wp_rp_title\">C++11 中的 Defaulted 和 Deleted 函数</a></li><li ><a href=\"http://blog.jobbole.com/86958/\" class=\"wp_rp_title\">如何用C++在不按回车的情况下获取标准输入中的字符</a></li></ul></div></div><p><a href=\"http://blog.jobbole.com/104042/\">如何在 Linux 下检测内存泄漏</a>，首发于<a href=\"http://blog.jobbole.com\">文章 - 伯乐在线</a>。</p>") (wfw:commentRss nil "http://blog.jobbole.com/104042/feed/") (slash:comments nil "0")) (item nil (title nil "面向 C++ 的测试驱动开发") (link nil "http://blog.jobbole.com/104032/") (comments nil "http://blog.jobbole.com/104032/#respond") (pubDate nil "Mon, 01 Aug 2016 03:04:44 +0000") (dc:creator nil "中二饼") (category nil "C/C++") (category nil "开发") (category nil "C++") (category nil "Linux") (guid ((isPermaLink . "false")) "http://blog.jobbole.com/?p=104032") (description nil "<p>用测试的方法驱动开发，这个概念的提出已经很长时间了，但测试驱动开发在 C 和 C++的应用和实践却比较晚，本文用一个简单项目的实例说明如何在 C 和 C++的开发过程中，应用测试驱动开发的理念，从需求定义，代码测试案例设计到开发实现这些案例定义的需求，展现了测试驱动开发的魅力。</p><p><a href=\"http://blog.jobbole.com/104032/\">面向 C++ 的测试驱动开发</a>，首发于<a href=\"http://blog.jobbole.com\">文章 - 伯乐在线</a>。</p>") (content:encoded nil "<div><h1>测试驱动开发（TDD）背景及综述</h1></div><div><p>测试驱动开发是 Kent 提出的一种新的软件开发流程，现在已广为人知，这种开发方法依赖于极短重复的开发周期，面对开发需求，开发人员要先开发代码测试用例，这些代码实现的测试用例定义了工程要实现的需求，然后去开发代码快速测试通过这这些用例，这个时候的代码是相对比较粗糙的，只是为了通过这个测试，测试通过以后，这些测试所覆盖的需求就会相对固定下来了，然后随着实现更多的需求，以前实现的那些粗糙的代码的问题会逐步的暴露出来，此时就要用重构来消除重复改进代码设计，因为自动化的测试用例已经框定了相应的需求，这样在代码改进和重构的过程中就不会破坏已实现的需求，实现了安全重构。</p><p>从测试驱动开发的流程可以看出来，测试驱动开发仅仅要求一个简单的设计开始实现需求，然后随着软件开发的推进实现有保护重构代码和设计。依赖于 TDD 开发所生成的单元测试用例代码，实现有保护重构是大型的软件开发项目不可以缺少的，代码级别的测试更能有效地提高软件产品的质量。测试驱动开发中的重构过程也是一个使设计逐步完善的过程。 本文的主要目的是使测试驱动开发落到实地，和具体的语言（C++）和单元测试框架结合起来，并用实例展示测试驱动开发的魅力。</p><h1 id=\"3.测试驱动开发的信条 |outline\">测试驱动开发的信条</h1><p>先开发和设计测试代码，再代码实现通过测试，以测试驱动设计实现，开发和设计的过程，得到了快速的反馈，用这些反馈驱动，改进和重构代码设计，是一个有机的开发过程。按照 Kent 的定义，测试驱动开发的原则是：</p><ol type=\"1\"><li>不要写一行代码，除非有一个失败的自动化测试案例要纠正。</li><li>消除重复的代码，改进设计。</li></ol><p>这两个简单的原则，却产生了一些复杂的个体和组的行为，这些隐含的技术行为包括：</p><ul><li>运行代码对设计决定快速反馈下，实现有机地设计</li><li>必须自己写自己的测试用例，而不是等待别人帮你写测试代码，那样会花费很长时间</li><li>必须要有对变更代码快发反应开发环境</li><li>组件必须要高内聚、低耦合，以使测试简单化。</li></ul><p>两个原则还隐含开发任务的顺序：</p><ol type=\"1\"><li>红色（Red）：写些不能够工作的小测试，这个测试甚至不能编译通过。</li><li>绿色（Green）：快速编写代码使测试通过，不用太在意代码质量只是通过测试。</li><li>重构（Refactor）：消除开始是只是要通过测试的重复代码，改进设计。</li></ol><p>红色（Red）-绿色（Green）-重构（Refactor），这个就是测试驱动开发的座右铭（Mantra）。这种开发方式可以有效的减少代码的缺陷密度，减少 bug 的数量，将大部分的缺陷在代码的开发过程中消除，减少了 QA 测试和质量保证的成本。</p><p>按照软件工程的说法，软件缺陷和 bug 发现的越早，所需的更正这些缺陷的成本就会越小。所以在软件的开发阶段，采用测试驱动的开发方法，把测试引入到开发阶段，使测试和质量意识融入到开发的过程中，这对提高软件工程质量非常有帮助。 而且在采用测试驱动开发必然要求所开发的组件、接口、类或方法是可测试的（testable），这就要求开发的组件，接口要遵循组件和类高内聚（Highly Cohesive），组件和组件、类和类之间低耦合（loosely Coupled）原则，这种开发方式生成的代码必然会帮助开发者，在不断的有保护重构的过程中，提高软件架构的设计，使日后的软件维护变得有章可循。</p><p>测试驱动开发符合敏捷软件开发的精神，在不断迭代过程中，增量地实现软件需求而这一切开始可以从简单设计开始。</p><h1 id=\"4.单元测试框架比较和筛选 |outline\">单元测试框架比较和筛选</h1><p>C++技术是一种高级语言，它出现的时间要比 Java 和 C#早得多，但支持像 xUnit 框架的 C++单元测试框架发展起来的比较晚。 C++ 的单元测试框架选择比较多，现在比较流行的 C++测试框架有 Boost Test、UnitTest++、CppTest、Google C++ Testing Framework。 Boost Test，拥有良好的断言功能，对异常控制，崩溃控制方面处理的比较好，也有良好的可以移植性，但结构复杂，不易于掌握。CPPUnit 是开发比较早的单元测试框架，是对 JUnit 的 C++的移植的一种尝试，拥有丰富的断言和期望功能。Google Test C++ 简称 Gtest，是近期发展起来的单元测试框架，对 xUnit 支持的比较好，支持 TDD 的红-绿-重构模式，支持死亡和退出测试，较好的异常测试控制能力，良好的测试报告输出，拥有自动注册测试用例和用例分组等功能，还有和 Gmock 框架的无缝结合，支持基于接口的（抽象类的）Mock 测试-模拟测试。</p><p>下表是一个对三种流行 C++单元测试框架的简单比较，Gtest 虽然发展起来的较晚，但丰富功能简单易用，易学，加之移植性较好，是跨平台项目单元测试框架比较好的选择。</p><h5 id=\"4.0.1.表 1.单元测试框架比较 |outline\">表 1.单元测试框架比较</h5><table cellspacing=\"0\" cellpadding=\"0\"><thead><tr><th>测试框架支持特性</th><th>Gtest</th><th>Boost Test</th><th>CPPUnit</th></tr></thead><tbody><tr><td>可移植性</td><td>较好</td><td>好（依赖于 Boost 库）</td><td>较好</td></tr><tr><td>丰富的断言</td><td>优</td><td>优</td><td>一般</td></tr><tr><td>丰富的断言信息</td><td>优</td><td>良好</td><td>较差</td></tr><tr><td>自动检测和注册测试用例</td><td>优</td><td>良</td><td>一般</td></tr><tr><td>易于扩展断言</td><td>易于扩展</td><td>一般</td><td>一般</td></tr><tr><td>支持死亡和退出测试（Death 和 Exit）</td><td>支持</td><td>支持</td><td>不支持</td></tr><tr><td>支持参数化测试（Parameterized test）</td><td>支持</td><td>支持</td><td>不支持</td></tr><tr><td>支持 Scoped_Trace</td><td>支持</td><td>不支持</td><td>不支持</td></tr><tr><td>支持选择性执行测试用例</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>丰富的测试报告形式（xml）</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>支持测试用例分组 Suites</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>开源</td><td>是</td><td>是</td><td>是</td></tr><tr><td>执行速度</td><td>快</td><td>快</td><td>快</td></tr><tr><td>基于接口的<code>Mock</code>测试</td><td>通过<code>Gmock</code>支持</td><td>不支持</td><td>不支持</td></tr><tr><td>易用性</td><td>优秀</td><td>较复杂</td><td>较好</td></tr><tr><td>支持类型化的参数化测试</td><td>支持</td><td>不直接支持</td><td>不直接支持</td></tr></tbody></table><h1 id=\"5.测试驱动开发-GTest 简介 |outline\">测试驱动开发-GTest 简介</h1><p>Gtest 是基于 xUnit 的 C++单元测试框架，支持自动化案例自动发掘，丰富的断言功能，支持用户自定义断言，支持死亡测试和退出测试，还有异常测试控制，支持值类型和类型化的参数化测试，接口简单易用，对每个测试案例有执行时间的输出，可以帮助分析代码的执行效率，单一接口文件 gtest.h。</p><p>图 1 是 Console 模式输出用红和绿表示失败和成功的测试用例，看起来比较符合 TDD 的策略和定义</p><h5 id=\"5.0.1.图 1.GTest 的案例测试结果输出 |outline\" style=\"text-align: center\">图 1.GTest 的案例测试结果输出</h5><p><img class=\"aligncenter\" src=\"http://www.ibm.com/developerworks/cn/linux/1401_xiajd_ctdd/image003.jpg\" alt=\"GTest 的案例测试结果输出\" /></p><p>Gtest 的断言有两种形式，致命性断言（Fatal Assertion）和非致命性断言（Nonfatal Assertion）。</p><p>除了基本的断言形式外，Gtest 还包括一些其他的高级断言形式，比如死亡断言，退出断言测试和异常断言等。</p><p>Gtest 还有其他的一些特性，比如类型参数化测试，值类型参数化的测试，测试用例分组，洗牌式测试等，可以参照附录中列出的 Gtest 的官网获取更多的信息。</p><p>在测试驱动软件开发的过程中，我们不可避免的要去依赖第三方系统，比如文件系统、第三方库、数据库访问，其他的在线数据的访问等，按照测试驱动开发的快速反馈的原则，如果在单元测试用例中去直接访问这些信息，势必在测试驱动开发过程中会依赖这些资源从而造成访问时间无法控制， 所以单元测试一般应该避免直接访问第三方系统，这就是 Mock 测试的主要目的，用模拟的接口去替换真实的接口，模拟出单元测试需要的第三方数据和接口进而隔离第三方的影响，专注于自己的逻辑实现。Gmock 就是这样一个 Mock 框架，它是类似于 jMock、EasyMock 和 Hamcres ，但是是 C++版本的 Mock 框架。 Gmock 是基于接口的 Mock 框架，在 C++中接口的定义是通过抽象函数和抽象类来实现的，这种要求势必会要求我们尽量遵循基于接口的编程原则，把交互界面上的操作抽象成接口，以便是接口可被模拟 Mock。可以在附录中列出的 Gmock 官网获取更多信息。</p><h1 id=\"6.测试驱动开发的实践 |outline\">测试驱动开发的实践</h1><p>测试驱动开发和敏捷开发是相辅相成的，敏捷开发的需求一般是以故事、产品功能列表，或需求用例的方式给出，拿到这些需求后，开发团队会根据相应的需求文档分析需求，做功能分解，根据功能优先级制定迭代开发计划和测试计划。测试驱动开发可以从两个角度来看，广义的和狭义的。广义的测试驱动开发是从流程上规定测试驱动开发，这种情况下一般要求 QA 走到前面，先根据需求先开发测试用例，这些测试用例会作为功能验收的标准，然后开发人员会根据测试用例做详细的功能设计和编码实现，最后提交给 QA 做功能验收测试。 狭义的测试驱动开发是开发人员拿到功能需求后，先自己开发代码级别的测试用例，然后开发具体的实现通过这些测试用例的一种开发方法。 本文涉及的是第二种，从代码级别开始的，狭义的测试驱动开发。</p><p>相信每个人都玩过棋牌游戏，简单起见，为了实践测试驱动开发方法我想开发一款简单的三子棋游戏，如图 2 所示。三子棋的游戏规则很简单，只要是同样的三个棋子连成一条线那么持对应棋子的人就胜出，图中持 O 子棋的人获胜。总结一下三子棋游戏的基本需求：</p><ol type=\"1\"><li>我需要一个 3X3 的棋盘，可以用下三子棋。</li><li>我需要在棋盘上下棋和获取到棋子。</li><li>我要能验证和判断是不是三个棋子在同一条线上，以判断是不是有人胜出。</li><li>我不能放棋子到已被占用的棋位置上。</li><li>我要能判断是不是棋盘已满并无赢家。</li><li>我需要能复位棋盘，以便于重新开始下棋。</li><li>我需要用对记住玩家，以便于我能特例化 Player</li><li>我需要能保存和加载棋局能力，以便于我能下次回来继续之前的游戏。</li></ol><h5 id=\"6.0.1.图 2.三子棋游戏 |outline\" style=\"text-align: center\">图 2.三子棋游戏</h5><p><img class=\"aligncenter\" src=\"http://www.ibm.com/developerworks/cn/linux/1401_xiajd_ctdd/image005.jpg\" alt=\"图 2.三子棋游戏\" /></p><p>以上是三子棋游戏的基本需求列表，拿到这些需求后，我会做一些简单解决方案的设计，解决方案包括 4 个子工程（C++ Project），其中一个测试工程 TicTacToeGamingTest，其余三个分别是 TicTacToeLib,TicToeGamingLib 和 TicTacToeConsoleGaming，这三个工程的依赖关系是 TicTacToeConsoleGaming 依赖于 TicToeGaminglib 和 TicTacToeLib，TicToeGamingLib 依赖于 TicTacToeLib。 建好这些工程,有了基本的设计思路后，在测试工程里首先开发的测试代码。</p><h5 id=\"6.0.2.图 3.解决方法设计 |outline\" style=\"text-align: center\">图 3.解决方法设计</h5><p style=\"text-align: center\"><img src=\"http://www.ibm.com/developerworks/cn/linux/1401_xiajd_ctdd/image007.jpg\" alt=\"图 3.解决方法设计\" /></p></div><div><p>先看第一个需求：</p><p><strong>1.我需要一个 3X3 的棋盘，可以来下三子棋。</strong></p><p style=\"text-align: center\">这个需求很简单，现在的棋盘不需要包括任何的逻辑，为了便于测试我需要一个接口去访问它，现在接口是空的，也没有实现，这样一个测试用例就可以满足这个需求：</p><div style=\"text-align: center\"><pre class=\"crayon-plain-tag\">TEST_F(TicTacToeTestFixture,IWantAGameBoard)
{

	IGameBoard *gameBoard=NULL; 
    EXPECT_NO_THROW(gameBoard=new SimpleGameBoard(\"simpleGame\")); 
	EXPECT_TRUE(gameBoard!=NULL); 	
    EXPECT_NO_THROW(delete gameBoard);
}</pre></div><p style=\"text-align: justify\">这是第一个测试用例，稍微解释一下。TicTacToeTestFixture 是用于测试的分组的，它是一个类，继承于 Gtest 的 test 类 testing::Test，这个类可以重载 setup 和 teardown 等虚拟函数用于测试准备和清理测试现场。<code>TEST_F</code> 是定义测试用例的宏，IWantAGameBoard 是测试的案例的名称，会显示在输出中，测试用例很简单，只是只是保证能创建和析构 SimpleGameBoard 实例，并无异常抛出。这个测试用例现在是不能编译通过的，因为 IGameBoard 接口和 SimplegameBoard 都还没有声明和定义,接下来为了使这个案例通过，我在 TicTacToeLib 工程里，声明和定义 IGameBoard 和 SimpleGameBoard 类，IGameBoard 是纯抽象类，抽象了所有对棋盘的操作。引入声明到测试工程中，编译通过并运行，现在完成了第一测试用例，尽管测试的 IGameBoard 和 SimpleGameBoard 还是空的。可以看一下输出：</p><h5 id=\"6.0.3.图 4 .测试用例输出 |outline\" style=\"text-align: center\">图 4 .测试用例输出</h5><p><img class=\"aligncenter\" src=\"http://www.ibm.com/developerworks/cn/linux/1401_xiajd_ctdd/image009.jpg\" alt=\"图 4 .测试用例输出\" /></p><p><strong>2.我需要在棋盘上下棋和获取到棋子</strong></p><p>这个需求能使棋手在棋盘上把棋子放到想要的位置上并能查看指定棋盘位置上的棋子，棋盘是 3&#215;3。实现这个需求也很简单，我只要在 IGameBoard 接口上添加两个函数然后在 SimpleGameBoard 里实现这两个函数就可以满足这个需求：</p><div><pre class=\"crayon-plain-tag\">virtual void PutChess(int x,int y,char chess)=0; 
virtual char GetChess(int x,int y)=0 ;
       有了这个思路，我想这样设计这个测试用例：
TEST_F(TicTacToeTestFixture,PutandGetChess)
{
char xChess='X'; 
char yChess='Y';
IGameBoard *gameBoard=new SimpleGameBoard(\"simpleBoard\"); 
gameBoard-&gt;PutChess(0,0,xChess); 
gameBoard-&gt;PutChess(2,2,yChess); 
EXPECT_EQ(xChess,gameBoard-&gt;GetChess(0,0));
EXPECT_EQ(yChess,gameBoard-&gt;GetChess(2,2)); 
delete gameBoard; 
}</pre></div><p>试着编译这个测试工程，失败，原因是没有实现这两个函数，接下来我回到 TicTacToeLib 工程去声明和定义这两个函数。为了实现这两个功能，在 SimpleGameBoard 定义 private 数据：<code>vector<code>char</code><code>&gt; data_;用于 保存棋子和位置信息，为了简单，棋子用 Char 类型来表示，位置信息和 data_向量的下标对应,如棋盘位置（2，2）对应的是 data_[2*3+2]这个位置，数据是安行存放的。两个函数的实现是：</code></code></p><div><pre class=\"crayon-plain-tag\">void SimpleGameBoard::PutChess( int x,int y,char chess )
{
	assert(x&lt;xMaxDim&amp;&amp;y&lt;yMaxDim); 
int xy=x*3+y; 
if(data_.size()==0)initboard_(); 
	data_[xy]=chess; 
}

char SimpleGameBoard::GetChess( int x,int y )
{
	assert(x&lt;xMaxDim&amp;&amp;y&lt;yMaxDim); 
	assert(data_.size()==yMaxDim*xMaxDim); 
return data_[x*3+y];
}</pre></div><p>initboard_()是个 protected 函数，用于初始化 data_。 现在可以重现编译和运行测试工程，结果如下：</p><h5 id=\"6.0.4.图 5 .测试用例输出 |outline\" style=\"text-align: center\">图 5 .测试用例输出</h5><p><img class=\"aligncenter\" src=\"http://www.ibm.com/developerworks/cn/linux/1401_xiajd_ctdd/image011.jpg\" alt=\"图 5 .测试用例输出\" /></p><p>有了两个测试用例的实现，并且运行是绿色，继续下个需求。</p><p><strong>3.我要能验证和判断是不是三个棋子在同一条线上，以判断是不是有人胜出</strong></p><p>这个需求用于判断三个棋子是否已经在一条线上，如果是的话，那么持对应棋子的棋手就会胜出，这个测试用例可以这样设计：</p><div><pre class=\"crayon-plain-tag\">TEST_F(TicTacToeTestFixture,JugeThreeInLine)
{
IGameBoard *gameBoard=new SimpleGameBoard(\"simpleBoard\"); 
IGameBoard *gameBoard2=new SimpleGameBoard(\"simpleboard2\"); 
char xChess='x',yChess='o'; 
gameBoard-&gt;PutChess(0,0,xChess); gameBoard2-&gt;PutChess(0,1,yChess); 
gameBoard-&gt;PutChess(1,1,xChess); gameBoard2-&gt;PutChess(1,1,yChess); 
gameBoard-&gt;PutChess(2,2,xChess); gameBoard2-&gt;PutChess(2,1,yChess); 
EXPECT_TRUE(gameBoard-&gt;CheckWinOut(xChess));
EXPECT_TRUE(gameBoard2-&gt;CheckWinOut(yChess)); 
EXPECT_FALSE(gameBoard-&gt;CheckWinOut(yChess));
EXPECT_FALSE(gameBoard2-)CheckWinOut(xChess)); 
delete gameBoard; 
delete gameBoard2; 
}</pre></div><p>设计是这样的，为简单，我把判断棋子胜出的函数 CheckWinOut 定义到接口 IGameBoard 中，并在 SimpleGameBoard 中实现它，实现如下：</p><div><pre class=\"crayon-plain-tag\">bool SimpleGameBoard::CheckWinOut(char chess)
{
return IsThreeInLine_(chess); 
}</pre></div><p>IsThreeInLine_是受保护的成员函数，它会扫描棋盘的行，列和对角线看是否指定的棋子在一条线上，如果有三个棋子在一条线上，则说明有人胜出。编译运行测试，绿色通过。 继续下一个需求。</p><p><strong>4.我不能放棋子到已被占用的棋位置上。</strong></p><p>这个需求是个验证性需求，要保证棋子不能重叠和覆盖已在棋盘上的棋子，实现这个需求我只要重构现有的代码加上避免棋子重叠的逻辑。只要避免在 PutChess 时候，检查是否指定的位置是否已有棋子，如果是简单的抛出异常即可。有了这些基本的思路，我开始设计测试用例。</p><div><pre class=\"crayon-plain-tag\">TEST_F(TicTacToeTestFixture,BizException_Occupied){

    IGameBoard *gameBoard=new SimpleGameBoard(\"simple board\"); 
char xChar='X',yChar='0'; 
EXPECT_NO_THROW(gameBoard-&gt;PutChess(0,0,xChar)); 
<strong>EXPECT_THROW(gameBoard-&gt;PutChess(0,0,xChar),ChessOverlapException); </strong>
EXPECT_NO_THROW(gameBoard-&gt;PutChess(2,2,yChar)); 
<strong>EXPECT_THROW(gameBoard-&gt;PutChess(2,2,yChar),ChessOverlapException); </strong>
delete gameBoard; 
}</pre></div><p>ChessOverlapException 是我将要实现的一个异常类，这个是在棋手试图放棋子到已有棋子的棋盘位置上时要抛出的异常。测试用例中，我在（0，0）和（2，2）这两个位置上放同样的棋子以触发这个异常。为了编译通过，我开始实现 ChessOverlapException。 ChessOverlapException 继承自 std::exception 我重载了 what 函数返回相应的异常信息。 把这个异常类的定义引入的测试工程中，编译通过运行测试，但却得到了红色 Red，案例失败：</p><p style=\"text-align: center\">图 6.测试用例输出</p><p><img class=\"aligncenter\" src=\"http://www.ibm.com/developerworks/cn/linux/1401_xiajd_ctdd/image013.jpg\" alt=\"图 6.测试用例输出\" /></p><p>原因是我还没有重构 PutChess 函数以加入避免棋子被被覆盖的代码。现在来重构 PutChess 函数：</p><div><pre class=\"crayon-plain-tag\">void SimpleGameBoard::PutChess( int x,int y,char chess )
{
assert(x&lt;xMaxDim&amp;&amp;y&lt;yMaxDim); 
int xy=x*3+y; 
if(data_.size()==0){
		initboard_(); 
		data_[xy]=chess;
return ; 
	}
if(data_[xy]!='+') {
throw ChessOverlapException(\"chess overlap!\");
	}
else data_[xy]=chess;
}</pre></div><p>重新编译测试工程并运行得到绿色 Green 通过。继续下一个需求。</p><p><strong>5.我要能判断是不是棋盘已满并无赢家。 </strong></p><p>这个需求用于判断是否是和棋的情况，棋盘满了但并无赢家，这是可能出现的一种情况，这个实现设计可以有两种方式. 一是重构 CheckWinOut 函数，使返回值携带更多的信息，比如和棋，有人胜出等。二是定义一个独立的函数去判断棋盘的当前状态。第一种方案较合理，开始设计这种方案的测试用例：</p><div><pre class=\"crayon-plain-tag\">EST_F(TicTacToeTestFixture,IsEndedInADraw)
{
char xChess='X',yChess='O'; 
IGameBoard *gameBoard=new SimpleGameBoard(\"simpleBoard\");
gameBoard-&gt;PutChess(0,0,yChess);gameBoard-&gt;PutChess(0,1,xChess);gameBoard-&gt;PutChess(0,2,yChess);
gameBoard-&gt;PutChess(1,0,xChess);gameBoard-&gt;PutChess(1,1,yChess);gameBoard-&gt;PutChess(1,2,yChess);
gameBoard-&gt;PutChess(2,0,xChess);gameBoard-&gt;PutChess(2,1,yChess);gameBoard-&gt;PutChess(2,2,xChess);

<strong>GameBoardStatus status=gameBoard-&gt;CheckWinOut(yChess);
EXPECT_TRUE(status==GAMEDRAW); </strong><strong>GameBoardStatus status2=gameBoard-&gt;CheckWinOut(xChess); EXPECT_TRUE(status2==GAMEDRAW);</strong> 
delete gameBoard; 
}</pre></div><p>以上的测试用例可以看出， 我设计了和棋的棋局，并想重构 CheckWinout 函数，使其返回枚举类型 GameBoardStatus 以表示棋局的状态，其中 GAMEDRAW 表示和棋状态。为了使工程能编译通过，开始定义这个枚举类型并重构 CheckWinOut 函数。实现所有设计，经过几次的 Red 失败，最终 形成代码：</p><div><pre class=\"crayon-plain-tag\">GameBoardStatus SimpleGameBoard::CheckWinOut(char chess)
{

if(IsThreeInLine_(chess)){
return GAMEMWINOUT;
	}
else if(IsEndedInADraw_()){
return GAMEDRAW; 
	}
else{
return GAMERUNNING; 
	}
}</pre></div><p>其中那个 IsEndedInADraw_是个受保护的成员函数，用于检测是否和棋。 在调通这个测试用例的过程中，我也更新了测试<code>JugeThreeInLine。因为重构 ChecWinOut 改变了返回类型。</code></p><p><strong>6.我需要能复位棋盘，以便于重新开始下棋。</strong></p><p><strong>7.我需要用对记住玩家，以便于我能特例化 Player。</strong></p><p>6 和 7 需求的测试案例和实现比较比较简单，不在赘述，7 的要求是要建立玩家 Player，这个主要是说要能实例化玩家。可以看附带的工程。</p><p><strong>8.我需要能保存和加载棋局能力，以便于我能下次回来继续之前的游戏</strong>。</p><p>这个需求是一个合理的需求，玩家可以保存和继续回来玩游戏，他的测试用例可以这样设计：</p><div><pre class=\"crayon-plain-tag\">TEST_F(TicTacToeTestFixture,SaveTheBoard)
{
IGameBoard * gameBoard=new SimpleGameBoard(\"simpleBoard\"); 
char xChess='x',yChess='o'; 
gameBoard-&gt;PutChess(0,0,xChess); 
gameBoard-&gt;PutChess(1,2,yChess); 
IGameIO *gameIO=new SimpleGameIO(); 
EXPECT_NO_THROW(gameIO-&gt;save(gameBoard,\"somewhere\")); 
delete gameBoard; 
delete gameIO;
}
TEST_F(TicTacToeTestFixture,LoadTheBoard)
{
IGameBoard * gameBoard=new SimpleGameBoard(\"simpleBoard\"); 
char xChess='x',yChess='o'; 
gameBoard-&gt;PutChess(0,0,xChess); 
gameBoard-&gt;PutChess(1,2,yChess); 
IGameIO *gameIO=new SimpleGameIO(); 
EXPECT_NO_THROW(gameIO-&gt;save(gameBoard,\"somewhere\")); 
IGameBoard *game=gameIO-&gt;load(\"somewhere\"); 
EXPECT_EQ(xChess,game-&gt;GetChess(0,0)); 
EXPECT_EQ(yChess,game-&gt;GetChess(1,2)); 
EXPECT_EQ('+',game-&gt;GetChess(2,2));
delete game;</pre></div><div><pre class=\"crayon-plain-tag\">delete gameBoard; 
delete gameIO; 
}</pre></div><p>这里用两个测试用例来覆盖这个需求，一个是保存棋盘，一个是加载棋盘。由这个测试用例可以看到，要通过这个测试，必须要定义 IGameIO 接口和 SimpeGameIO 类。 保存棋盘的媒介是文件。按照 TDD 的开发要求，测试单元本身最好是脱离对第三方系统的依赖，但测试中必然会用到第三方系统，解决这些问题的方法有几种。创建第三方系统的 Stub 类或是 FakedObject，第三种选择是 Mock 框架，如 Gmock。 Gmock 的设计理念是基于接口的，只要是第三方访问提供的是接口，这些访问就可以可以被用 Gmock 模拟。可以看参考文献获取更多的信息。 限于篇幅不再赘述。一下是完成所有测试用例的测试结果。</p><h5 id=\"6.0.6.图 7.测试用例输出 |outline\" style=\"text-align: center\">图 7.测试用例输出</h5><p><img class=\"aligncenter\" src=\"http://www.ibm.com/developerworks/cn/linux/1401_xiajd_ctdd/image015.jpg\" alt=\"图 7.测试用例输出\" /></p><p>或许你会注意到有些测试用例的设计，只是以点盖面，如果想要更多的验证点可以借助于 Gtest 提供的参数化测试设计测试数据，然后去测试实现的类和逻辑。 还有死亡测试的用例，可以在参考资源中的 Gtest 资源中查看。</p><h1 id=\"7.结论 |outline\">结论</h1><p>C++中实现测试驱动开发 TDD 之前是很困难的事。 但有了类似于 xUnit 的 Gtest 和 Gmock 测试框架，在 C++工程中实现 TDD 也变得很享受。测试驱动开发是一个很好的工具，它可以帮助开发者实现有机开发，在需求的实现过程中快速得到反馈，另一个好处是测试驱动开发可以使开发人员更加重视需求和测试，以测试用例为中心，这样势必会产生更好代码。从软件工程的角度来说，测试驱动开发的实践应用会大幅度的提高软件开发的质量，用代码级别的测试用例来覆盖和保障程序的健壮性更能保障整个软件产品的开发质量。</p><p>测试驱动开发的座右铭模式：红色-绿色-重构，然后重复这个直到开发完成为止，是一个自我确认和有保护代码重构的过程。采用测试驱动开发的模式的软件产品，产生的单元测试代码，从代码级别测试覆盖了软件的需求，使以后的代码重构更安全可靠。</p></div><div class=\"wp_rp_wrap  wp_rp_plain\" ><div class=\"wp_rp_content\"><h3 class=\"related_post_title\">相关文章</h3><ul class=\"related_post wp_rp\" style=\"visibility: visible\"><li ><a href=\"http://blog.jobbole.com/104042/\" class=\"wp_rp_title\">如何在 Linux 下检测内存泄漏</a></li><li ><a href=\"http://blog.jobbole.com/103640/\" class=\"wp_rp_title\">Linux 平台相关代码的 C++ 解决方案</a></li><li ><a href=\"http://blog.jobbole.com/94497/\" class=\"wp_rp_title\">Linux 动态库相关知识整理</a></li><li ><a href=\"http://blog.jobbole.com/103596/\" class=\"wp_rp_title\">Linux 下 C++ 异常处理技巧</a></li><li ><a href=\"http://blog.jobbole.com/88279/\" class=\"wp_rp_title\">Linux 内核里的“智能指针”</a></li><li ><a href=\"http://blog.jobbole.com/86392/\" class=\"wp_rp_title\">C++和双重检查锁定模式(DCLP)的风险</a></li><li ><a href=\"http://blog.jobbole.com/104080/\" class=\"wp_rp_title\">编写高质量代码</a></li><li ><a href=\"http://blog.jobbole.com/92792/\" class=\"wp_rp_title\">Linux Shell 创建序列数组</a></li><li ><a href=\"http://blog.jobbole.com/103662/\" class=\"wp_rp_title\">C++11 中的右值引用与转移语义</a></li><li ><a href=\"http://blog.jobbole.com/85186/\" class=\"wp_rp_title\">Linux 上的最佳 C/C++ IDE</a></li></ul></div></div><p><a href=\"http://blog.jobbole.com/104032/\">面向 C++ 的测试驱动开发</a>，首发于<a href=\"http://blog.jobbole.com\">文章 - 伯乐在线</a>。</p>") (wfw:commentRss nil "http://blog.jobbole.com/104032/feed/") (slash:comments nil "0")) (item nil (title nil "Github上的有趣事实：\"BigQuery驱动下的数据世界\"") (link nil "http://blog.jobbole.com/100327/") (comments nil "http://blog.jobbole.com/100327/#respond") (pubDate nil "Mon, 01 Aug 2016 01:40:59 +0000") (dc:creator nil "伯小乐") (category nil "IT技术") (category nil "BigQuery") (category nil "Github") (guid ((isPermaLink . "false")) "http://blog.jobbole.com/?p=100327") (description nil "<p>近日看到了Google的BigQuery技术，用类似SQL的语言来做一些数据的分析。而Github也加入了进来。闲来无事，就去体验了一把。</p><p><a href=\"http://blog.jobbole.com/100327/\">Github上的有趣事实：\"BigQuery驱动下的数据世界\"</a>，首发于<a href=\"http://blog.jobbole.com\">文章 - 伯乐在线</a>。</p>") (content:encoded nil "<p>近日看到了Google的BigQuery技术，用类似SQL的语言来做一些数据的分析。而Github也加入了进来。闲来无事，就去体验了一把。https://cloud.google.com/bigquery/public-data/github 这是相关文章的地址。</p><h3 id=\"bigquery\">BigQuery语法</h3><p></p><pre class=\"crayon-plain-tag\">SELECT
  package,
  COUNT(*) count
FROM (
  SELECT
    REGEXP_EXTRACT(line, r' ([a-z0-9\\._]*)\\.') package,
    id
  FROM (
    SELECT
      SPLIT(content, '\\n') line,
      id
    FROM
      [bigquery-public-data:github_repos.sample_contents]
    WHERE
      content CONTAINS 'import'
      AND sample_path LIKE '%.py'
    HAVING
      LEFT(line, 6)='import' )
  GROUP BY
    package,
    id )
GROUP BY
  1
ORDER BY
  count DESC
LIMIT
  40;</pre><p>整体的语法都和SQL非常接近，鉴于点进来的人很多都是冲着“有趣”这两个字来的，就不过多介绍代码了。这段代码的作用是找到github仓库中，使用Python语言的仓库中，前10个被引用的库。</p><p>BigQuery的界面也非常有Google风…… <img src=\"https://ooo.0o0.ooo/2016/07/01/577695245abdb.png\" alt=\"github_20160702000047.png\" /></p><h3 id=\"most-popular-python-packages\">Most Popular Python Packages</h3><p>这是通过刚刚的分析做出来的前几名的Python库的列表。 <img src=\"https://ooo.0o0.ooo/2016/07/01/5776947692ff9.png\" alt=\"a5037d6edd3b9ca5 (2).png\" /></p><h3 id=\"most-popular-java-packages\">Most Popular Java Packages</h3><p><img src=\"https://ooo.0o0.ooo/2016/07/01/577698eb17973.png\" alt=\"a5037d6edd3b9ca5 (3).png\" /></p><h3 id=\"section\">一些其它有趣的事情</h3><p>例如大家都在用什么协议来发布作品，有接近150万个仓库使用MIT协议来发布。 <img src=\"https://ooo.0o0.ooo/2016/07/01/57769f3c9b10c.png\" alt=\"a5037d6edd3b9ca5 (4).png\" /></p><p>关注tensorflow的人都在关注什么？ <img src=\"https://ooo.0o0.ooo/2016/07/01/5776a076be634.png\" alt=\"a5037d6edd3b9ca5 (5).png\" /></p><p>最受欢迎的语言 <img src=\"https://ooo.0o0.ooo/2016/07/01/5776a104a17d5.png\" alt=\"1-_uxwTTOd1oRXjmloZ5Qi0g.png\" /></p><p>提交次数和时间的关系 <img src=\"https://ooo.0o0.ooo/2016/07/01/5776a1049aeb3.png\" alt=\"1-Ud8ZAz1xoVWK9DfiX6_hBg.png\" /></p><div class=\"wp_rp_wrap  wp_rp_plain\" ><div class=\"wp_rp_content\"><h3 class=\"related_post_title\">相关文章</h3><ul class=\"related_post wp_rp\" style=\"visibility: visible\"><li ><a href=\"http://blog.jobbole.com/86585/\" class=\"wp_rp_title\">微软推出 Visual Studio 的 GitHub 扩展</a></li><li ><a href=\"http://blog.jobbole.com/97681/\" class=\"wp_rp_title\">2015年 GitHub 十大开源项目</a></li><li ><a href=\"http://blog.jobbole.com/34195/\" class=\"wp_rp_title\">ThoughtBot的代码审查指导原则</a></li><li ><a href=\"http://blog.jobbole.com/38213/\" class=\"wp_rp_title\">Cookies 的跨域脚本攻击 &#8211; Github 迁移域名的安全详解</a></li><li ><a href=\"http://blog.jobbole.com/17010/\" class=\"wp_rp_title\">版本控制入门简介</a></li><li ><a href=\"http://blog.jobbole.com/14489/\" class=\"wp_rp_title\">版本控制工具历史的10个里程碑</a></li><li ><a href=\"http://blog.jobbole.com/61115/\" class=\"wp_rp_title\">Egor Homakov：我是如何再次黑掉GitHub的</a></li><li ><a href=\"http://blog.jobbole.com/60505/\" class=\"wp_rp_title\">如何创建你自己的Git服务器</a></li><li ><a href=\"http://blog.jobbole.com/87700/\" class=\"wp_rp_title\">如何在 Git 里撤销(几乎)任何操作</a></li><li ><a href=\"http://blog.jobbole.com/89418/\" class=\"wp_rp_title\">GitHub vs. Bitbucket 不只是功能不同</a></li></ul></div></div><p><a href=\"http://blog.jobbole.com/100327/\">Github上的有趣事实：\"BigQuery驱动下的数据世界\"</a>，首发于<a href=\"http://blog.jobbole.com\">文章 - 伯乐在线</a>。</p>") (wfw:commentRss nil "http://blog.jobbole.com/100327/feed/") (slash:comments nil "0")) (item nil (title nil "Expert 诊断优化（1）：你的 CPU 高么？") (link nil "http://blog.jobbole.com/104023/") (comments nil "http://blog.jobbole.com/104023/#respond") (pubDate nil "Mon, 01 Aug 2016 01:27:25 +0000") (dc:creator nil "伯小乐") (category nil "IT技术") (category nil "SQL Server") (category nil "数据库") (guid ((isPermaLink . "false")) "http://blog.jobbole.com/?p=104023") (description nil "<p>现在很多用户被数据库的慢的问题所困扰，又苦于花钱请一个专业的DBA成本太高。软件维护人员对数据库的了解又不是那么深入，所以导致问题迟迟不能解决，或只能暂时解决不能得到根治。开发人员解决数据问题基本又是搜遍百度各种方法尝试个遍，可能错过诊断问题的最佳时机，又可能尝试一堆方法最后无奈放弃。</p><p><a href=\"http://blog.jobbole.com/104023/\">Expert 诊断优化（1）：你的 CPU 高么？</a>，首发于<a href=\"http://blog.jobbole.com\">文章 - 伯乐在线</a>。</p>") (content:encoded nil "<p>现在很多用户被数据库的慢的问题所困扰，又苦于花钱请一个专业的DBA成本太高。软件维护人员对数据库的了解又不是那么深入，所以导致问题迟迟不能解决，或只能暂时解决不能得到根治。开发人员解决数据问题基本又是搜遍百度各种方法尝试个遍，可能错过诊断问题的最佳时机，又可能尝试一堆方法最后无奈放弃。</p><p>怎么样让琐事缠身的程序维护人员，用最快的方式解决数据库出现的问题？怎么让我们程序员的痛苦降低到最小&#8230;每天喝喝茶水，看看新闻平安度过一天呢？本系列重要通过 <a href=\"http://www.grqsh.com/product_Expert.html\" target=\"_blank\">Expert for sqlserver </a>工具讲解下数据库遇到的各种问题的表象及导致这样问题的根本原因，让定位问题更准确，解决问题思路更清晰！！</p><p>数据库的性能好坏，对于最终用户来说表现为点击的操作是否能够快速响应，那么反应到数据库上就是语句执行时间是否够短！</p><p>对用运维人员数据库性能的表现，简单可能看成CPU 、内存、磁盘三巨头指标是否正常，那么今天我们就从CPU 下手，看看CPU能够看出哪些问题！</p><p><strong>废话不多说，直接开整&#8212;</strong></p><p>主要用到的性能计数器（不知道什么是性能计数器的，请自行百度）</p><p>就用两个~</p><ol><li>%Process Time　全实例　 （主要用于查看当前服务器的CPU 情况）</li><li>%Process Time　sqlservr （主要用于查看数据库使用的CPU情况 ）</li></ol><p><strong><strong>排除其他应用影响CPU</strong>　　　　　　　　　　　　　　　　　　　　　　　</strong></p><p><img src=\"http://jbcdn2.b0.upaiyun.com/2016/08/da810078db6fa6472766a284528c48d3.jpg\" alt=\" \" /></p><p>综合这两个计数器 在同一时间点可以诊断出CPU 是否是被服务器其他的应用所消耗的，如图中17:10 左右的  “%Process Time　全实例（红线）” 突然升高，而SQL 服务的（绿线）并无明显升高，这也就说明，在这个时间段的CPU 压力不是有数据库导致的！</p><p>这个红线的明显升高时，因为我在数据库所在的服务器上做了一次文件压缩！类似文件压缩这种操作会使用大量CPU，对数据库性能造成冲击！</p><p><strong>　CPU 问题分析　　　　　　　　　　　　　　　　　　　　　　　　</strong></p><p>CPU很高或者达到100%一定是你业务压力很大？CPU 不能满足你的需求么？在下结论前请仔细分析，一个草率的定论可能换来，老板一个安慰“世界那么大你该出去走走了！”</p><p>下面我们用几个典型的场景，分析下问题，并给出最佳实践~</p><p>高峰时段CPU 持续很高</p><p><img src=\"http://jbcdn2.b0.upaiyun.com/2016/08/9e65af5f98debf06ae62d746e93e5a21.png\" alt=\" \" /></p><p>图中是服务器几天的CPU情况</p><p>很多人看到这张图，是不是看到了自己的服务器？是否有一种亲切感呢~下面我们来分析下这种表象可能存在的问题！</p><p>首先明确一点90%的问题可能集中在10%的场景，这种CPU 持续持续很高的情况请注意下面两点：</p><ol><li>你的数据库并行度是否调整？</li><li>你的数据库是否缺少索引，导致频繁的查询消耗很高的CPU资源？</li></ol><p>最大并行度是什么？简单的可以理解为执行一条语句最多可以使用多少个CPU。看起来当然是使用的越多越好啦，使用的越多语句肯定越快呀！ 这个答案是大写的 “<strong>NO</strong>”，使用过多的CPU会导致线程协同工作产生的时间较长，直接导致语句很慢，而且消耗的CPU时间很多，导致CPU使用高，进而成为瓶颈！</p><p>看一个数据语句持续时间也就是执行时间，但是看看CPU的时间，这就是没有设置并行度，一个并行计划会产生大量的CPU消耗，另外会让语句执行的更慢！</p><p><img src=\"http://jbcdn2.b0.upaiyun.com/2016/08/4c9bea5e728bbb427a0bb8fc2dc97691.png\" alt=\" \" /></p><p>那么是不是使用的越少越好呢？任何事情没有绝对的，视情况而定，如果系统有比较大数据量的操作需求，并行使用多个CPU会有很大的提升。</p><p>一般建议系统如果超过32个CPU 那么设置成8或者4，如果系统中都是特别短小且频繁的语句建议设置成1（取消语句并行，要慎重真的符合你的场景才好）</p><p>并行开销的阀值，主要控制SQL优化器何时选用并行计划，建议默认值，此值设置的越小优化器越容易选择并行计划。</p><p>并行度的设置是针对实例级别的设置（2016中可以对单独数据库设置）</p><p>怎么设置并行度和阀值，请看下图: 系统默认的并行度 为0，阀值默认为5</p><p><img src=\"http://jbcdn2.b0.upaiyun.com/2016/08/9525a32d8e70d5a9d8131f02f9345531.png\" alt=\" \" /></p><p>并行度的调整可谓谁用谁知道啊，下面我们说说系统老大难的问题&#8211;语句导致CPU高</p><p>语句导致CPU高也是很常见的问题之一，那么语句怎么调优降低CPU 消耗呢？ 这里只做一些简单的说明，具体的语句调优、参数化减少语句编译，请看后面的系列文章。</p><p>语句调优的方式很多种，这里介绍和CPU相关最为常用：</p><ol><li>添加索引降低语句开销，执行需要的资源消耗少了消耗的CPU 自然相对就少了。</li><li>降低语句复杂度，让SQL Server执行高效（同样也是降低资源消耗的方法）。</li><li>分析语句是否可以采用串行计划。</li><li>前端程序尽量参数化减少语句的编译消耗。</li></ol><p>CPU 规律波动</p><p>拿到CPU的监控数据不要盲目下结论，数据往往是最能反映问题，给你提供思路的！</p><p><img src=\"http://jbcdn2.b0.upaiyun.com/2016/08/7009f4196ece05242ce2e9aa0f64b2ec.png\" alt=\" \" /></p><p>如果你是系统维护人员，看到类似这样的CPU数据指标，如果你还不能有一些思路，请你好好熟悉下你亲爱的系统。</p><p>这张图很清晰地反映出系统每半小时一次的CPU升高，那么别忙着去找对应时间点的语句，我们最少要好好想一下，系统中有什么操作半小时执行一直？SQL JOB？计划任务？前台定时处理？等等等</p><p>这个规律的定时处理是否有异常？是否最近有什么改动？执行的结果是不是和你想的一样？</p><p>也许问题就这么清晰的定位了&#8230;&#8230;</p><p>CPU 突然飙高</p><p><img src=\"http://jbcdn2.b0.upaiyun.com/2016/08/732f1e453228c9ce2ddb4ad3bcc238c6.png\" alt=\" \" /></p><p>图中 9点CPU由平均20几飙升到100%</p><p>CPU突然飙高可能是偶然的现象，也许你可以认为没有关系，但当你判断为偶然之前，你是否做过下面的分析：</p><ol><li>是否分析过系统日志，CPU飙高时间点是否有异常？</li><li>是否检查服务器上有什么特殊应用？</li><li>是否检查了数据库状态？</li><li>是否询问过相关业务人员？</li><li>是否马上开启监控为下一次突发情况的到来做好准备？</li></ol><p>如果没有你的判断真是毫无根据&#8230;也错过了一次发现问题，学习知识的机会！</p><p>排除上述异常，最有可能的原因就是数据库中，在那一刻有一个或多个语句运行异常，或非常不优化。如果这情况真的因为语句问题，而且只出现一次，那么这可能不是问题，我们尽量找到当时的语句，查看问题。找到当时的语句可以通过系统视图sys.dm_exec_query_stats 查看CPU消耗以及运行时间，或者由自己的监控工具得到。</p><p>找到对应的时间点看看到底是什么语句在运行~</p><p><img src=\"http://jbcdn2.b0.upaiyun.com/2016/08/62593bc80bf63bb476b975146dae912c.png\" alt=\" \" /></p><p>对这条语句进行分析到底是为什么！</p><p>CPU 真高！</p><p>经过各种分析优化，如果依然CPU压力明显，真心是硬件不能支撑业务了，那么我们就要选择更高大上的方式了，比如修改程序设计垂直/水平拆分，添加硬件，读写分离分担压力，组建集群负载均衡等等手段&#8230;&#8230;</p><p>&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8211;</p><p>总结：对于CPU压力的解决，大部分的用户可以通过调整并行度和系统语句的优化来解决。</p><p>另外对系统的监控和分析在诊断问题及解决问题中起到至关重要的作用。</p><p>在下结论前一定要经过仔细的分析研究，一个想当然的决定可能造成严重的影响。</p><p>你的系统真的需要加硬件，或高大上的方案么？</p><p>&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8211;给出一些CPU相关的文章连接&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8211;</p><ul><li>桦仔的  <a href=\"http://www.cnblogs.com/lyhabc/archive/2013/06/12/3133273.html\" target=\"_blank\">SQLSERVER排查CPU占用高的情况</a></li><li>高大侠的  <a id=\"cb_post_title_url\" href=\"http://www.cnblogs.com/shanksgao/p/5530107.html\">深入解析SQL Server并行执行原理及实践(下)</a></li><li>careyson的 <a id=\"cb_post_title_url\" href=\"http://www.cnblogs.com/CareySon/archive/2013/05/04/PlanCacheInSQLServer.html\">谈一谈SQL Server中的执行计划缓存（上）</a></li><li><a href=\"http://blog.csdn.net/zhaowenzhong/article/details/7211829\">常用 监控SQLSERVER性能计数器</a></li></ul><div class=\"wp_rp_wrap  wp_rp_plain\" ><div class=\"wp_rp_content\"><h3 class=\"related_post_title\">相关文章</h3><ul class=\"related_post wp_rp\" style=\"visibility: visible\"><li ><a href=\"http://blog.jobbole.com/91002/\" class=\"wp_rp_title\">SQL SERVER中什么情况会导致索引查找变成索引扫描</a></li><li ><a href=\"http://blog.jobbole.com/95913/\" class=\"wp_rp_title\">RAID的概念和RAID对于SQL性能的影响</a></li><li ><a href=\"http://blog.jobbole.com/95875/\" class=\"wp_rp_title\">如何查看某个查询用了多少TempDB空间</a></li><li ><a href=\"http://blog.jobbole.com/98633/\" class=\"wp_rp_title\">StackOverflow 这么大，它的架构是怎么样的？</a></li><li ><a href=\"http://blog.jobbole.com/100081/\" class=\"wp_rp_title\">MySQL 读写分离介绍及搭建</a></li><li ><a href=\"http://blog.jobbole.com/94173/\" class=\"wp_rp_title\">如何找出你性能最差的SQL Server查询</a></li><li ><a href=\"http://blog.jobbole.com/103474/\" class=\"wp_rp_title\">SQL SERVER全面优化：写出好语句是习惯</a></li><li ><a href=\"http://blog.jobbole.com/86774/\" class=\"wp_rp_title\">SQL Server基础：游标</a></li><li ><a href=\"http://blog.jobbole.com/95897/\" class=\"wp_rp_title\">谈一谈SQL Server中的执行计划缓存（上）</a></li><li ><a href=\"http://blog.jobbole.com/95907/\" class=\"wp_rp_title\">浅谈SQL Server中统计对于查询的影响</a></li></ul></div></div><p><a href=\"http://blog.jobbole.com/104023/\">Expert 诊断优化（1）：你的 CPU 高么？</a>，首发于<a href=\"http://blog.jobbole.com\">文章 - 伯乐在线</a>。</p>") (wfw:commentRss nil "http://blog.jobbole.com/104023/feed/") (slash:comments nil "0")) (item nil (title nil "为什么很多硅谷工程师偏爱 OS X，而不是 Linux 或 Windows？") (link nil "http://blog.jobbole.com/104019/") (comments nil "http://blog.jobbole.com/104019/#comments") (pubDate nil "Mon, 01 Aug 2016 00:10:12 +0000") (dc:creator nil "踏歌行") (category nil "开发") (category nil "Linux") (category nil "Mac") (category nil "Windows") (guid ((isPermaLink . "false")) "http://blog.jobbole.com/?p=104019") (description nil "<p>我看过许多诸如 Google、Dropbox、Quora 等公司的视频，发现有超过 90% 的工程师都在使用 Mac。Mac 为什么这么流行？难道大家没发现下面这些问题嘛？</p><p><a href=\"http://blog.jobbole.com/104019/\">为什么很多硅谷工程师偏爱 OS X，而不是 Linux 或 Windows？</a>，首发于<a href=\"http://blog.jobbole.com\">文章 - 伯乐在线</a>。</p>") (content:encoded nil "<p>【伯乐在线导读】：这个问题源自 Quora。题主说「看过许多诸如 Google、Dropbox、Quora 等公司的视频，发现有超过 90% 的工程师都在使用 Mac。Mac 为什么这么流行？难道大家没发现下面这些问题嘛？」</p><ul><li>昂贵但 GPU 性能一般！</li><li>没 Linux 开放（Linux 允许你编辑任何文件）</li><li>服务器是运行在 Linux 上的，在 Linux 上开发岂不更好。</li></ul><p>伯乐在线摘编了 3 位程序员的回复，全文如下。</p><p><img id=\"pic\" class=\" \" src=\"http://ww2.sinaimg.cn/large/7cc829d3gw1f6dxd5foaej20ci07oglx.jpg\" /></p><h3>Mike Mikowski 的回答，2700+ 顶</h3><p>我觉得以上大部分原因跟问题并不相关。</p><p>图中的这位，显然认为把 Linux 作为自己的首选操作系统，这是个非常好的主意。<br /><img title=\"Jeff Dean\" src=\"https://qph.ec.quoracdn.net/main-qimg-941c7c2232bf5465c5948a36f7a9c210?convert_to_webp=true\" alt=\"Jeff Dean\" /></p><p>他就是 Jeff Dean，在过去十年中为 Google 创造了数十亿美元的收入。</p><p>我们俩的桌面看起来很像：<br /><img title=\"Our's desktop\" src=\"https://qph.ec.quoracdn.net/main-qimg-6dd404a0b476c918ddd410ae906c2170?convert_to_webp=true\" alt=\"Our's desktop\" /></p><p>作为硅谷的一名高级架构师，Linux 和 OS X 我都在使用，但 Linux 更适合我。我坚信 Linux 应该被普及。说实话，OS X 在某些方面的确比 Linux 好，但这优势已经越来越小，因为 OS X 的缺陷越来越多了。</p><p>我相信，当工程师花 2500 美元买了一台 Macbook Retina Pro（16 GB 内存，Intel Iris Pro Graphics 图形处理器 和 AMD Radeon R9 M370X 图形处理器），就会发现 Mac 并没有比 Linux 优秀。随着 Mac 硬件（GPU）进一步落后和软件质量下降，我能预料 Linux 的普及。</p><p>让 Linux 普及的要点是可定制以及厂家的支持。这将解决硬件兼容性问题，启动时再也不会出现“just some old hardware”的提示。我现在用 System76 的笔记本和台式电脑，他们的电脑和售后非常好。我其中的一台笔记本 Oryx Pro 配置如下：搭载 GSync 技术的 GTX970m 显卡，固态硬盘， i7 处理器，32 GB 内存和 IPS 显示器，一点也不比 Macbook Pro 差。同时，我维护着一份 Kubuntu 下装机必备软件列表，欢迎评论和补充。</p><p>以下是我为什么用 Linux 开发和个人电脑的原因：</p><p><strong>1.强劲的 GPU 和 CPU。</strong>我的家用电脑和笔记本都培了顶级的显示器和 GPU。我和孩子 Steam 上玩了有 2000 个游戏，并且我对 CUDA 和 深度学习很感兴趣。而 Mac 对此就无能为力了。对我来说，强大的 GPU 是非常重要的，所以我配了一台搭载 GTX980Ti 显卡、32 GB 内存、3440&#215;1440分辨率的曲面屏、i7 WildDogPro 处理器的电脑。而价格跟 MBP Retina 的价格相差无几。</p><p><strong>2. 与服务器真正的兼容。</strong>我曾工作过的一家公司，半数脚本是用 Linux 脚本和 GNU 工具写的，另一半是 Bash 和 BSD 工具写的，因为这部分开发者坚持用 Mac 开发，并认为 Mac 和 Linux 相差无几。我只想说，这真的太乱了。后来，我花了几周时间重写了代码（为了兼容）。这些人一边说：“Mac OS X 是不同的”，但另一边又说：“Mac OS X 跟 Linux 相差无几”。但事实并不是，Mac OS X 与 Linux 差很多。</p><p><strong>3. Linux 使我更高效。</strong>几乎不需要切换环境，我可以使用相同的工具，专注编写脚本，与服务器无缝衔接。至今，我还没发现哪个 Mac 用户能展现出令我印象深刻的 脚本编写能力。我曾经管理过一个需要超过 100 台以上 Linux 服务器集群的软件，除了 Linux ，其它系统根本胜任不了这个任务。</p><p><strong>4. Linux 上一切允许正常（Everything just works）。</strong>相对那些用 Mac 的同事，我在 Linux 上碰到的问题更少。不需要安装 <a href=\"http://brew.sh/\">homebrew</a>、<a href=\"http://www.finkproject.org/\">fink</a>、<a href=\"https://www.macports.org/\">MacPorts</a>，只要运行 <code>suao apt-get update</code> 和 <code>sudo apt-get upgrade</code> 这两个命令就可以了。团队里有少数人还在坚持使用 Mac，他们认为这是一种荣耀。编写脚本和程序设置电脑， Mac 大概要 2-3 天，而 Linux 只要一个小时，而且几乎是全自动化的。</p><p><strong>5. Linux 能做 Mac 不能做的事。</strong>有一天，我们需要超高清分辨率的屏幕截图，在 Linux 上只要输入: <code>$ xrandr --output DP-2.8 -s 3440x2880 --panning 3440x2880</code> ，之后用 Chrome 把图片放大一倍，并用 Ksnapshot 获得所需图片，前后只需要几分钟。谁能在 Mac 或者 Windows 上实现？</p><p><strong>6. “Linux 上不能运行商业软件”这个争论是毫无意义的</strong>，尤其是在硅谷，这里早就不使用微软的 Office 软件了。我使用 Balsamiq 3、Slack、DropBox、Chrome、Hangout、Google 办公套件、GoToMeeting、WebStorm、Skype、Gimp、Insync等软件&#8230;对了，在休息时间我会在 Steam 上玩会游戏。所有程序都运行良好，几乎没有应用程序或者系统崩溃。Webstorm（JetBrains IDE）在 Linux 上更友好，同样，NodeJS、MongoDB、MySQL和其它一系列开发工具在 Linux 都比 Mac 友好。</p><p>KED/Plasma 的界面比 Mac 和 Windows 都友好多了。你问我为什么这么说，因为我 KDE/Plasma 我都在使用。</p><p>这么多开发人员缺乏系统管理和使用脚本的技能，真是一件令人沮丧的事。相对命令行来说，Mac OS X 的图形界面限制了程序员的思考。如果有一天我在硅谷创业，我会把 Linux 当做首选的操作系统。</p><p><strong>注：</strong></p><ul><li>CUDA：一种由 NVIDIA 推出的通用并行计算架构，该架构使GPU能够解决复杂的计算问题。</li><li>deep learning：深度学习。源于人工神经网络的研究。含多隐层的多层感知器就是一种深度学习结构。深度学习通过组合低层特征形成更加抽象的高层表示属性类别或特征，以发现数据的分布式特征表示。需要 N 卡支持，而 Macbook 基本上配的都是 Intel 显卡。</li></ul><h3>Garry Taloy 的回答，103 顶</h3><p>GPU:</p><p><strong>程序员 != 游戏玩家。</strong></p><p>毫无疑问，配有更快的 GPU 显示效果更好，但除非你是开发游戏或者需要进行 3D 渲染，否则太奢侈了。我自己的两台开发用电脑，都只配备了普通的 Intel 集成显卡。</p><p><strong>Linux 允许你修改任何文件：</strong></p><p>我只是一位程序员，我只关心自己的代码，除此之外，别的文件能否修改和编译我并不关心。或许你该问问自己：什么是我真正需要编辑的？我是否有能力去修改文件？我为什么要这么做？</p><p><strong>在同一个系统下开发更好（代指服务器环境和开发环境相同）</strong></p><p>首先，这个理由相当不错，但对于 Apache 或者其它什么，在 Mac OS X 上和 Linux 上运行的效果是极其相似的。如果使用诸如 OpenVMS 、 IBM i 或者 z/OS 这些操作系统，那就另当别论了。但是，我敢打赌，在 Mac 上运行网页的效果肯定跟 Linux 是一样的。</p><p><strong>Expensive:</strong><br /><strong>贵</strong></p><p>实则不然，在相似情况下，一台搭载高清屏、 SSD 固态硬盘 、工业设计都不错的、你听过的牌子的笔记本， Mac 的价格其实并没有贵多少。姑且就说 Mac 贵几百美元吧，但能给程序员支付高薪的公司，并不会吝啬这部分钱。假设 Google 程序员的年薪是 100,000 美元，加上税收和医疗保险、办公空间等额外支出，Google 每年在程序员身上的花费可能会达到 150000 美元。你认为 Google 会在乎多花 300 美元购买 Mac 嘛？</p><p>这就好像花 10 美元买喜欢的披萨，和话 10.01 美元买你很喜欢的披萨，没多少差别~</p><p>回答你的问题，就要忽略你说的，因为你说的 99% 与问题无关。</p><h3>Ivan Apple 的回答</h3><p><strong>服务器是运行在 Linux 上的，在 Linux 上开发岂不更好</strong></p><p>兄弟，你这让我想起这个论点还有价值的年代。想当年，想用 Linux 却没钱买新电脑，唯一的选择就是将 Linux 作为你的主操作系统（学会忍受糟糕的 GUI、应用少等这些不足之处）。</p><p>如今，通过 VirtualBox，可以很轻松地在 Windows 或 Mac 上安装 Linux 服务器发行版，“在同一个操作系统下开发”就迎刃而解了。</p><p>最终，学习如何调整 KDE Plasma 和 分析 Wi-Fi 驱动并不会让你成为一个更好的程序员和系统管理员。这只是一个习惯问题，而且是相当无聊的习惯。</p><p><strong>Linux 允许你修改任何文件</strong></p><p>这个观点经常出现在争论中。</p><p>我就说一句话：Ubuntu 和 Red Hat 是现实世界中最流行的 Linux 发行版，而它们可以在 VirtualBox 很好的工作。</p><p><strong>昂贵但 GPU 性能一般！</strong></p><p>其实 Mac 并不贵。MB Pro 大概只要 1300 欧元（折合人民币约 9500 元）。而差不多配置 HP 或者 Lenove 笔记本大概要 900 欧元（折合人民币约 6600元）。根据笔记本平均生命周期，购买外形轻薄、耐用（强劲的电池寿命）的 Mac 每个月只要多支付 7 欧元即可。这是一个很划算的投资。</p><h3>你的主力操作系统是哪一个？为什么选用？欢迎大家评论。</h3><div class=\"wp_rp_wrap  wp_rp_plain\" ><div class=\"wp_rp_content\"><h3 class=\"related_post_title\">相关文章</h3><ul class=\"related_post wp_rp\" style=\"visibility: visible\"><li ><a href=\"http://blog.jobbole.com/34764/\" class=\"wp_rp_title\">王垠：漫谈Linux、Windows和Mac</a></li><li ><a href=\"http://blog.jobbole.com/40278/\" class=\"wp_rp_title\">如何在安装双启动后卸载 Windows 或者 Linux</a></li><li ><a href=\"http://blog.jobbole.com/97676/\" class=\"wp_rp_title\">基于 JavaScript 的操作系统你听说过吗？</a></li><li ><a href=\"http://blog.jobbole.com/29546/\" class=\"wp_rp_title\">Ubuntu桌面生存指南(1)：选择 Linux</a></li><li ><a href=\"http://blog.jobbole.com/97892/\" class=\"wp_rp_title\">一个八年的 Linux 老用户使用 Windows 10 的体验</a></li><li ><a href=\"http://blog.jobbole.com/26741/\" class=\"wp_rp_title\">王垠：从工具的奴隶到工具的主人</a></li><li ><a href=\"http://blog.jobbole.com/1574/\" class=\"wp_rp_title\">受够了Linux服务器 重返Windows</a></li><li ><a href=\"http://blog.jobbole.com/85341/\" class=\"wp_rp_title\">Windows 10 VS. Linux</a></li><li ><a href=\"http://blog.jobbole.com/104042/\" class=\"wp_rp_title\">如何在 Linux 下检测内存泄漏</a></li><li ><a href=\"http://blog.jobbole.com/22838/\" class=\"wp_rp_title\">流行Linux和Windows脚本语言列表</a></li></ul></div></div><p><a href=\"http://blog.jobbole.com/104019/\">为什么很多硅谷工程师偏爱 OS X，而不是 Linux 或 Windows？</a>，首发于<a href=\"http://blog.jobbole.com\">文章 - 伯乐在线</a>。</p>") (wfw:commentRss nil "http://blog.jobbole.com/104019/feed/") (slash:comments nil "9")) (item nil (title nil "玩转 Windows 10 中的 Linux 子系统") (link nil "http://blog.jobbole.com/104012/") (comments nil "http://blog.jobbole.com/104012/#respond") (pubDate nil "Sun, 31 Jul 2016 04:06:39 +0000") (dc:creator nil "ABOER") (category nil "IT技术") (category nil "Linux") (guid ((isPermaLink . "false")) "http://blog.jobbole.com/?p=104012") (description nil "<p>在今年的 Build 2016 上，微软向全世界介绍了他们还处于 Beta 阶段的 Windows 下的 Linux 子系统WSL，它可以让开发者们在 Windows 10 下通过 Bash shell 运行原生的 Ubuntu 用户态二进制程序。如果你参与了 Windows Insider 计划，你就可以在最新的 Windows 10 年度升级版的 Insider 构建版中体验这个功能了。</p><p><a href=\"http://blog.jobbole.com/104012/\">玩转 Windows 10 中的 Linux 子系统</a>，首发于<a href=\"http://blog.jobbole.com\">文章 - 伯乐在线</a>。</p>") (content:encoded nil "<p style=\"text-align: justify\">在今年的 Build 2016 上，微软向全世界<a href=\"https://linux.cn/article-7177-1.html\">介绍了</a>他们还处于 Beta 阶段的 Windows 下的 Linux 子系统（Windows Subsystem for Linux）（WSL），它可以让开发者们在 Windows 10 下通过 Bash shell 运行原生的 Ubuntu 用户态二进制程序。如果你参与了 Windows Insider 计划，你就可以在最新的 Windows 10 年度升级版的 Insider 构建版中体验这个功能了。</p><p style=\"text-align: justify\">Web 开发人员们不用再苦恼所用的 Windows 开发平台上没有合适的 Linux 工具和库了。WSL 是由 Windows 内核团队与 Canonical 合作设计和开发的，可以让 Windows 10 下的开发者们在拥有 Windows 中那些强力支持之外，还能使用 Linux 下丰富的开发环境与工具，而不用启动到另外的操作系统或者使用虚拟机。这绝对是一个“来自开发者，服务开发者”的 Windows 10 特色，它的目的是让开发者们每天的开发工作都变得顺畅而便捷。</p><p style=\"text-align: justify\">在本文中，我会展示给你一些我认为非常有趣的功能，以及告诉你一些可以让你找到更多信息的资源。首先，我会展示 WSL 所集成的那些主要命令（比如 ssh）是如何操作服务器和设备的。其次，我会演示使用 Bash 脚本是如何以简明的方式来自动化执行任务的。其三，我会利用极棒的命令行编译器、一些其它工具以及对 *nix 兼容的能力来玩一个轻量级的古典黑客级游戏： NetHack。最后，我会展示如何使用已有的 Python 脚本和其它来自网上的脚本。</p><blockquote><p>从我的第一台 286 上运行的 Windows 3.0 开始，Windows 就一直是我的主要操作系统和开发环境。不过，我身边也有很多 Linux 服务器和设备。从树莓派和路由器/网关设备这样的物联网设备，到 Minecraft 服务器，它们堆满了我的办公室的每个角落。而我经常要从我的主工作站中去管理和配置这些 Linux 计算机。</p></blockquote><h3 style=\"text-align: justify\">管理服务器和设备</h3><p style=\"text-align: justify\">我在我的家中运行着一台无显示器的 Ubuntu Minecraft 服务器，这是我去年给我十岁大的儿子的圣诞礼物，但是它已经变成了我的玩具而不是他的（好吧，主要是我的玩具）。我以前在我的 Windows 10 电脑上使用几个客户端来管理它，不过我现在想使用 Windows 中的 Bash 里面的 ssh 命令行来管理它。使用类似 PuTTY 或来自 Cygwin 的 Tera Term 这样的应用当然也可以，但是我想试试真正原生而自然的体验也是一种不错的选择。Cygwin 就像是在披萨店订购的披萨一样，好吃，但是没有那种氛围。</p><p style=\"text-align: justify\">我已经使用 WSL 中的 <code>ssh-keygen</code> 和 <code>ssh-copy-id</code> 设置好了公私密钥对，所以使用 ssh 只需要如下简单输入即可：</p><p></p><pre class=\"crayon-plain-tag\">$ ssh &lt;username&gt;@&lt;server&gt;</pre><p></p><p style=\"text-align: justify\">我还为此创建了一个别名，以便更快一些。这是一个标准的 Linux/Bash 功能：</p><p></p><pre class=\"crayon-plain-tag\">$ alias mc='ssh &lt;user&gt;@&lt;server&gt;'</pre><p></p><p style=\"text-align: justify\">现在，我要访问我的 Minecraft 服务器只需要在 Windows 10 下的 Bash 中输入“mc”即可。</p><p style=\"text-align: justify\"><img src=\"http://jbcdn2.b0.upaiyun.com/2016/07/e2775253ec67d3de168cbeafda33e5ba.png\" alt=\" \" width=\"785\" height=\"603\" /></p><p style=\"text-align: justify\">当然，同样的方法你也可以用于任何 Linux 上的 Web 或数据库服务器上，甚至树莓派或其它的物联网设备也可以。</p><blockquote><p>在终端里面进行 ssh 只是为了方便而已，不过当你在 shell 中工作时，如果还有类似 apt、node、Ruby、Python 等等工具时，你就有了自动化各种工作的可能。</p></blockquote><h3 style=\"text-align: justify\">远程脚本</h3><p style=\"text-align: justify\">假如说你有一大堆 Linux 服务器和设备，而你要在它们上面执行一个远程命令的话，如果已经配置好公私密钥对，你就可以在 Bash 中直接远程执行命令。</p><p style=\"text-align: justify\">举个例子说，想知道远程服务器自从上次重启后已经运行了多长时间了，你只需要输入：</p><p></p><pre class=\"crayon-plain-tag\">$ ssh &lt;user&gt;@&lt;server&gt; 'last -x|grep reboot'</pre><p></p><p style=\"text-align: justify\">ssh 会连接到该服务器并执行 <code>last -x</code> 命令，然后搜索包含“reboot”的一行。我在我的 Ubuntu Minecraft 服务器上运行的结果如下：</p><p></p><pre class=\"crayon-plain-tag\">reboot   system boot  4.4.0-28-generic Thu Jul  7 08:14   still running</pre><p></p><p style=\"text-align: justify\">这只是一台服务器，如果你有许多服务器的话，你可以自动化这个过程。我在 WSL 里我的主目录下创建了一个名为 servers.txt 的文件，它包含了一系列 Linux 服务器/设备的名称，每个一行。然后我就可以创建一个脚本来读取这个文件。</p><p style=\"text-align: justify\">在使用了很多年像树莓派这样的设备之后，我已经变成了一个 nano 人（在 VMS 上我是一个 LSEdit 人），下面是我用我喜爱的 nano 编辑器打开的脚本。</p><p style=\"text-align: justify\"><img src=\"http://jbcdn2.b0.upaiyun.com/2016/07/4b3f3d4144ed32d597a063b9915dc18d.png\" alt=\" \" width=\"836\" height=\"268\" /></p><p style=\"text-align: justify\">当然，你也可以使用 vim 、 emacs 或者其它可以用在 Ubuntu 终端上的编辑器。</p><p style=\"text-align: justify\">该脚本是 Bash 脚本，要执行该脚本，输入：</p><p></p><pre class=\"crayon-plain-tag\">$ ./foreachserver.sh 'last -x|grep reboot'</pre><p></p><p style=\"text-align: justify\">它将迭代输出文件中的每个服务器/设备，然后通过 ssh 远程执行该命令。当然，这个例子非常简单，但是你可以像这样把你的本地脚本或其它命令变成远程的。Bash 脚本语言足够丰富，所以你可以使用它来完成你的大多数远程管理任务。你可以用你下载到 WSL 或远程系统中的其它应用来扩展它的使用。</p><blockquote><p>你是否需要在工作中把本地的 Windows 文件或资源用于其它的 Linux 计算机吗？或者，你根本不使用 Linux ？Bash 可以操作本地的 Windows 文件或资源，还是说它就是一个完全独立的环境？</p></blockquote><h3 style=\"text-align: justify\">使用 Windows 文件</h3><p style=\"text-align: justify\">WSL 系统可以通过 <code>/mnt//</code> 目录（挂载点）来访问你计算机上的文件系统。举个例子，你的 Windows 上的 C: 和 D: 根目录可以在 WSL 中相应地通过 /mnt/c 和 /mnt/d 访问。当你要把你的 Windows 下的项目文件、下载的内容和其它文件用到 Linux/Bash 之中时这很有用。</p><p style=\"text-align: justify\"><img src=\"http://jbcdn2.b0.upaiyun.com/2016/07/1701666cc539d37cc44e132663c3835b.png\" alt=\" \" width=\"604\" height=\"193\" /></p><p style=\"text-align: justify\">上图显示的两个目录分别对应于我的计算机上的 SSD 和硬盘：</p><p style=\"text-align: justify\"><img src=\"http://jbcdn2.b0.upaiyun.com/2016/07/bab4932042fba9e803e88a829b6a200a.png\" alt=\" \" width=\"556\" height=\"104\" /></p><p style=\"text-align: justify\">这是逻辑挂载，所以当你在 shell 中使用类似 <code>mount</code> 这样的命令时它们不会显示。但是它们可以如你预期的那样工作。举个例子，在 Windows 中，我在我的 C 盘根目录下放了一个名为 test.txt 的文件，我可以在 WSL 中如下访问它：</p><p style=\"text-align: justify\"><img src=\"http://jbcdn2.b0.upaiyun.com/2016/07/06344269f0e21908b291acf215d98ba0.png\" alt=\" \" width=\"774\" height=\"151\" /></p><p style=\"text-align: justify\">在 Build  Tour 大会期间，我们要确保所有的演示都可以在没有互联网时也能正常工作（你绝不会知道会场的网络是什么样子的） ，所以为了让 Bash/WSL 可以演示 Git 操作，该演示访问的是本地计算机上的 Windows 文件，我在 Windows 上的 C:gitNetHack 下设置一个本地仓库。 要在 WSL 中进行 clone 操作，我执行了如下命令：</p><p></p><pre class=\"crayon-plain-tag\">$ git –clone file:///mnt/c/git/NetHack</pre><p></p><p style=\"text-align: justify\">该命令告诉 git 使用 <code>file://</code> 协议，并 clone 了位于 /mnt/c/git/NetHack 下的仓库。你可以以类似的方式来访问你的 Windows 下的所有文件。</p><p style=\"text-align: justify\">警示：就像在其它终端中一样，如果你不小心的话，你可以在 Bash 中修改/删除 Windows 文件系统中的文件。举个例子，你可以像下面这样来干掉你的 Windows ，假如你有合适的权限的话。</p><p></p><pre class=\"crayon-plain-tag\">$ rm -rf /mnt/c/  [千万别试！][千万别试！][千万别试！]</pre><p></p><p style=\"text-align: justify\">我之所以郑重提醒是因为我们很多人都是刚刚接触 Linux 命令，它们不是 Windows 命令。</p><p style=\"text-align: justify\">这种可以让文件系统集成到一起的魔法来自 DrvFs。如果你希望了解该文件系统的更多细节，以及它是如何工作在 WSL 中的，WSL 团队为此写了一篇<a href=\"https://blogs.msdn.microsoft.com/wsl/2016/06/15/wsl-file-system-support/\">详细的文章</a>。</p><blockquote><p>当然， 文件系统访问只是 WSL 其中的一部分功能而已，许多开发任务还需要通过 HTTP 或其它网络协议访问远程资源。</p></blockquote><h3 style=\"text-align: justify\">发起 HTTP 请求</h3><p style=\"text-align: justify\">从脚本或命令行而不是从一个编译好的程序或 Web 页面上发起 REST 或其它 HTTP（或 FTP）请求是很有用的。就像在大多数 Linux 发行版一样，WSL 也包括了类似 curl 或 wget 获取资源这样的标准功能，它们可以用来发起 HTTP 或者其它网络请求。举个例子，下面是使用 curl 对 Github 发起 REST 请求来获取我个人的属性信息：</p><p></p><pre class=\"crayon-plain-tag\">$ curl -i https://api.github.com/users/Psychlist1972
HTTP/1.1 200 OK
Server: GitHub.com
Date: Wed, 13 Jul 2016 02:38:08 GMT
Content-Type: application/json; charset=utf-8
Content-Length: 1319
Status: 200 OK
...
{
  \"login\": \"Psychlist1972\",
  \"avatar_url\": \"https://avatars.githubusercontent.com/u/1421146?v=3\",
  \"url\": \"https://api.github.com/users/Psychlist1972\",
  \"name\": \"Pete Brown\",
  \"company\": \"Microsoft\",
   ...
}
$</pre><p></p><p style=\"text-align: justify\">你可以用它和 Bash 脚本来创建一个 REST API 的快速测试客户端，也可以用来探测一个 Web 页面或服务器并报告其返回的状态。它用来从网上下载文件也很棒，你可以简单地重定向输出到一个文件而不是在屏幕上显示它：</p><p></p><pre class=\"crayon-plain-tag\">$ curl -i https://api.github.com/users/Psychlist1972 &gt; pete.json</pre><p></p><p style=\"text-align: justify\">我也是一个 PowerShell 用户，甚至还使用 <a href=\"https://github.com/Psychlist1972/Windows-10-PowerShell-MIDI\">Windows 10 MIDI in PowerShell</a> 创建了一些有趣的扩展，也<a href=\"https://github.com/Psychlist1972/Fix-SoundDevices-File-Corruption\">修复</a>过出现在特定的录音硬件设备上的一些文件问题。作为长时间的 .NET 开发者和爱好者，我经常使用和扩展 PowerShell 以满足我的项目需求。但是  PowerShell 并不是一个可以运行所有的那些 Bash 脚本和针对 Linux 的开源工具的地方。我希望以一种最简单、最舒服的方式来完成这些任务，在某种意义上，这意味着我们需要在 Bash 中完成它们。</p><blockquote><p>我已经一掠而过的介绍了 Bash、Bash 脚本以及你可以在 shell 中完成的任务。到目前为止，我谈论的都是有助于开发工作的那些功能。但是在 WSL 中实际的开发和编译工作是怎样的？我在 Build Tour 大会上演示了下面这个部分。</p></blockquote><h3 style=\"text-align: justify\">Build Tour 大会上的演示：NetHack</h3><p style=\"text-align: justify\">这个夏初，来自微软的讲演者们向大家演示了一些来自 Windows 和微软云上的很酷的开发者新功能。作为其中的一部分，我以一种好玩的方式来演示了 WSL，而且这是一种和开发者们相关的方式。</p><p style=\"text-align: justify\">我个人想要展示使用 git 和一些传统的终端开发工具，我已经写好了 Bash 的演示程序，包括了这些基础的东西（用 Python 和 Ruby 写的“Hello World”），不过我还是想要更有冲击力一些。</p><p style=\"text-align: justify\">我回想起我在大学的时光，那时我们在 Unix（DEC Ultrix 及 SunOS）和 VAX/VMS 之间折腾，Unix 几乎全是命令行环境。在我们学校，绝大多数使用图形工作站的用户只是为了在不同的窗口打开多个终端会话而已，当然，会在桌面背景放上一张超酷的月相图。大部分学生都是使用 VT-220 终端来打开他们的会话（学校离波士顿不远，所以我们有很多 DEC 设备）。</p><p style=\"text-align: justify\">那时，计算机系的学生们主要玩两大游戏：MUD （主要是 lpMUD 和当时刚出的 DikuMUD）和 <a href=\"https://en.wikipedia.org/wiki/NetHack\">NetHack</a>。NetHack 和其它的 <a href=\"https://en.wikipedia.org/wiki/Roguelike\">Roguelikes</a> 类游戏被视为历史上最有影响力的游戏之一，它们是许多现在流行的地牢冒险和角色扮演类游戏的鼻祖。</p><p style=\"text-align: justify\">NetHack 有很长的历史，现在的它包含了来自几十年前的几十万行 *nix 代码，以及后来补充的一些代码。该游戏使用 <a href=\"https://en.wikipedia.org/wiki/Curses_(programming_library)\">curses</a> （及其替代品）作为终端交互方式，需要通过 lex、 yacc（或 flex 和 bison）和 cc（或 gcc），以及一堆其它的开发工具构建。</p><p style=\"text-align: justify\">它是由 C 语言编写的，并包括了一些用 <a href=\"https://en.wikipedia.org/wiki/Bourne_shell\">Bourne shell</a> 编写的复杂的脚本配置功能。我觉得它是一个体现 WSL 和 Bash on Windows 10 的开发者能力的不错而有趣的方式。由于使用了 curses（在 Linux 和 WSL 中是 libncurses 库），它也可以用来展示 Windows 10 中命令行窗口中的终端模拟能力。</p><p style=\"text-align: justify\">以前，在我们的分时 Ultrix 服务器上从源代码构建 NetHack 要花费掉我们很多时间，而现在我的个人计算机上只需要几分钟就可以搞定。我喜欢这种技术进步。在 Linux 或 WSL 上配置和编译 NetHack 有容易和复杂两种方式。为了节省时间，我们会以容易的方式来进行。</p><h4 style=\"text-align: justify\">前置需求</h4><p style=\"text-align: justify\">首先，更新你的 WSL 环境，确保你的软件是最新的。在安装新的软件包之前，这是一个好的做法。</p><p></p><pre class=\"crayon-plain-tag\">$ sudo apt update
$ sudo apt upgrade</pre><p></p><p style=\"text-align: justify\">然后，安装必须的开发工具。最简单的办法就是使用 build-essential 软件包，它包括了 Linux 开发者构建以 C/C++ 开发的软件时所需的绝大部分程序。</p><p></p><pre class=\"crayon-plain-tag\">$ sudo apt install build-essential</pre><p></p><p style=\"text-align: justify\">这要花几分钟。如果你想更加深入地了解，你可以分别安装 gcc、gdb、make、flex、bison 以及 NetHack 文档中提到的其它工具。不过如果你是一位开发者，有时候你可能还需要一些其它工具。 build-essential 基本上提供了你所需的工具集。</p><p style=\"text-align: justify\">然后，安装 git。如你所想，很容易：</p><p></p><pre class=\"crayon-plain-tag\">$ sudo apt install git</pre><p></p><p style=\"text-align: justify\">就像在 Linux 中一样，你可以添加一个 git 的 PPA 来获取较新的版本，不过这里我们有一个就行了。</p><p style=\"text-align: justify\">最后，我们需要安装 curses（实际上是 ncurses）来进行终端屏幕交互。</p><p></p><pre class=\"crayon-plain-tag\">$ sudo apt install libncurses-dev</pre><p></p><p style=\"text-align: justify\">当我们完成这些步骤之后，就可以开始构建 NetHack 了。</p><h4 style=\"text-align: justify\">构建 NetHack</h4><p style=\"text-align: justify\">官方的 NetHack 仓库放在 <a href=\"https://github.com/NetHack/NetHack\">GitHub</a> 上，首先我们需要把它抓取下来放到我们的主目录里面。</p><p></p><pre class=\"crayon-plain-tag\">$ cd ~$ git clone http://github.com/NetHack/NetHack</pre><p></p><p style=\"text-align: justify\"><img src=\"http://jbcdn2.b0.upaiyun.com/2016/07/5d751b6d3dccf35a8c949227f7cabf36.png\" alt=\" \" width=\"906\" height=\"225\" /></p><p style=\"text-align: justify\">因为 NetHack 支持很多种操作系统，所以我们需要做一些基础配置来告诉它我们使用的是 Linux，并且用开源的 gcc 代替了了 Unix 上 cc 的作用。</p><p style=\"text-align: justify\">如我所提到的，这有好几种办法可以实现。有些人想很周到，将这些配置信息放到了 hints 文件中。相信我，使用 hints 文件会避免遇到该 GitHub 仓库中提到的很多麻烦。在 README 文件和其它文档中并没有着重提到如何使用 hints 文件，我们可以这样做：</p><p></p><pre class=\"crayon-plain-tag\">$ cd NetHack/sys/unix
$ ./setup.sh hints/linux</pre><p></p><p style=\"text-align: justify\">这将会设置 Makefile 正确的使用 Linux 下的工具、库及其路径。这个设置脚本很强大，它做了大量的配置工作，很高兴它在 WSL 中工作的也很好。如果你很好奇这个脚本是如何写的，你可以使用你的编辑器打开它一窥究竟。</p><p style=\"text-align: justify\">然后，开始最终的构建：</p><p></p><pre class=\"crayon-plain-tag\">$ cd ~/NetHack
$ make all</pre><p></p><p style=\"text-align: justify\">构建完成之后，你需要安装它。这其实就是将可执行文件复制到目标位置：</p><p></p><pre class=\"crayon-plain-tag\">$ make install</pre><p></p><p style=\"text-align: justify\">它会安装到你的 ~/nh 文件夹下， NetHack 放在 ~/nh/install/games 目录，名为 nethack。要运行它，切换到该目录（或输入完整路径）并输入：</p><p></p><pre class=\"crayon-plain-tag\">$ cd ~/nh/install/games
$ nethack</pre><p></p><p style=\"text-align: justify\">然后，屏幕会清屏并显示你可以玩 NetHack 了。注意，所有的东西都是在这个 Ubuntu Linux 环境中完成的，根本不需要任何 Windows 特有的东西。</p><h4 style=\"text-align: justify\">玩 NetHack</h4><p style=\"text-align: justify\">由于终端游戏的局限性和 NetHack 的复杂性，这里只能一带而过。对于初次接触它的人来说，还有一些神秘的地方，不过我觉得我们程序员们从来不怕挑战未知。</p><p style=\"text-align: justify\">方向键和 vi（vim）中的一样，HJKL 是左、下、上、右。要退出游戏，你可以在地下城顶层找到楼梯出口然后使用它就可以，或者直接按下 CTRL-C 强制退出。</p><p style=\"text-align: justify\">在 NetHack 中， @ 符号代表你自己，每一层都由房间、走廊、门，和向上及向下的楼梯组成。<a href=\"https://nethackwiki.com/wiki/Monster\">怪物</a>、<a href=\"https://nethackwiki.com/wiki/Item\">宝箱和物品</a>以各种 ASCII  字符组成，你慢慢就会熟悉它们。为了符合 Roguelikes 游戏规范，并没有存盘功能，你只有一条命。如果你死了就只能重玩，地下城环境是随机生成的，各种物品也是打乱放置的。</p><p style=\"text-align: justify\">NetHack 游戏的目的是在地下城生存，收集金子和物品，尽可能的干掉各种怪物。除了这些目的之外，你就是不断在其中玩来找它们。规则大致遵循“龙与地下城（DnD）”的武器、技能等规则。</p><p style=\"text-align: justify\">下面的 NetHack 截屏上可以看到有三个房间和两个走廊。向上的楼梯在左上角的房间里，我现在在右上角的房间，还有一些宝箱和其它物品。</p><p style=\"text-align: justify\"><img src=\"http://jbcdn2.b0.upaiyun.com/2016/07/0444a5ac1c36099fab318f6f218b3543.png\" alt=\" \" width=\"938\" height=\"540\" /></p><p style=\"text-align: justify\">如果在你的游戏中没有显示颜色，可以创建一个名为 ~/.nethackrc 的文件，并放入如下内容：</p><p></p><pre class=\"crayon-plain-tag\">OPTIONS=color:true,dark_room:true,menucolors:true</pre><p></p><p style=\"text-align: justify\">注：如果 ASCII 字符图形不是你的菜，但是你喜欢这种类型的游戏，你可以在微软商店搜索“roguelike”来找到视觉上更好看的这种游戏。</p><p style=\"text-align: justify\">当然，NetHack 很古老了，可能只有特定年龄段的人们喜欢它。不过，构建它用到了大量重要的开发工具和 *nix 操作系统功能，也包括终端模拟功能。从这里可以看到，从 gcc、gdb、make、bison 和 flex 到更现代一些的 git，都在 WSL 里面工作的很好。</p><p style=\"text-align: justify\">如果你想看看 Build Tour 大会上的演示，你可以在 Build Tour 加拿大大会上看到这个讲演。WSL 的这部分演示在 6:20 开始。</p><p style=\"text-align: justify\">希望你能喜欢在 NetHack 地下城中的探险。</p><blockquote><p>C 和 C++ 都很伟大，就像其他的那些经典的开发工具一样。你甚至还可以用普通的 Bash 脚本做到很多。不过，也有很多开发者喜欢用 Python 做为他们的脚本语言。</p></blockquote><h3 style=\"text-align: justify\">Python</h3><p style=\"text-align: justify\">你可以在网上找到很多 Python 脚本的例子，这意味着 Python 越来越流行，也越来越有用了。当然，大多数情况下这些例子都是运行在 Linux 下的。在过去，这就需要我们有另外一台安装着 Linux 的机器来运行它们，或者使用虚拟机和多引导，否则就需要修改一些东西才能让他们运行在 Windows 下的 Python 环境中。</p><p style=\"text-align: justify\">这是都不是无法解决的问题，但是它会日渐消磨开发人员每天的生活。通过 WSL，不用折腾你就拥有了一个兼容的、具有 Python 功能和 shell 变量的子系统。</p><p style=\"text-align: justify\">要安装最新的 Python 开发版本和 Python 包安装器 pip，在 Bash 中执行如下命令：</p><p></p><pre class=\"crayon-plain-tag\">$ sudo apt install python-pip python-dev
$ sudo pip install --upgrade pip</pre><p></p><p style=\"text-align: justify\">现在 Python 安装好了，我要展示给你如何从网上获取一个典型的 Linux 下的 Python 例子并让它直接工作起来。我去 <a href=\"http://code.activestate.com/recipes/langs/python/?query_start=1\">Activestate Python 菜谱站</a>找一个排名第一的 Python 例子。好吧，我走眼了，排名第一的是打印出整数名称的脚本，这看起来没啥意思，所以我选择了第二名：俄罗斯方块。我们每天都能看到 Python 出现在各种地方，所以这次让我们去玩另外一个游戏。</p><p style=\"text-align: justify\"><img src=\"http://jbcdn2.b0.upaiyun.com/2016/07/7a3462bf51dfc902a3fc42170364562f.png\" alt=\" \" width=\"800\" /></p><p style=\"text-align: justify\">我打开了 nano 编辑器，从 Windows 上的浏览器中打开的页面上复制了这 275 行 Python 代码，然后粘贴到我的 WSL 终端窗口终端中的 nano 中，并保存为 tetris.py ，然后执行它：</p><p></p><pre class=\"crayon-plain-tag\">$ python tetris.py</pre><p></p><p style=\"text-align: justify\">它马上就清屏并出现了俄罗斯方块的游戏。同 NetHack 一样，你可以使用同样的 vi 标准的方向键来移动（以前是使用鼠标和 WSAD 键来移动，而右手使用 HJKL 键更方便）。</p><p style=\"text-align: justify\"><img src=\"http://jbcdn2.b0.upaiyun.com/2016/07/6f239710255586c43a466f9d1a46cf41.png\" alt=\" \" width=\"325\" height=\"560\" /></p><p style=\"text-align: justify\">如我所提到的，你当然可以不用 WSL 就在 Windows 中运行 Python。然而，要想快速简便，不用修改 Linux 下的 Python 代码，只需要简单的复制粘贴代码即可运行，则可以极大的提高开发者的效率。</p><p style=\"text-align: justify\">这是真的。这并不是要替代 Windows 原生的工具，比如 Python、PowerShell、C# 等等，而是当你需要在现代的开发工作流程中快速而有效地完成一些事情时，可以避免种种折腾。</p><p style=\"text-align: justify\">包括 Bash、Python 以及其它所有的 Linux 原生的命令行开发工具，WSL 为我的开发工作提供了所有需要的工具。这不是一个 Linux 服务器，甚至也不是一个完整的客户端，相反，它就是一个可以让我避免每天折腾，让我在 Windows 上开发更有效率、更有快感的一个东西！</p><hr /><h3 style=\"text-align: justify\">重置你的 WSL 环境</h3><p style=\"text-align: justify\">随便去试吧，如果你搞坏了你的 WSL 环境，它很容易重新安装。在进行之前，请确保做好了任何重要内容的备份。</p><p></p><pre class=\"crayon-plain-tag\">C:&gt; lxrun.exe /uninstall /full
C:&gt; lxrun.exe /install</pre><p></p><h3 style=\"text-align: justify\">你使用 Bash 和 WSL 的感觉如何？</h3><p style=\"text-align: justify\">我们希望 WSL ，特别是 Bash 可以在 Windows 10 中帮你带来更高的效率，减少每天的开发中的折腾。</p><p style=\"text-align: justify\">你对 Windows 10 上的 WSL 怎么看？你喜欢使用它吗？</p><p style=\"text-align: justify\">开发团队做了大量的工作希望让 WSL 成为一个为开发者提供的强大的终端工具。如果你有任何反馈或运行出现问题，我们推荐你查看一下 <a href=\"https://github.com/Microsoft/BashOnWindows/issues\">GitHub 反馈页面</a>，以及 <a href=\"https://wpdev.uservoice.com/forums/266908-command-prompt-console-bash-on-ubuntu-on-windo\">用户之声的反馈和投票站点</a>。我们真的希望听到你的声音。</p><h3 style=\"text-align: justify\">更多参考与延伸阅读</h3><p style=\"text-align: justify\">Linux shell 编程是一个庞大的话题，在网上有很多这方面的内容。如果你还不够熟悉它们，想要了解更多，可以看看各种 Bash 教程。<a href=\"https://help.ubuntu.com/community/Beginners/BashScripting\">可以从这一份开始</a>。</p><p style=\"text-align: justify\">还有一些其他的参考资料也许对你有用：</p><ul style=\"text-align: justify\"><li><a href=\"https://channel9.msdn.com/Events/Build/Build-Tour-2016-Toronto\">Build Tour videos</a></li><li><a href=\"https://help.ubuntu.com/community/Beginners/BashScripting\">Bash Scripting 101</a></li><li><a href=\"https://msdn.microsoft.com/commandline/wsl/\">WSL Home</a></li><li><a href=\"https://blogs.msdn.microsoft.com/commandline/2016/06/02/learn-more-about-bash-on-ubuntu-on-windows-and-the-windows-subsystem-for-linux/\">WSL Overview</a></li><li><a href=\"https://msdn.microsoft.com/en-us/commandline/wsl/faq#how-do-i-update-bash-on-ubuntu-on-windows-\">WSL FAQ</a></li><li><a href=\"https://blogs.msdn.microsoft.com/wsl/2016/06/08/wsl-system-calls/\">WSL System Calls</a></li><li><a href=\"http://www.hanselman.com/blog/VIDEOHowToRunLinuxAndBashOnWindows10AnniversaryUpdate.aspx\">Scott Hanselman’s video on how to run WSL</a></li></ul><p style=\"text-align: justify\">哦，当然，要更多的了解 NetHack，请访问 <a href=\"http://www.nethack.org/\">NetHack 主站</a>。</p><div class=\"wp_rp_wrap  wp_rp_plain\" ><div class=\"wp_rp_content\"><h3 class=\"related_post_title\">相关文章</h3><ul class=\"related_post wp_rp\" style=\"visibility: visible\"><li ><a href=\"http://blog.jobbole.com/97676/\" class=\"wp_rp_title\">基于 JavaScript 的操作系统你听说过吗？</a></li><li ><a href=\"http://blog.jobbole.com/93132/\" class=\"wp_rp_title\">Linux Shell 管道命令(pipe)使用及与 Shell 重定向区别</a></li><li ><a href=\"http://blog.jobbole.com/92792/\" class=\"wp_rp_title\">Linux Shell 创建序列数组</a></li><li ><a href=\"http://blog.jobbole.com/104042/\" class=\"wp_rp_title\">如何在 Linux 下检测内存泄漏</a></li><li ><a href=\"http://blog.jobbole.com/40278/\" class=\"wp_rp_title\">如何在安装双启动后卸载 Windows 或者 Linux</a></li><li ><a href=\"http://blog.jobbole.com/98633/\" class=\"wp_rp_title\">StackOverflow 这么大，它的架构是怎么样的？</a></li><li ><a href=\"http://blog.jobbole.com/29668/\" class=\"wp_rp_title\">Ubuntu桌面生存指南(2)：Ubuntu桌面体验简介</a></li><li ><a href=\"http://blog.jobbole.com/31614/\" class=\"wp_rp_title\">Learn Linux The Hard Way/笨办法学Linux</a></li><li ><a href=\"http://blog.jobbole.com/85341/\" class=\"wp_rp_title\">Windows 10 VS. Linux</a></li><li ><a href=\"http://blog.jobbole.com/48195/\" class=\"wp_rp_title\">如何保证Linux服务器的安全</a></li></ul></div></div><p><a href=\"http://blog.jobbole.com/104012/\">玩转 Windows 10 中的 Linux 子系统</a>，首发于<a href=\"http://blog.jobbole.com\">文章 - 伯乐在线</a>。</p>") (wfw:commentRss nil "http://blog.jobbole.com/104012/feed/") (slash:comments nil "0")) (item nil (title nil "年轻人，你为啥使用 Linux") (link nil "http://blog.jobbole.com/104008/") (comments nil "http://blog.jobbole.com/104008/#comments") (pubDate nil "Sun, 31 Jul 2016 03:55:50 +0000") (dc:creator nil "ABOER") (category nil "IT技术") (category nil "Linux") (guid ((isPermaLink . "false")) "http://blog.jobbole.com/?p=104008") (description nil "<p>Linux 越来越流行，很多 OS X 或 Windows 用户都转移到 Linux 阵营了。但是你知道是什么让他们开始使用 Linux 的吗？一个 Reddit 用户在网站上问了这个问题，并且得到了很多有趣的回答。 </p><p><a href=\"http://blog.jobbole.com/104008/\">年轻人，你为啥使用 Linux</a>，首发于<a href=\"http://blog.jobbole.com\">文章 - 伯乐在线</a>。</p>") (content:encoded nil "<p class=\"p1\" style=\"text-align: justify\">Linux 越来越流行，很多 OS X 或 Windows 用户都转移到 Linux 阵营了。但是你知道是什么让他们开始使用 Linux 的吗？一个 Reddit 用户在网站上问了这个问题，并且得到了很多有趣的回答。</p><p class=\"p1 article_img\" style=\"text-align: justify\"><a href=\"http://jbcdn2.b0.upaiyun.com/2016/07/430141ccef7d54501e2b6091ed6bc959.jpg\"><img class=\"alignnone size-full wp-image-104009\" src=\"http://jbcdn2.b0.upaiyun.com/2016/07/430141ccef7d54501e2b6091ed6bc959.jpg\" alt=\"122648qajvaz5akz6jkuzk\" /></a></p><p class=\"p2\" style=\"text-align: justify\"><span class=\"s1\">一个名为 SilverKnight 的用户在 Reddit 的 Linux 版块上问了如下问题：</span></p><blockquote><p class=\"p3\"><span class=\"s1\">我知道这个问题肯定被问过了，但我还是想听听年轻一代使用 Linux 的原因，以及是什么让他们坚定地成为 Linux 用户。</span></p><p class=\"p3\"><span class=\"s1\">我无意阻止大家讲出你们那些精彩的 Linux 故事，但是我还是对那些没有经历过什么精彩故事的新人的想法比较感兴趣。</span></p><p class=\"p3\"><span class=\"s1\">我27岁，半吊子 Linux 用户，这些年装过不少发行版，但没有投入全部精力去玩 Linux。我正在找更多的、能让我全身心投入到 Linux 潮流的理由，或者说激励。</span></p></blockquote><p class=\"p2\" style=\"text-align: justify\"><span class=\"s1\">以下是网站上的回复：</span></p><blockquote><p class=\"p3\" style=\"text-align: justify\"><span class=\"s3\"><strong>DoublePlusGood</strong></span><span class=\"s1\">：我12岁开始使用 Backtrack（现在改名为 Kali），因为我想成为一名黑客（LCTT 译注：原文“1337 haxor”，1337 是 leet 的火星文写法，意为&#8217;火星文&#8217;，haxor 为 hackor 的火星文写法，意为&#8217;黑客&#8217;，另一种写法是 1377 h4x0r，满满的火星文文化）。我现在一直使用 ArchLinux，因为它给我无限自由，让我对我的电脑可以为所欲为。</span></p><p class=\"p3\" style=\"text-align: justify\"><span class=\"s3\"><strong>Zack</strong></span><span class=\"s1\">：我记得是12、3岁的时候使用 Linux，现在15岁了。</span></p><p class=\"p3\" style=\"text-align: justify\"><span class=\"s1\">我11岁的时候就对 Windows XP 感到不耐烦，一个简单的功能，比如关机，TMD 都要让我耐心等着它慢慢完成。</span></p><p class=\"p3\" style=\"text-align: justify\"><span class=\"s1\">在那之前几个月，我在 freenode IRC 聊天室参与讨论了一个游戏，它是一个开源项目，大多数用户使用 Linux。</span></p><p class=\"p3\" style=\"text-align: justify\"><span class=\"s1\">我不断听到 Linux 但当时对它还没有兴趣。然而由于这些聊天频道（大部分在 freenode 上）谈论了很多编程话题，我就开始学习 python 了。</span></p><p class=\"p3\" style=\"text-align: justify\"><span class=\"s1\">一年后我尝试着安装 GNU/Linux （主要是 ubuntu）到我的新电脑（其实不新，但它是作为我的生日礼物被我得到的）。不幸的是它总是不能正常工作，原因未知，也许硬盘坏了，也许灰尘太多了。</span></p><p class=\"p3\" style=\"text-align: justify\"><span class=\"s1\">那时我放弃自己解决这个问题，然后缠着老爸给我的电脑装上 Ubuntu，他也无能为力，原因同上。</span></p><p class=\"p3\" style=\"text-align: justify\"><span class=\"s1\">在追求 Linux 一段时间后，我打算抛弃 Windows，使用 Linux Mint 代替 Ubuntu，本来没抱什么希望，但 Linux Mint 竟然能跑起来！</span></p><p class=\"p3\" style=\"text-align: justify\"><span class=\"s1\">于是这个系统我用了6个月。</span></p><p class=\"p3\" style=\"text-align: justify\"><span class=\"s1\">那段时间我的一个朋友给了我一台虚拟机，跑 Ubuntu 的，我用了一年，直到我爸给了我一台服务器。</span></p><p class=\"p3\" style=\"text-align: justify\"><span class=\"s1\">6个月后我得到一台新 PC（现在还在用）。于是起想折腾点不一样的东西。</span></p><p class=\"p3\" style=\"text-align: justify\"><span class=\"s1\">我打算装 openSUSE。</span></p><p class=\"p3\" style=\"text-align: justify\"><span class=\"s1\">我很喜欢这个系统。然后在圣诞节的时候我得到树莓派，上面只能跑 Debian，还不能支持其它发行版。</span></p><p class=\"p3\" style=\"text-align: justify\"><span class=\"s3\"><strong>Cqz</strong></span><span class=\"s1\">：我9岁的时候有一次玩 Windows 98，结果这货当机了，原因未知。我没有 Windows 安装盘，但我爸的一本介绍编程的杂志上有一张随书附赠的光盘，这张光盘上刚好有 Mandrake Linux 的安装软件，于是我瞬间就成为了 Linux 用户。我当时还不知道自己在玩什么，但是玩得很嗨皮。这些年我虽然在电脑上装了多种 Windows 版本，但是 FLOSS 世界才是我的家（LCTT 译注：FLOSS —— Free/Libre and Open Source Software，自由/开源软件）。现在我只把 Windows 装在虚拟机上，用来玩游戏。</span></p><p class=\"p3\" style=\"text-align: justify\"><span class=\"s3\"><strong>Tosmarcel</strong></span><span class=\"s1\">：15岁那年对&#8217;编程&#8217;这个概念很好奇，然后我开始了哈佛课程&#8217;CS50&#8217;，这个课程要我们安装 Linux 虚拟机用来执行一些命令。当时我问自己为什么 Windows 没有这些命令？于是我 Google 了 Linux，搜索结果出现了 Ubuntu，在安装 Ubuntu 的时候不小心把 Windows 分区给删了。。。当时对 Linux 毫无所知，适应这个系统非常困难。我现在16岁，用 ArchLinux，不想用回 Windows，我爱 ArchLinux。</span></p><p class=\"p3\" style=\"text-align: justify\"><span class=\"s3\"><strong>Micioonthet</strong></span><span class=\"s1\">：第一次听说 Linux 是在我5年级的时候，当时去我一朋友家，他的笔记本装的就是 MEPIS（Debian的一个比较老的衍生版），而不是 XP。</span></p><p class=\"p3\" style=\"text-align: justify\"><span class=\"s1\">原来是他爸爸是个美国的社会学家，而他全家都不信任微软。我对这些东西完全陌生，这系统完全没有我熟悉的软件，我很疑惑他怎么能使用。</span></p><p class=\"p3\" style=\"text-align: justify\"><span class=\"s1\">我13岁那年还没有自己的笔记本电脑，而我另一位朋友总是抱怨他的电脑有多慢，所以我打算把它买下来并修好它。我花了20美元买下了这台装着 Windows Vista 系统、跑满病毒、完全无法使用的惠普笔记本。我不想重装讨厌的 Windows 系统，记得 Linux 是免费的，所以我刻了一张 Ubuntu 14.04 光盘，马上把它装起来，然后我被它的高性能给震精了。</span></p><p class=\"p3\" style=\"text-align: justify\"><span class=\"s1\">“我的世界（Minecraft）”（由于它允许运行在 JAVA 上，所以当时它是 Linux 下为数不多的几个游戏之一）在 Vista 上只能跑5帧每秒，而在 Ubuntu 上能跑到25帧。</span></p><p class=\"p3\" style=\"text-align: justify\"><span class=\"s1\">我到现在还会偶尔使用一下那台笔记本，Linux 可不会在乎你的硬件设备有多老。</span></p><p class=\"p3\" style=\"text-align: justify\"><span class=\"s1\">之后我把我爸也拉入 Linux 行列，我们会以很低的价格买老电脑，装上 Linux Mint 或其他轻量级发行版，这省了好多钱。</span></p><p class=\"p3\" style=\"text-align: justify\"><span class=\"s3\"><strong>Webtm</strong></span><span class=\"s1\">：我爹每台电脑都会装多个发行版，有几台是 opensuse 和 Debian，他的个人电脑装的是 Slackware。所以我记得很小的时候一直在玩 debian，但没有投入很多精力，我用了几年的 Windows，然后我爹问我有没有兴趣试试 debian。这是个有趣的经历，在那之后我一直使用 debian。而现在我不用 Linux，转投 freeBSD，5个月了，用得很开心。</span></p><p class=\"p3\" style=\"text-align: justify\"><span class=\"s1\">完全控制自己的系统是个很奇妙的体验。开源界有好多酷酷的软件，我认为在自己解决一些问题并且利用这些工具解决其他事情的过程是最有趣的。当然稳定和高效也是吸引我的地方。更不用说它的保密级别了。</span></p><p class=\"p3\" style=\"text-align: justify\"><span class=\"s3\"><strong>Wyronaut</strong></span><span class=\"s1\">：我今年18，第一次玩 Linux 是13岁，当时玩的 Ubuntu，为啥要碰 Linux？因为我想搭一个“我的世界”的服务器来和小伙伴玩游戏，当时“我的世界”可是个新鲜玩意儿。而搭个私服需要用 Linux 系统。</span></p><p class=\"p3\" style=\"text-align: justify\"><span class=\"s1\">当时我还是个新手，对着 Linux 的命令行有些傻眼，因为很多东西都要我自己处理。还是多亏了 Google 和维基，我成功地在多台老 PC 上部署了一些简单的服务器，那些早已无人问津的老古董机器又能发挥余热了。</span></p><p class=\"p3\" style=\"text-align: justify\"><span class=\"s1\">跑过游戏服务器后，我又开始跑 web 服务器，先是跑了几年 HTML，CSS 和 PHP，之后受 TheNewBoston 视频的误导转到了 JAVA。</span></p><p class=\"p3\" style=\"text-align: justify\"><span class=\"s1\">一周后放弃 JAVA 改用 Python，当时学习 Python 用的书名叫《Learn Python The Hard Way》，作者是 Zed A. Shaw。我花了两周学完 Python，然后开始看《C++ Primer》，因为我想做游戏开发。看到一半（大概500页）的时候我放弃了。那个时候我有点讨厌玩电脑了。</span></p><p class=\"p3\" style=\"text-align: justify\"><span class=\"s1\">这样中断了一段时间之后，我决定学习 JavaScript，读了2本书，试了4个平台，然后又不玩了。</span></p><p class=\"p3\" style=\"text-align: justify\"><span class=\"s1\">现在到了不得不找一所学校并决定毕业后找什么样工作的糟糕时刻。我不想玩图形界面编程，所以我不会进游戏行业。我也不喜欢画画和建模。然后我发现了一个涉及网络安全的专业，于是我立刻爱上它了。我挑了很多 C 语言的书来度过这个假期，并且复习了一下数学来迎接新的校园生活。</span></p><p class=\"p3\" style=\"text-align: justify\"><span class=\"s1\">目前我玩 archlinux，不同 PC 上跑着不同任务，它们运行很稳定。</span></p><p class=\"p3\" style=\"text-align: justify\"><span class=\"s1\">可以说 Linux 带我进入编程的世界，而反过来，我最终在学校要学的就是 Linux。我估计会终生感谢 Linux。</span></p><p class=\"p3\" style=\"text-align: justify\"><span class=\"s3\"><strong>Linuxllc</strong></span><span class=\"s1\">：你们可以学学像我这样的老头。</span></p><p class=\"p3\" style=\"text-align: justify\"><span class=\"s1\">扔掉 Windows！扔掉 Windows！扔掉 Windows！给自己一个坚持使用 Linux 的理由，那就是完全，彻底，远离，Windows。</span></p><p class=\"p3\" style=\"text-align: justify\"><span class=\"s1\">我在 2003 年放弃 Windows，只用了5天就把所有电脑跑成 Linux，包括所有的外围设备（LCTT 译注：比如打印机？）。我不玩 Windows 里的游戏，只玩 Linux 里的。</span></p><p class=\"p3\" style=\"text-align: justify\"><span class=\"s3\"><strong>Highclass</strong></span><span class=\"s1\">：我28岁，不知道还是不是你要找的年轻人类型。</span></p><p class=\"p3\" style=\"text-align: justify\"><span class=\"s1\">老实说我对电脑挺感兴趣的，当我还没接触&#8217;自由软件哲学&#8217;的时候，我认为 free 是免费的意思。我也不认为命令行界面很让人难以接受，因为我小时候就接触过 DOS 系统。</span></p><p class=\"p3\" style=\"text-align: justify\"><span class=\"s1\">我第一个发行版是 Mandrake，在我11岁还是12岁那年我把家里的电脑弄得乱七八糟，然后我一直折腾那台电脑，试着让我自己的技能提升一个台阶。现在我在一家公司全职使用 Linux。（请允许我耸个肩）。</span></p><p class=\"p3\" style=\"text-align: justify\"><span class=\"s3\"><strong>Matto</strong></span><span class=\"s1\">：我的电脑是旧货市场淘回来的，装 XP，跑得慢，于是我想换个系统。Google 了一下，发现 Ubuntu。当年我15、6岁，现在23了，就职的公司内部使用 Linux。</span></p></blockquote><div class=\"wp_rp_wrap  wp_rp_plain\" ><div class=\"wp_rp_content\"><h3 class=\"related_post_title\">相关文章</h3><ul class=\"related_post wp_rp\" style=\"visibility: visible\"><li ><a href=\"http://blog.jobbole.com/97676/\" class=\"wp_rp_title\">基于 JavaScript 的操作系统你听说过吗？</a></li><li ><a href=\"http://blog.jobbole.com/93132/\" class=\"wp_rp_title\">Linux Shell 管道命令(pipe)使用及与 Shell 重定向区别</a></li><li ><a href=\"http://blog.jobbole.com/92792/\" class=\"wp_rp_title\">Linux Shell 创建序列数组</a></li><li ><a href=\"http://blog.jobbole.com/104042/\" class=\"wp_rp_title\">如何在 Linux 下检测内存泄漏</a></li><li ><a href=\"http://blog.jobbole.com/29546/\" class=\"wp_rp_title\">Ubuntu桌面生存指南(1)：选择 Linux</a></li><li ><a href=\"http://blog.jobbole.com/98705/\" class=\"wp_rp_title\">2016：如何选择 Linux 桌面环境</a></li><li ><a href=\"http://blog.jobbole.com/98056/\" class=\"wp_rp_title\">2016：如何选择 Linux 发行版</a></li><li ><a href=\"http://blog.jobbole.com/98947/\" class=\"wp_rp_title\">盘点这些以国家名义研发的 Linux 系统</a></li><li ><a href=\"http://blog.jobbole.com/34764/\" class=\"wp_rp_title\">王垠：漫谈Linux、Windows和Mac</a></li><li ><a href=\"http://blog.jobbole.com/40278/\" class=\"wp_rp_title\">如何在安装双启动后卸载 Windows 或者 Linux</a></li></ul></div></div><p><a href=\"http://blog.jobbole.com/104008/\">年轻人，你为啥使用 Linux</a>，首发于<a href=\"http://blog.jobbole.com\">文章 - 伯乐在线</a>。</p>") (wfw:commentRss nil "http://blog.jobbole.com/104008/feed/") (slash:comments nil "2")) (item nil (title nil "七种WebSocket框架的性能比较") (link nil "http://blog.jobbole.com/103994/") (comments nil "http://blog.jobbole.com/103994/#comments") (pubDate nil "Sun, 31 Jul 2016 03:49:18 +0000") (dc:creator nil "ABOER") (category nil "IT技术") (category nil "Scala") (category nil "WebSocket") (guid ((isPermaLink . "false")) "http://blog.jobbole.com/?p=103994") (description nil "<p>最近我又使用几个框架实现了websocket push服务器的原型，并专门对这七种实现做了测试。 本文记录了测试结果和一些对结果的分析。</p><p><a href=\"http://blog.jobbole.com/103994/\">七种WebSocket框架的性能比较</a>，首发于<a href=\"http://blog.jobbole.com\">文章 - 伯乐在线</a>。</p>") (content:encoded nil "<p style=\"text-align: justify\">前一篇文章<a href=\"http://blog.jobbole.com/103995/\">使用四种框架分别实现百万websocket常连接的服务器</a>介绍了四种websocket框架的测试方法和基本数据。 最近我又使用几个框架实现了websocket push服务器的原型，并专门对这七种实现做了测试。 本文记录了测试结果和一些对结果的分析。<br />
这七种框架是：</p><ul style=\"text-align: justify\"><li><a href=\"http://netty.io/\" target=\"_blank\" rel=\"external\">Netty</a></li><li><a href=\"http://undertow.io/\" target=\"_blank\" rel=\"external\">Undertow</a></li><li><a href=\"http://www.eclipse.org/jetty/\" target=\"_blank\" rel=\"external\">Jetty</a></li><li><a href=\"http://http://vertx.io\" target=\"_blank\" rel=\"external\">Vert.x</a></li><li><a href=\"https://grizzly.java.net/\" target=\"_blank\" rel=\"external\">Grizzly</a></li><li><a href=\"https://github.com/wandoulabs/spray-websocket\" target=\"_blank\" rel=\"external\">spray-websocket</a></li><li><a href=\"https://github.com/sitegui/nodejs-websocket\" target=\"_blank\" rel=\"external\">nodejs-websocket/Node.js</a></li></ul><p style=\"text-align: justify\">最近用Golang实现了第八种，Go表现还不错。</p><ul style=\"text-align: justify\"><li><a href=\"https://golang.org/\" target=\"_blank\" rel=\"external\">Go</a></li></ul><h2 id=\"测试环境\" style=\"text-align: justify\">测试环境</h2><p style=\"text-align: justify\">使用三台C3.4xlarge AWS服务器做测试。 一台作为服务器，两台作为客户端机器， 每台客户端机器启动10个client,一共20个client<br />
C3.4xlarge的配置如下：</p><table cellspacing=\"0\" cellpadding=\"1\"><tbody><tr><td width=\"57\" height=\"42\">型号</td><td width=\"29\">vCPU</td><td width=\"42\">内存 (GiB)</td><td width=\"42\">SSD 存储 (GB)</td></tr><tr><td width=\"57\" height=\"15\">c3.large</td><td width=\"29\">2</td><td width=\"42\">3.75</td><td width=\"42\">2 x 16</td></tr><tr><td width=\"57\" height=\"15\">c3.xlarge</td><td width=\"29\">4</td><td width=\"42\">7.5</td><td width=\"42\">2 x 40</td></tr><tr><td width=\"57\" height=\"15\">c3.2xlarge</td><td width=\"29\">8</td><td width=\"42\">15</td><td width=\"42\">2 x 80</td></tr><tr><td width=\"57\" height=\"15\">c3.4xlarge</td><td width=\"29\">16</td><td width=\"42\">30</td><td width=\"42\">2 x 160</td></tr><tr><td width=\"57\" height=\"15\">c3.8xlarge</td><td width=\"29\">32</td><td width=\"42\">60</td><td width=\"42\">2 x 320</td></tr></tbody></table><p style=\"text-align: justify\">服务器和客户端机器按照上一篇文章做了基本的优化。</p><p style=\"text-align: justify\">以下是测试的配置数据：</p><ul style=\"text-align: justify\"><li>20 clients</li><li>setup rate设为500 * 20 requests/second = 10000 request /second</li><li>每个client负责建立50000个websocket 连接</li><li>等1,000,000个websocket建好好，发送一个消息(时间戳)给所有的客户端，客户端根据时间戳计算latency</li><li>如果服务器setup rate建立很慢，主动停止测试</li><li>监控三个阶段的性能指标： setup时， setup完成后应用发呆(idle)时，发送消息时</li></ul><h2 id=\"测试结果\" style=\"text-align: justify\">测试结果</h2><h3 id=\"Netty\" style=\"text-align: justify\">Netty</h3><p style=\"text-align: justify\"><strong>Setup时</strong></p><ul style=\"text-align: justify\"><li>cpu idle: 90%</li><li>minor gc: Few</li><li>full gc: No</li></ul><p style=\"text-align: justify\"><strong>Setup完成， 应用Idle时</strong></p><ul style=\"text-align: justify\"><li>cpu idle: 100%</li><li>memory usage: 1.68G</li><li>server free memory: 16.3G</li></ul><p style=\"text-align: justify\"><strong>发送消息时</strong></p><ul style=\"text-align: justify\"><li>cpu idle: 75%</li><li>minor gc: few</li><li>full gc: No</li><li>Message latency (one client)<br /><pre class=\"crayon-plain-tag\">count = 50000
         min = 0
         max = 18301
        mean = 2446.09
      stddev = 3082.11
      median = 1214.00
        75% 3625.00
        95% 8855.00
        98% 12069.00
        99% 13274.00
      99.9% 18301.00</pre></li></ul><h3 id=\"Vert-x\" style=\"text-align: justify\">Vert.x</h3><p style=\"text-align: justify\"><strong>Setup时</strong></p><ul style=\"text-align: justify\"><li>cpu idle: 95%</li><li>minor gc: Few</li><li>full gc: No</li></ul><p style=\"text-align: justify\"><strong>Setup完成， 应用Idle时</strong></p><ul style=\"text-align: justify\"><li>cpu idle: 100%</li><li>memory usage: 6.37G</li><li>server free memory: 16.3G</li></ul><p style=\"text-align: justify\"><strong>发送消息时</strong></p><ul style=\"text-align: justify\"><li>cpu idle: 47% ~ 76%</li><li>minor gc: few</li><li>full gc: few</li><li>Message latency (one client)<br /><pre class=\"crayon-plain-tag\">count = 50000
         min = 49
         max = 18949
        mean = 10427.00
      stddev = 5182.72
      median = 10856.00
        75% 14934.00
        95% 17949.00
        98% 18458.00
        99% 18658.00
      99.9% 18949.00</pre></li></ul><h3 id=\"Undertow\" style=\"text-align: justify\">Undertow</h3><p style=\"text-align: justify\"><strong>Setup时</strong></p><ul style=\"text-align: justify\"><li>cpu idle: 90%</li><li>minor gc: Few</li><li>full gc: No</li></ul><p style=\"text-align: justify\"><strong>Setup完成， 应用Idle时</strong></p><ul style=\"text-align: justify\"><li>cpu idle: 100%</li><li>memory usage: 4.02G</li><li>server free memory: 14.2G</li></ul><p style=\"text-align: justify\"><strong>发送消息时</strong></p><ul style=\"text-align: justify\"><li>cpu idle: 65%</li><li>minor gc: few</li><li>full gc: No</li><li>Message latency<br /><pre class=\"crayon-plain-tag\">count = 50000
         min = 1
         max = 11948
        mean = 1366.86
      stddev = 2007.77
      median = 412.00
        75% 2021.00
        95% 5838.00
        98% 7222.00
        99% 8051.00
      99.9% 11948.00</pre></li></ul><h3 id=\"Jetty\" style=\"text-align: justify\">Jetty</h3><p style=\"text-align: justify\"><strong>Setup时</strong></p><ul style=\"text-align: justify\"><li>cpu idle: 2%</li><li>minor gc: Many</li><li>full gc: No</li><li>memory usage: 5G</li><li>server free memory: 17.2G</li></ul><p style=\"text-align: justify\"><em>当建立360,000左右的websocket时， setup非常的慢， gc频繁，无法继续正常建立websocket， 主动终止测试。</em></p><h3 id=\"Grizzly\" style=\"text-align: justify\">Grizzly</h3><p style=\"text-align: justify\"><strong>Setup时</strong></p><ul style=\"text-align: justify\"><li>cpu idle: 20%</li><li>minor gc: Some</li><li>full gc: Some</li><li>memory usage: 11.5G</li><li>server free memory: 12.3G</li></ul><p style=\"text-align: justify\"><em>当建立500,000左右的websocket时， setup非常的慢， gc频繁，无法继续正常建立websocket， 主动终止测试。</em></p><h3 id=\"Spray\" style=\"text-align: justify\">Spray</h3><p style=\"text-align: justify\"><strong>Setup时</strong></p><ul style=\"text-align: justify\"><li>cpu idle: 80%</li><li>minor gc: Many</li><li>full gc: No</li></ul><p style=\"text-align: justify\"><em>当建立500,000左右的websocket时， setup非常的慢， gc频繁，无法继续正常建立websocket， 主动终止测试。</em></p><h3 id=\"Node-js\" style=\"text-align: justify\">Node.js</h3><p style=\"text-align: justify\"><strong>Setup时</strong></p><ul style=\"text-align: justify\"><li>cpu idle: 94%</li></ul><p style=\"text-align: justify\"><strong>Setup完成， 应用Idle时</strong></p><ul style=\"text-align: justify\"><li>cpu idle: 100%</li><li>memory usage: 5.0G</li><li>server free memory: 16.3G</li></ul><p style=\"text-align: justify\"><strong>发送消息时</strong></p><ul style=\"text-align: justify\"><li>cpu idle: 94%</li><li>Message latency (one client)</li><li>Message latency<br /><pre class=\"crayon-plain-tag\">count = 50000
         min = 0
         max = 18
        mean = 1.27
      stddev = 3.08
      median = 1.00
        75% 1.00
        95% 1.00
        98% 1.00
        99% 1.00
      99.9% 15.00</pre></li></ul><h3 id=\"Go\" style=\"text-align: justify\">Go</h3><p style=\"text-align: justify\"><strong>Setup时</strong></p><ul style=\"text-align: justify\"><li>cpu idle: 94%</li></ul><p style=\"text-align: justify\"><strong>Setup完成， 应用Idle时</strong></p><ul style=\"text-align: justify\"><li>cpu idle: 100%</li><li>memory usage: 15G</li><li>server free memory: 6G</li></ul><p style=\"text-align: justify\"><strong>发送消息时</strong></p><ul style=\"text-align: justify\"><li>cpu idle: 94%</li><li>Message latency (one client)</li><li>Message latency<br /><pre class=\"crayon-plain-tag\">count = 50000
         min = 0
         max = 35
        mean = 1.89
      stddev = 1.83
      median = 1.00
        75% 1.00
        95% 2.00
        98% 2.00
        99% 4.00
      99.9% 34.00</pre></li></ul><h2 id=\"测试结果分析\" style=\"text-align: justify\">测试结果分析</h2><ul><li style=\"text-align: justify\">Netty, Go, Node.js, Undertow, Vert.x都能正常建立百万连接。 Jetty, Grizzly 和 Spray未能完成百万连接</li><li style=\"text-align: justify\">Netty表现最好。内存占用非常的少， CPU使用率也不高。 尤其内存占用，远远小于其它框架</li><li style=\"text-align: justify\">Jetty, Grizzly和Spray会产生大量的中间对象，导致垃圾回收频繁。Jetty表现最差</li><li style=\"text-align: justify\">Node.js表现非常好。 尤其是测试中使用单实例单线程，建立速度非常快，消息的latency也很好。 内存占用也不错</li><li style=\"text-align: justify\">Undertow表现也不错，内存占用比Netty高一些，其它差不多</li><li style=\"text-align: justify\">这里还未测到Spray另一个不好的地方。 在大量连接的情况小，即使没有消息发送，Spray也会占用40% CPU 时间</li></ul><div class=\"wp_rp_wrap  wp_rp_plain\" ><div class=\"wp_rp_content\"><h3 class=\"related_post_title\">相关文章</h3><ul class=\"related_post wp_rp\" style=\"visibility: visible\"><li ><a href=\"http://blog.jobbole.com/89446/\" class=\"wp_rp_title\">Apache Spark 入门简介</a></li><li ><a href=\"http://blog.jobbole.com/46091/\" class=\"wp_rp_title\">有趣的 Scala 语言: 使用递归的方式去思考</a></li><li ><a href=\"http://blog.jobbole.com/46094/\" class=\"wp_rp_title\">有趣的 Scala 语言: 简洁的 Scala 语法</a></li><li ><a href=\"http://blog.jobbole.com/16631/\" class=\"wp_rp_title\">致Play Framework开发者们的一封信</a></li><li ><a href=\"http://blog.jobbole.com/1477/\" class=\"wp_rp_title\">向Java开发者介绍Scala</a></li><li ><a href=\"http://blog.jobbole.com/68531/\" class=\"wp_rp_title\">JVM 并发性: Java 和 Scala 并发性基础</a></li><li ><a href=\"http://blog.jobbole.com/1536/\" class=\"wp_rp_title\">函数式编程很难，这正是你要学的原因</a></li><li ><a href=\"http://blog.jobbole.com/63036/\" class=\"wp_rp_title\">趣文：编程语言拟人化（第二弹）</a></li><li ><a href=\"http://blog.jobbole.com/923/\" class=\"wp_rp_title\">如何判断开发语言的复杂度？</a></li><li ><a href=\"http://blog.jobbole.com/1263/\" class=\"wp_rp_title\">为什么我喜欢富于表达性的编程语言</a></li></ul></div></div><p><a href=\"http://blog.jobbole.com/103994/\">七种WebSocket框架的性能比较</a>，首发于<a href=\"http://blog.jobbole.com\">文章 - 伯乐在线</a>。</p>") (wfw:commentRss nil "http://blog.jobbole.com/103994/feed/") (slash:comments nil "1")) (item nil (title nil "四种框架分别实现百万websocket常连接的服务器") (link nil "http://blog.jobbole.com/103995/") (comments nil "http://blog.jobbole.com/103995/#respond") (pubDate nil "Sun, 31 Jul 2016 03:45:46 +0000") (dc:creator nil "ABOER") (category nil "IT技术") (category nil "服务器") (category nil "架构") (guid ((isPermaLink . "false")) "http://blog.jobbole.com/?p=103995") (description nil "<p>著名的 C10K 问题提出的时候， 正是 2001 年。这篇文章可以说是高性能服务器开发的一个标志性文档，它讨论的就是单机为1万个连接提供服务这个问题，当时因为硬件和软件的限制，单机1万还是一个非常值得挑战的目标。</p><p><a href=\"http://blog.jobbole.com/103995/\">四种框架分别实现百万websocket常连接的服务器</a>，首发于<a href=\"http://blog.jobbole.com\">文章 - 伯乐在线</a>。</p>") (content:encoded nil "<blockquote><p style=\"text-align: justify;\">事实上，最近我又增加了几个框架，现在包括 Netty, Undertow, Jetty, Spray, Vert.x, Grizzly 和 Node.js七种框架。<br />
测试数据可以看下一篇文章: <a href=\"http://blog.jobbole.com/103994/\">七种WebSocket框架的性能比较</a></p></blockquote><p style=\"text-align: justify;\">著名的 <a href=\"http://www.kegel.com/c10k.htm\" target=\"_blank\" rel=\"external\">C10K</a> 问题提出的时候, 正是 2001 年。这篇文章可以说是高性能服务器开发的一个标志性文档，它讨论的就是单机为1万个连接提供服务这个问题，当时因为硬件和软件的限制，单机1万还是一个非常值得挑战的目标。但是时光荏苒，随着硬件和软件的飞速发展，单机1万的目标已经变成了最简单不过的事情。</p><p style=\"text-align: justify;\">现在用任何一种主流语言都能提供单机1万的并发处理的能力。所以现在目标早已提高了100倍，变成C1000k，也就是一台服务器为100万连接提供服务。在2010年,2011年已经看到一些实现C1000K的文章了，所以在2015年，实现C1000K应该不是一件困难的事情。</p><p style=\"text-align: justify;\">本文是我在实践过程中的记录，我的目标是使用spran-websocket，netty, undertow和node.js四种框架分别实现C1000K的服务器，看看这几个框架实现的难以程度，性能如何。开发语言为Scala和Javascript。</p><p style=\"text-align: justify;\">当然，谈起性能，我们还必须谈到每秒每个连接有多少个请求，也就是RPS数，还要考虑每条消息的大小。<br />
一般来说，我们会选取一个百分比，比如每秒20%的连接会收发消息。我的需求是服务器只是<code>push</code>,客户端不会主动发送消息。 一般每一分钟会为这一百万群发一条消息。</p><p style=\"text-align: justify;\">所以实现的测试工具每个client建立60000个websocket连接，一共二十个client。实际不可能使用20台机器，我使用了两台AWS C3.2xlarge(8核16G)服务器作为客户端机。每台机器10个客户端。<br />
服务器每1分钟群发一条消息。消息内容很简单，只是服务器的当天时间。</p><p style=\"text-align: justify;\">最近看到360用Go实现的消息推送系统，下面是他们的数据：</p><blockquote><p>目前360消息推送系统服务于50+内部产品，万款开发平台App，实时长连接数亿量级，日独数十亿量级，1分钟内可以实现亿量级广播，日下发峰值百亿量级，400台物理机，3000多个实例分布在9个独立集群中，每个集群跨国内外近10个IDC。</p></blockquote><p style=\"text-align: justify;\"><strong>四个服务器的代码和Client测试工具代码可以在<a href=\"https://github.com/smallnest/C1000K-Servers\" target=\"_blank\" rel=\"external\">github</a>上下载。</strong> (其实不止四种框架了，现在包括Netty, Undertow, Jetty, Spray-websocket, Vert.x, Grizzly 和 Node.js 七种框架的实现)</p><p style=\"text-align: justify;\">测试下来可以看到每种服务器都能轻松达到同时120万的websocket活动连接，只是资源占用和事务处理时间有差别。120万只是保守数据，在这么多连接情况下服务器依然很轻松，下一步我会进行C2000K的测试。</p><p style=\"text-align: justify;\"><a id=\"more\"></a>在测试之前我们需要对服务器/客户机的一些参数进行调优。</p><h3 id=\"服务器的参数调优\" style=\"text-align: justify;\">服务器的参数调优</h3><p style=\"text-align: justify;\">一般会修改两个文件，<code>/etc/sysctl.conf</code>和<code>/etc/security/limits.conf</code>， 用来配置TCP/IP参数和最大文件描述符。</p><h4 id=\"TCP/IP参数配置\" style=\"text-align: justify;\">TCP/IP参数配置</h4><p style=\"text-align: justify;\">修改文件<code>/etc/sysctl.conf</code>,配置网络参数。</p><figure style=\"text-align: justify;\"></figure><p></p><pre class=\"crayon-plain-tag\">net.ipv4.tcp_wmem = 4096 87380 4161536
net.ipv4.tcp_rmem = 4096 87380 4161536
net.ipv4.tcp_mem = 786432 2097152 3145728</pre><p></p><p style=\"text-align: justify;\">数值根据需求进行调整。更多的参数可以看以前整理的一篇文章: <a href=\"http://colobu.com/2014/09/18/linux-tcpip-tuning/\" target=\"_blank\" rel=\"external\">Linux TCP/IP 协议栈调优 </a>。<br />
执行<code>/sbin/sysctl -p</code>即时生效。</p><h4 id=\"最大文件描述符\" style=\"text-align: justify;\">最大文件描述符</h4><p style=\"text-align: justify;\">Linux内核本身有文件描述符最大值的限制，你可以根据需要更改：</p><ul style=\"text-align: justify;\"><li>系统最大打开文件描述符数：/proc/sys/fs/file-max
<ol><li>临时性设置：<code>echo 1000000 &gt; /proc/sys/fs/file-max</code></li><li>永久设置：修改<code>/etc/sysctl.conf</code>文件，增加<code>fs.file-max = 1000000</code></li></ol></li><li>进程最大打开文件描述符数<br />
使用<code>ulimit -n</code>查看当前设置。使用<code>ulimit -n 1000000</code>进行临时性设置。<br />
要想永久生效，你可以修改<code>/etc/security/limits.conf</code>文件，增加下面的行：</li></ul><figure style=\"text-align: justify;\"></figure><p></p><pre class=\"crayon-plain-tag\">* hard nofile 1000000
* soft nofile 1000000
root hard nofile 1000000
root soft nofile 1000000</pre><p></p><p style=\"text-align: justify;\">还有一点要注意的就是hard limit不能大于<code>/proc/sys/fs/nr_open</code>，因此有时你也需要修改nr_open的值。<br />
执行<code>echo 2000000 &gt; /proc/sys/fs/nr_open</code></p><p style=\"text-align: justify;\">查看当前系统使用的打开文件描述符数，可以使用下面的命令：</p><figure style=\"text-align: justify;\"></figure><p></p><pre class=\"crayon-plain-tag\">[root@localhost ~]# cat /proc/sys/fs/file-nr
1632 0 1513506</pre><p></p><p style=\"text-align: justify;\">其中第一个数表示当前系统已分配使用的打开文件描述符数，第二个数为分配后已释放的（目前已不再使用），第三个数等于file-max。</p><p style=\"text-align: justify;\">总结一下：</p><ul style=\"text-align: justify;\"><li>所有进程打开的文件描述符数不能超过/proc/sys/fs/file-max</li><li>单个进程打开的文件描述符数不能超过user limit中nofile的soft limit</li><li>nofile的soft limit不能超过其hard limit</li><li>nofile的hard limit不能超过/proc/sys/fs/nr_open</li></ul><h4 id=\"应用运行时调优\" style=\"text-align: justify;\">应用运行时调优</h4><ol style=\"text-align: justify;\"><li>Java 应用内存调优<br />
服务器使用12G内存，吞吐率优先的垃圾回收器：</li></ol><figure style=\"text-align: justify;\"></figure><p style=\"text-align: justify;\">2. V8引擎</p><figure style=\"text-align: justify;\"></figure><p></p><pre class=\"crayon-plain-tag\">node --nouse-idle-notification --expose-gc --max-new-space-size=1024 --max-new-space-size=2048 --max-old-space-size=8192 ./webserver.js</pre><p></p><h4 id=\"OutOfMemory_Killer\" style=\"text-align: justify;\">OutOfMemory Killer</h4><p style=\"text-align: justify;\">如果服务器本身内存不大，比如8G，在不到100万连接的情况下，你的服务器进程有可能出现&#8221;Killed&#8221;的问题。 运行<code>dmesg</code>可以看到</p><figure style=\"text-align: justify;\"></figure><p></p><pre class=\"crayon-plain-tag\">Out of memory: Kill process 10375 (java) score 59 or sacrifice child</pre><p></p><p style=\"text-align: justify;\">这是Linux的OOM Killer主动杀死的。 开启oom-killer的话，在/proc/pid下对每个进程都会多出3个与oom打分调节相关的文件。临时对某个进程可以忽略oom-killer可以使用下面的方式:<br /><code>echo -17 &gt; /proc/$(pidof java)/oom_adj</code><br />
解决办法有多种，可以参看文章最后的参考文章,最好是换一个内存更大的机器。</p><h3 id=\"客户端的参数调优\" style=\"text-align: justify;\">客户端的参数调优</h3><p style=\"text-align: justify;\">在一台系统上，连接到一个远程服务时的本地端口是有限的。根据TCP/IP协议，由于端口是16位整数，也就只能是0到 65535，而0到1023是预留端口，所以能分配的端口只是1024到65534，也就是64511个。也就是说，一台机器一个IP只能创建六万多个长连接。<br />
要想达到更多的客户端连接，可以用更多的机器或者网卡，也可以使用虚拟IP来实现,比如下面的命令增加了19个IP地址，其中一个给服务器用，其它18个给client,这样<br />
可以产生18 * 60000 = 1080000个连接。</p><figure style=\"text-align: justify;\"></figure><p></p><pre class=\"crayon-plain-tag\">ifconfig eth0:0 192.168.77.10 netmask 255.255.255.0 up
ifconfig eth0:1 192.168.77.11 netmask 255.255.255.0 up
ifconfig eth0:2 192.168.77.12 netmask 255.255.255.0 up
ifconfig eth0:3 192.168.77.13 netmask 255.255.255.0 up
ifconfig eth0:4 192.168.77.14 netmask 255.255.255.0 up
ifconfig eth0:5 192.168.77.15 netmask 255.255.255.0 up
ifconfig eth0:6 192.168.77.16 netmask 255.255.255.0 up
ifconfig eth0:7 192.168.77.17 netmask 255.255.255.0 up
ifconfig eth0:8 192.168.77.18 netmask 255.255.255.0 up
ifconfig eth0:9 192.168.77.19 netmask 255.255.255.0 up
ifconfig eth0:10 192.168.77.20 netmask 255.255.255.0 up
ifconfig eth0:11 192.168.77.21 netmask 255.255.255.0 up
ifconfig eth0:12 192.168.77.22 netmask 255.255.255.0 up
ifconfig eth0:13 192.168.77.23 netmask 255.255.255.0 up
ifconfig eth0:14 192.168.77.24 netmask 255.255.255.0 up
ifconfig eth0:15 192.168.77.25 netmask 255.255.255.0 up
ifconfig eth0:16 192.168.77.26 netmask 255.255.255.0 up
ifconfig eth0:17 192.168.77.27 netmask 255.255.255.0 up
ifconfig eth0:18 192.168.77.28 netmask 255.255.255.0 up</pre><p></p><p style=\"text-align: justify;\">修改<code>/etc/sysctl.conf</code>文件：</p><figure style=\"text-align: justify;\"></figure><p></p><pre class=\"crayon-plain-tag\">net.ipv4.ip_local_port_range = 1024 65535</pre><p></p><p style=\"text-align: justify;\">执行<code>/sbin/sysctl -p</code>即时生效。</p><h3 id=\"服务器测试\" style=\"text-align: justify;\">服务器测试</h3><p style=\"text-align: justify;\">实际测试中我使用一台<strong>AWS C3.4xlarge (16 cores, 32G memory)</strong>作为应用服务器，两台<strong>AWS C3.2xlarge (8 cores, 16G memory)</strong>服务器作为客户端。<br />
这两台机器作为测试客户端绰绰有余，每台客户端机器创建了十个内网虚拟IP, 每个IP创建60000个websocket连接。</p><p style=\"text-align: justify;\"><strong>客户端配置如下</strong>：<br /><em><code>/etc/sysctl.conf</code>配置</em></p><figure style=\"text-align: justify;\"></figure><p></p><pre class=\"crayon-plain-tag\">fs.file-max = 2000000
fs.nr_open = 2000000
net.ipv4.ip_local_port_range = 1024 65535</pre><p></p><p style=\"text-align: justify;\"><em><code>/etc/security/limits.conf</code>配置</em></p><figure style=\"text-align: justify;\"></figure><p></p><pre class=\"crayon-plain-tag\">* soft nofile 2000000
* hard nofile 2000000
 
* soft nproc 2000000
* hard nproc 2000000</pre><p></p><p style=\"text-align: justify;\"><strong>服务端配置如下</strong>：<br /><em><code>/etc/sysctl.conf</code>配置</em></p><figure style=\"text-align: justify;\"></figure><p></p><pre class=\"crayon-plain-tag\">fs.file-max = 2000000
fs.nr_open = 2000000
net.ipv4.ip_local_port_range = 1024 65535</pre><p></p><p style=\"text-align: justify;\"><em><code>/etc/security/limits.conf</code>配置</em></p><figure style=\"text-align: justify;\"></figure><p></p><pre class=\"crayon-plain-tag\">* soft nofile 2000000
* hard nofile 2000000
 
* soft nproc 2000000
* hard nproc 2000000</pre><p></p><h4 id=\"Netty服务器\" style=\"text-align: justify;\">Netty服务器</h4><ul style=\"text-align: justify;\"><li>建立120万个连接，不发送消息，轻轻松松达到。内存还剩14G未用。</li></ul><figure style=\"text-align: justify;\"></figure><ul style=\"text-align: justify;\"><li><pre class=\"crayon-plain-tag\">[roocolobu ~]# ss -s; free -m
Total: 1200231 (kernel 1200245)
TCP: 1200006 (estab 1200002, closed 0, orphaned 0, synrecv 0, timewait 0/0), ports 4
 
Transport Total IP IPv6
* 1200245 - -
RAW 0 0 0
UDP 1 1 0
TCP 1200006 1200006 0
INET 1200007 1200007 0
FRAG 0 0 0
 
total used free shared buffers cached
Mem: 30074 15432 14641 0 9 254
-/+ buffers/cache: 15167 14906
Swap: 815 0 815</pre><br />
每分钟给所有的120万个websocket发送一条消息，消息内容为当前的服务器的时间。这里发送显示是单线程发送，服务器发送完120万个总用时15秒左右。</li></ul><figure style=\"text-align: justify;\"><pre class=\"crayon-plain-tag\">02:15:43.307 [pool-1-thread-1] INFO com.colobu.webtest.netty.WebServer$ - send msg to channels for c4453a26-bca6-42b6-b29b-43653767f9fc
02:15:57.190 [pool-1-thread-1] INFO com.colobu.webtest.netty.WebServer$ - sent 1200000 channels for c4453a26-bca6-42b6-b29b-43653767f9fc</pre><br /></figure><p style=\"text-align: justify;\">发送时CPU使用率并不高，网络带宽占用基本在10M左右。</p><figure style=\"text-align: justify;\"></figure><p></p><pre class=\"crayon-plain-tag\">----total-cpu-usage---- -dsk/total- -net/total- ---paging-- ---system--
usr sys idl wai hiq siq| read writ| recv send| in out | int csw
0 0 100 0 0 0| 0 0 | 60B 540B| 0 0 | 224 440
0 0 100 0 0 0| 0 0 | 60B 870B| 0 0 | 192 382
0 0 100 0 0 0| 0 0 | 59k 74k| 0 0 |2306 2166
2 7 87 0 0 4| 0 0 |4998k 6134k| 0 0 | 169k 140k
1 7 87 0 0 5| 0 0 |4996k 6132k| 0 0 | 174k 140k
1 7 87 0 0 5| 0 0 |4972k 6102k| 0 0 | 176k 140k
1 7 87 0 0 5| 0 0 |5095k 6253k| 0 0 | 178k 142k
2 7 87 0 0 5| 0 0 |5238k 6428k| 0 0 | 179k 144k
1 7 87 0 0 5| 0 24k|4611k 5660k| 0 0 | 166k 129k
1 7 87 0 0 5| 0 0 |5083k 6238k| 0 0 | 175k 142k
1 7 87 0 0 5| 0 0 |5277k 6477k| 0 0 | 179k 146k
1 7 87 0 0 5| 0 0 |5297k 6500k| 0 0 | 179k 146k
1 7 87 0 0 5| 0 0 |5383k 6607k| 0 0 | 180k 148k
1 7 87 0 0 5| 0 0 |5504k 6756k| 0 0 | 184k 152k
1 7 87 0 0 5| 0 48k|5584k 6854k| 0 0 | 183k 152k
1 7 87 0 0 5| 0 0 |5585k 6855k| 0 0 | 183k 153k
1 7 87 0 0 5| 0 0 |5589k 6859k| 0 0 | 184k 153k
1 5 91 0 0 3| 0 0 |4073k 4999k| 0 0 | 135k 110k
0 0 100 0 0 0| 0 32k| 60B 390B| 0 0 |4822 424</pre><p></p><p style=\"text-align: justify;\">客户端(一共20个，这里选取其中一个查看它的指标)。每个客户端保持6万个连接。每个消息从服务器发送到客户端接收到总用时平均633毫秒，而且标准差很小，每个连接用时差不多。</p><figure style=\"text-align: justify;\"></figure><p></p><pre class=\"crayon-plain-tag\">Active WebSockets for eb810c24-8565-43ea-bc27-9a0b2c910ca4
count = 60000
WebSocket Errors for eb810c24-8565-43ea-bc27-9a0b2c910ca4
count = 0
 
-- Histograms ------------------------------------------------------------------
Message latency for eb810c24-8565-43ea-bc27-9a0b2c910ca4
count = 693831
min = 627
max = 735
mean = 633.06
stddev = 9.61
median = 631.00
75% 633.00
95% 640.00
98% 651.00
99% 670.00
99.9% 735.00
 
-- Meters ----------------------------------------------------------------------
Message Rate for eb810c24-8565-43ea-bc27-9a0b2c910ca4
count = 693832
mean rate = 32991.37 events/minute
1-minute rate = 60309.26 events/minute
5-minute rate = 53523.45 events/minute
15-minute rate = 31926.26 events/minute</pre><p></p><p style=\"text-align: justify;\">平均每个client的RPS = 1000, 总的RPS大约为 20000 requests /seconds.<br />
latency平均值为633 ms，最长735 ms，最短627ms。</p><h4 id=\"Spray服务器\" style=\"text-align: justify;\">Spray服务器</h4><ul style=\"text-align: justify;\"><li>建立120万个连接，不发送消息，轻轻松松达到。它的内存相对较高，内存还剩7G。</li></ul><figure style=\"text-align: justify;\"></figure><ul style=\"text-align: justify;\"><li><pre class=\"crayon-plain-tag\"># ss -s; free -m
Total: 1200234 (kernel 1200251)
TCP: 1200006 (estab 1200002, closed 0, orphaned 0, synrecv 0, timewait 0/0), ports 4
 
Transport Total IP IPv6
* 1200251 - -
RAW 0 0 0
UDP 1 1 0
TCP 1200006 1200006 0
INET 1200007 1200007 0
FRAG 0 0 0
 
total used free shared buffers cached
Mem: 30074 22371 7703 0 10 259
-/+ buffers/cache: 22100 7973
Swap: 815 0 815</pre><br />
每分钟给所有的120万个websocket发送一条消息，消息内容为当前的服务器的时间。<br />
CPU使用较高，发送很快，带宽可以达到46M。群发完一次大约需要8秒左右。</li></ul><figure style=\"text-align: justify;\"></figure><figure style=\"text-align: justify;\"><pre class=\"crayon-plain-tag\">05/22 04:42:57.569 INFO [ool-2-worker-15] c.c.w.s.WebServer - send msg to workers 。for 8454e7d8-b8ca-4881-912b-6cdf3e6787bf
05/22 04:43:05.279 INFO [ool-2-worker-15] c.c.w.s.WebServer - sent msg to workers for 8454e7d8-b8ca-4881-912b-6cdf3e6787bf. current workers: 1200000</pre><br /><pre class=\"crayon-plain-tag\">----total-cpu-usage---- -dsk/total- -net/total- ---paging-- ---system--
usr sys idl wai hiq siq| read writ| recv send| in out | int csw
74 9 14 0 0 3| 0 24k|6330k 20M| 0 0 | 20k 1696
70 23 0 0 0 6| 0 64k| 11M 58M| 0 0 | 18k 2526
75 11 6 0 0 7| 0 0 |9362k 66M| 0 0 | 24k 11k
82 4 8 0 0 6| 0 0 | 11M 35M| 0 0 | 24k 10k
85 0 14 0 0 1| 0 0 |8334k 12M| 0 0 | 44k 415
84 0 15 0 0 1| 0 0 |9109k 16M| 0 0 | 36k 425
81 0 19 0 0 0| 0 24k| 919k 858k| 0 0 | 23k 629
76 0 23 0 0 0| 0 0 | 151k 185k| 0 0 | 18k 1075</pre><br /></figure><p style=\"text-align: justify;\">客户端(一共20个，这里选取其中一个查看它的指标)。每个客户端保持6万个连接。每个消息从服务器发送到客户端接收到总用时平均1412毫秒，而且标准差较大，每个连接用时差别较大。</p><figure style=\"text-align: justify;\"></figure><p></p><pre class=\"crayon-plain-tag\">Active WebSockets for 6674c9d8-24c6-4e77-9fc0-58afabe7436f
count = 60000
WebSocket Errors for 6674c9d8-24c6-4e77-9fc0-58afabe7436f
count = 0
 
-- Histograms ------------------------------------------------------------------
Message latency for 6674c9d8-24c6-4e77-9fc0-58afabe7436f
count = 454157
min = 716
max = 9297
mean = 1412.77
stddev = 1102.64
median = 991.00
75% 1449.00
95% 4136.00
98% 4951.00
99% 5308.00
99.9% 8854.00
 
-- Meters ----------------------------------------------------------------------
Message Rate for 6674c9d8-24c6-4e77-9fc0-58afabe7436f
count = 454244
mean rate = 18821.51 events/minute
1-minute rate = 67705.18 events/minute
5-minute rate = 49917.79 events/minute
15-minute rate = 24355.57 events/minute</pre><p></p><h4 id=\"Undertow\" style=\"text-align: justify;\">Undertow</h4><ul style=\"text-align: justify;\"><li>建立120万个连接，不发送消息，轻轻松松达到。内存占用较少，还剩余11G内存。<br /><pre class=\"crayon-plain-tag\"># ss -s; free -m
Total: 1200234 (kernel 1200240)
TCP: 1200006 (estab 1200002, closed 0, orphaned 0, synrecv 0, timewait 0/0), ports 4
 
Transport Total IP IPv6
* 1200240 - -
RAW 0 0 0
UDP 1 1 0
TCP 1200006 1200006 0
INET 1200007 1200007 0
FRAG 0 0 0
 
total used free shared buffers cached
Mem: 30074 18497 11576 0 10 286
-/+ buffers/cache: 18200 11873
Swap: 815 0 815</pre><br />
每分钟给所有的120万个websocket发送一条消息，消息内容为当前的服务器的时间。<br />
群发玩一次大约需要15秒。</li></ul><p></p><pre class=\"crayon-plain-tag\">03:19:31.154 [pool-1-thread-1] INFO c.colobu.webtest.undertow.WebServer$ - send msg to channels for d9b450da-2631-42bc-a802-44285f63a62d
03:19:46.755 [pool-1-thread-1] INFO c.colobu.webtest.undertow.WebServer$ - sent 1200000 channels for d9b450da-2631-42bc-a802-44285f63a62d</pre><p></p><p style=\"text-align: justify;\">客户端(一共20个，这里选取其中一个查看它的指标)。每个客户端保持6万个连接。每个消息从服务器发送到客户端接收到总用时平均672毫秒，而且标准差较小，每个连接用时差别不大。</p><p></p><pre class=\"crayon-plain-tag\">Active WebSockets for b2e95e8d-b17a-4cfa-94d5-e70832034d4d
count = 60000
WebSocket Errors for b2e95e8d-b17a-4cfa-94d5-e70832034d4d
count = 0
 
-- Histograms ------------------------------------------------------------------
Message latency for b2e95e8d-b17a-4cfa-94d5-e70832034d4d
count = 460800
min = 667
max = 781
mean = 672.12
stddev = 5.90
median = 671.00
75%
95%
98%
99%
99.9%
 
-- Meters ----------------------------------------------------------------------
Message Rate for b2e95e8d-b17a-4cfa-94d5-e70832034d4d
count = 460813
mean rate = 27065.85 events/minute
1-minute rate = 69271.67 events/minute
5-minute rate = 48641.78 events/minute
15-minute rate = 24128.67 events/minute
Setup Rate for b2e95e8d-b17a-4cfa-94d5-e70832034d4d</pre><p></p><h4 id=\"node-js\" style=\"text-align: justify;\">node.js</h4><p style=\"text-align: justify;\">node.js不是我要考虑的框架，列在这里只是作为参考。性能也不错。</p><p></p><pre class=\"crayon-plain-tag\">Active WebSockets for 537c7f0d-e58b-4996-b29e-098fe2682dcf
count = 60000
WebSocket Errors for 537c7f0d-e58b-4996-b29e-098fe2682dcf
count = 0
 
-- Histograms ------------------------------------------------------------------
Message latency for 537c7f0d-e58b-4996-b29e-098fe2682dcf
count = 180000
min = 808
max = 847
mean = 812.10
stddev = 1.95
median = 812.00
75% 812.00
95% 813.00
98% 814.00
99% 815.00
99.9% 847.00
 
-- Meters ----------------------------------------------------------------------
Message Rate for 537c7f0d-e58b-4996-b29e-098fe2682dcf
count = 180000
mean rate = 7191.98 events/minute
1-minute rate = 10372.33 events/minute
5-minute rate = 16425.78 events/minute
15-minute rate = 9080.53 events/minute</pre><p></p><h3 id=\"参考文档\" style=\"text-align: justify;\">参考文档</h3><ol><li style=\"text-align: justify;\"><a href=\"http://www.linuxde.net/2013/08/15150.html\" target=\"_blank\" rel=\"external\">HTTP长连接200万尝试及调优</a></li><li style=\"text-align: justify;\"><a href=\"http://blog.csdn.net/superchanon/article/details/13303705\" target=\"_blank\" rel=\"external\">Linux最大打开文件描述符数 </a></li><li style=\"text-align: justify;\"><a href=\"http://www.blogjava.net/yongboy/archive/2013/04/11/397677.html\" target=\"_blank\" rel=\"external\">100万并发连接服务器笔记之1M并发连接目标达成</a></li><li style=\"text-align: justify;\"><a href=\"http://www.zhihu.com/question/20831000\" target=\"_blank\" rel=\"external\">知乎：如何实现单服务器300万个长连接的？</a></li><li style=\"text-align: justify;\"><a href=\"http://www.ideawu.net/blog/archives/740.html\" target=\"_blank\" rel=\"external\">构建C1000K的服务器</a></li><li style=\"text-align: justify;\"><a href=\"http://www.csdn.net/article/2013-05-16/2815317-The-Secret-to-10M-Concurrent-Connections\" target=\"_blank\" rel=\"external\">千万级并发实现的秘密</a></li><li style=\"text-align: justify;\"><a href=\"http://blog.csdn.net/solstice/article/details/26363901\" target=\"_blank\" rel=\"external\">C1000k 新思路：用户态 TCP/IP 协议栈</a></li><li style=\"text-align: justify;\"><a href=\"https://github.com/xiaojiaqi/C1000kPracticeGuide\" target=\"_blank\" rel=\"external\">https://github.com/xiaojiaqi/C1000kPracticeGuide</a></li><li style=\"text-align: justify;\"><a href=\"http://www.jayway.com/2015/04/13/600k-concurrent-websocket-connections-on-aws-using-node-js/\" target=\"_blank\" rel=\"external\">600k concurrent websocket connections on AWS using Node.js</a></li><li style=\"text-align: justify;\"><a href=\"https://plumbr.eu/blog/memory-leaks/out-of-memory-kill-process-or-sacrifice-child?utm_source=feedly&amp;utm_reader=feedly&amp;utm_medium=rss&amp;utm_campaign=rss\" target=\"_blank\" rel=\"external\">https://plumbr.eu/blog/memory-leaks/out-of-memory-kill-process-or-sacrifice-child</a></li><li style=\"text-align: justify;\"><a href=\"http://it.deepinmind.com/java/2014/06/12/out-of-memory-kill-process-or-sacrifice-child.html\" target=\"_blank\" rel=\"external\">http://it.deepinmind.com/java/2014/06/12/out-of-memory-kill-process-or-sacrifice-child.html</a></li><li style=\"text-align: justify;\"><a href=\"https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Performance_Tuning_Guide/s-memory-captun.html\" target=\"_blank\" rel=\"external\">https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Performance_Tuning_Guide/s-memory-captun.html</a></li><li style=\"text-align: justify;\"><a href=\"http://www.nateware.com/linux-network-tuning-for-2013.html#.VV0s6kawqgQ\" target=\"_blank\" rel=\"external\">http://www.nateware.com/linux-network-tuning-for-2013.html#.VV0s6kawqgQ</a></li><li style=\"text-align: justify;\"><a href=\"http://warmjade.blogspot.jp/2014_03_22_archive.html\" target=\"_blank\" rel=\"external\">http://warmjade.blogspot.jp/2014_03_22_archive.html</a></li><li style=\"text-align: justify;\"><a href=\"http://mp.weixin.qq.com/s?__biz=MjM5NzAwNDI4Mg==&amp;mid=209282398&amp;idx=1&amp;sn=9ffef32b3ab93d1e239c9dc753a3a9bb\" target=\"_blank\" rel=\"external\">http://mp.weixin.qq.com/s?__biz=MjM5NzAwNDI4Mg==&amp;mid=209282398&amp;idx=1&amp;sn=9ffef32b3ab93d1e239c9dc753a3a9bb</a></li></ol><div class=\"wp_rp_wrap  wp_rp_plain\" ><div class=\"wp_rp_content\"><h3 class=\"related_post_title\">相关文章</h3><ul class=\"related_post wp_rp\" style=\"visibility: visible\"><li ><a href=\"http://blog.jobbole.com/98633/\" class=\"wp_rp_title\">StackOverflow 这么大，它的架构是怎么样的？</a></li><li ><a href=\"http://blog.jobbole.com/99159/\" class=\"wp_rp_title\">使用ansible批量管理远程服务器</a></li><li ><a href=\"http://blog.jobbole.com/740/\" class=\"wp_rp_title\">深入Facebook消息应用服务器</a></li><li ><a href=\"http://blog.jobbole.com/96958/\" class=\"wp_rp_title\">浅谈服务器单I/O线程＋工作者线程池模型架构及实现要点</a></li><li ><a href=\"http://blog.jobbole.com/103116/\" class=\"wp_rp_title\">游戏服务端究竟解决了什么问题？</a></li><li ><a href=\"http://blog.jobbole.com/1435/\" class=\"wp_rp_title\">Tagged社交网站扩展到上千个服务器过程中的5个快照</a></li><li ><a href=\"http://blog.jobbole.com/91749/\" class=\"wp_rp_title\">高并发Web服务的演变：节约系统内存和CPU</a></li><li ><a href=\"http://blog.jobbole.com/91754/\" class=\"wp_rp_title\">Web系统大规模并发：电商秒杀与抢购  </a></li><li ><a href=\"http://blog.jobbole.com/34212/\" class=\"wp_rp_title\">可伸缩系统的架构经验</a></li><li ><a href=\"http://blog.jobbole.com/58714/\" class=\"wp_rp_title\">Linux服务器性能评估</a></li></ul></div></div><p><a href=\"http://blog.jobbole.com/103995/\">四种框架分别实现百万websocket常连接的服务器</a>，首发于<a href=\"http://blog.jobbole.com\">文章 - 伯乐在线</a>。</p>") (wfw:commentRss nil "http://blog.jobbole.com/103995/feed/") (slash:comments nil "0")) (item nil (title nil "Getty：Java NIO 框架设计与实现") (link nil "http://blog.jobbole.com/103978/") (comments nil "http://blog.jobbole.com/103978/#comments") (pubDate nil "Sun, 31 Jul 2016 03:26:47 +0000") (dc:creator nil "肖汉松") (category nil "开发") (category nil "java") (category nil "NIO") (guid ((isPermaLink . "false")) "http://blog.jobbole.com/?p=103978") (description nil "<p>Getty是我为了学习 Java NIO 所写的一个 NIO 框架，实现过程中参考了 Netty 的设计，同时使用 Groovy 来实现。虽然只是玩具，但是麻雀虽小，五脏俱全，在实现过程中，不仅熟悉了 NIO 的使用，还借鉴了很多 Netty 的设计思想，提升了自己的编码和设计能力。</p><p><a href=\"http://blog.jobbole.com/103978/\">Getty：Java NIO 框架设计与实现</a>，首发于<a href=\"http://blog.jobbole.com\">文章 - 伯乐在线</a>。</p>") (content:encoded nil "<div><h2 id=\"u524D_u8A00\">前言</h2><p><a href=\"https://github.com/x-hansong/Getty\" target=\"_blank\" rel=\"external\">Getty</a> 是我为了学习 Java NIO 所写的一个 NIO 框架，实现过程中参考了 Netty 的设计，同时使用 Groovy 来实现。虽然只是玩具，但是麻雀虽小，五脏俱全，在实现过程中，不仅熟悉了 NIO 的使用，还借鉴了很多 Netty 的设计思想，提升了自己的编码和设计能力。</p><p>至于为什么用 Groovy 来写，因为我刚学了 Groovy，正好拿来练手，加上 Groovy 是兼容 Java 的，所以只是语法上的差别，底层实现还是基于 Java API的。</p><p>Getty 的核心代码行数不超过 500 行，一方面得益于 Groovy 简洁的语法，另一方面是因为我只实现了核心的逻辑，最复杂的其实是解码器实现。脚手架容易搭，摩天大楼哪有那么容易盖，但用来学习 NIO 足以。</p><h2 id=\"u7EBF_u7A0B_u6A21_u578B\">线程模型</h2><p>Getty 使用的是 Reactor 多线程模型<br /><img src=\"http://7xjtfr.com1.z0.glb.clouddn.com/getty-1.png\" alt=\"reactor\" /></p><ol><li>有专门一个 NIO 线程- Acceptor 线程用于监听服务端，接收客户端的 TCP 连接请求，然后将连接分配给工作线程，由工作线程来监听读写事件。</li><li>网络 IO 操作-读/写等由多个工作线程负责，由这些工作线程负责消息的读取、解码、编码和发送。</li><li>1 个工作线程可以同时处理N条链路，但是 1 个链路只对应 1 个工作线程，防止发生并发操作问题。</li></ol><h2 id=\"u4E8B_u4EF6_u9A71_u52A8_u6A21_u578B\">事件驱动模型</h2><p>整个服务端的流程处理，建立于事件机制上。在 [接受连接－＞读－＞业务处理－＞写 －＞关闭连接 ]这个过程中，触发器将触发相应事件，由事件处理器对相应事件分别响应，完成服务器端的业务处理。</p><h3 id=\"u4E8B_u4EF6_u5B9A_u4E49\">事件定义</h3><ol><li><code>onRead</code>：当客户端发来数据，并已被工作线程正确读取时，触发该事件 。该事件通知各事件处理器可以对客户端发来的数据进行实际处理了。</li><li><code>onWrite</code>：当客户端可以开始接受服务端发送数据时触发该事件，通过该事件，我们可以向客户端发送响应数据。（当前的实现中并未使用写事件）</li><li><code>onClosed</code>：当客户端与服务器断开连接时触发该事件。</li></ol><h3 id=\"u4E8B_u4EF6_u56DE_u8C03_u673A_u5236_u7684_u5B9E_u73B0\">事件回调机制的实现</h3><p>在这个模型中，事件采用广播方式，也就是所有注册的事件处理器都能获得事件通知。这样可以将不同性质的业务处理，分别用不同的处理器实现，使每个处理器的功能尽可能单一。</p><p>如下图：整个事件模型由监听器、事件适配器、事件触发器（HandlerChain，PipeLine）、事件处理器组成。<br /><img src=\"http://7xjtfr.com1.z0.glb.clouddn.com/getty-2.png\" alt=\"event\" /></p><ul><li><code>ServerListener</code>：这是一个事件接口，定义需监听的服务器事件<br /><pre class=\"crayon-plain-tag\">interface ServerListener extends Serializable{
    /**
     * 可读事件回调
     * @param request
     */
    void onRead(ctx)
    /**
     * 可写事件回调
     * @param request
     * @param response
     */
    void onWrite(ctx)
    /**
     * 连接关闭回调
     * @param request
     */
    void onClosed(ctx)
}</pre></li><li><code>EventAdapter</code>：对 Serverlistener 接口实现一个适配器 (EventAdapter)，这样的好处是最终的事件处理器可以只处理所关心的事件。<br /><pre class=\"crayon-plain-tag\">class EventAdapter implements ServerListener {
    //下个处理器的引用
    protected next
    void onRead(Object ctx) {
    }
    void onWrite(Object ctx) {
    }
    void onClosed(Object ctx) {
    }
}</pre></li><li><code>Notifier</code>：用于在适当的时候通过触发服务器事件，通知在册的事件处理器对事件做出响应。<br /><pre class=\"crayon-plain-tag\">interface Notifier extends Serializable{
    /**
     * 触发所有可读事件回调
     */
    void fireOnRead(ctx)
    /**
     * 触发所有可写事件回调
     */
    void fireOnWrite(ctx)
    /**
     * 触发所有连接关闭事件回调
     */
    void fireOnClosed(ctx)
}</pre></li><li><code>HandlerChain</code>：实现了<code>Notifier</code>接口，维持有序的事件处理器链条，每次从第一个处理器开始触发。<br /><pre class=\"crayon-plain-tag\">class HandlerChain implements Notifier{
    EventAdapter head
    EventAdapter tail
    /**
     * 添加处理器到执行链的最后
     * @param handler
     */
    void addLast(handler) {
        if (tail != null) {
            tail.next = handler
            tail = tail.next
        } else {
            head = handler
            tail = head
        }
    }
    void fireOnRead(ctx) {
        head.onRead(ctx)
    }
    void fireOnWrite(ctx) {
        head.onWrite(ctx)
    }
    void fireOnClosed(ctx) {
        head.onClosed(ctx)
    }
}</pre></li><li><code>PipeLine</code>：实现了<code>Notifier</code>接口，作为事件总线，维持一个事件链的列表。<br /><pre class=\"crayon-plain-tag\">class PipeLine implements Notifier{
    static logger = LoggerFactory.getLogger(PipeLine.name)
    //监听器队列
    def listOfChain = []
    PipeLine(){}
    /**
     * 添加监听器到监听队列中
     * @param chain
     */
    void addChain(chain) {
        synchronized (listOfChain) {
            if (!listOfChain.contains(chain)) {
                listOfChain.add(chain)
            }
        }
    }
    /**
     * 触发所有可读事件回调
     */
    void fireOnRead(ctx) {
        logger.debug(\"fireOnRead\")
        listOfChain.each { chain -&gt;
            chain.fireOnRead(ctx)
        }
    }
    /**
     * 触发所有可写事件回调
     */
    void fireOnWrite(ctx) {
        listOfChain.each { chain -&gt;
            chain.fireOnWrite(ctx)
        }
    }
    /**
     * 触发所有连接关闭事件回调
     */
    void fireOnClosed(ctx) {
        listOfChain.each { chain -&gt;
            chain.fireOnClosed(ctx)
        }
    }
}</pre></li></ul><h3 id=\"u4E8B_u4EF6_u5904_u7406_u6D41_u7A0B\">事件处理流程</h3><p><img src=\"http://7xjtfr.com1.z0.glb.clouddn.com/getty-3.png\" alt=\"编程模型\" /><br />
事件处理采用职责链模式，每个处理器处理完数据之后会决定是否继续执行下一个处理器。如果处理器不将任务交给线程池处理，那么整个处理流程都在同一个线程中处理。而且每个连接都有单独的<code>PipeLine</code>，工作线程可以在多个连接上下文切换，但是一个连接上下文只会被一个线程处理。</p><h2 id=\"u6838_u5FC3_u7C7B\">核心类</h2><h3 id=\"ConnectionCtx\">ConnectionCtx</h3><p>连接上下文<code>ConnectionCtx</code></p><pre class=\"crayon-plain-tag\">class ConnectionCtx {
    /**socket连接*/
    SocketChannel channel
    /**用于携带额外参数*/
    Object attachment
    /**处理当前连接的工作线程*/
    Worker worker
    /**连接超时时间*/
    Long timeout
    /**每个连接拥有自己的pipeline*/
    PipeLine pipeLine
}</pre><p></p><h3 id=\"NioServer\">NioServer</h3><p>主线程负责监听端口，持有工作线程的引用（使用轮转法分配连接），每次有连接到来时，将连接放入工作线程的连接队列，并唤醒线程<code>selector.wakeup()</code>（线程可能阻塞在<code>selector</code>上）。</p><pre class=\"crayon-plain-tag\">class NioServer extends Thread {
    /**服务端的套接字通道*/
    ServerSocketChannel ssc
    /**选择器*/
    Selector selector
    /**事件总线*/
    PipeLine pipeLine
    /**工作线程列表*/
    def workers = []
    /**当前工作线程索引*/
    int index
}</pre><p></p><h3 id=\"Worker\">Worker</h3><p>工作线程，负责注册server传递过来的socket连接。主要监听读事件，管理socket，处理写操作。</p><pre class=\"crayon-plain-tag\">class Worker extends Thread {
    /**选择器*/
    Selector selector
    /**读缓冲区*/
    ByteBuffer buffer
    /**主线程分配的连接队列*/
    def queue = []
    /**存储按超时时间从小到大的连接*/
    TreeMap ctxTreeMap

    void run() {
        while (true) {
            selector.select()
            //注册主线程发送过来的连接
            registerCtx()
            //关闭超时的连接
            closeTimeoutCtx()
            //处理事件
            dispatchEvent()
        }
    }
}</pre><p></p><h2 id=\"u8FD0_u884C_u4E00_u4E2A_u7B80_u5355_u7684_Web__u670D_u52A1_u5668\">运行一个简单的 Web 服务器</h2><p>我实现了一系列处理<code>HTTP</code>请求的处理器，具体实现看代码。</p><ul><li><code>LineBasedDecoder</code>：行解码器，按行解析数据</li><li><code>HttpRequestDecoder</code>：HTTP请求解析，目前只支持GET请求</li><li><code>HttpRequestHandler</code>：Http 请求处理器，目前只支持GET方法</li><li><code>HttpResponseHandler</code>：Http响应处理器</li></ul><p>下面是写在<code>test</code>中的例子</p><pre class=\"crayon-plain-tag\">class WebServerTest {
    static void main(args) {
        def pipeLine = new PipeLine()

        def readChain = new HandlerChain()
        readChain.addLast(new LineBasedDecoder())
        readChain.addLast(new HttpRequestDecoder())
        readChain.addLast(new HttpRequestHandler())
        readChain.addLast(new HttpResponseHandler())

        def closeChain = new HandlerChain()
        closeChain.addLast(new ClosedHandler())

        pipeLine.addChain(readChain)
        pipeLine.addChain(closeChain)

        NioServer nioServer = new NioServer(pipeLine)
        nioServer.start()
    }
}</pre><p>另外，还可以使用配置文件<code>getty.properties</code>设置程序的运行参数。</p><pre class=\"crayon-plain-tag\">#用于拼接消息时使用的二进制数组的缓存区
common_buffer_size=1024
#工作线程读取tcp数据的缓存大小
worker_rcv_buffer_size=1024
#监听的端口
port=4399
#工作线程的数量
worker_num=1
#连接超时自动断开时间
timeout=900
#根目录
root=.</pre><p></p><h2 id=\"u603B_u7ED3\">总结</h2><p><a href=\"https://github.com/x-hansong/Getty\" target=\"_blank\" rel=\"external\">Getty</a>是我造的第二个小轮子，第一个是<a href=\"https://github.com/x-hansong/RedisHttpSession\" target=\"_blank\" rel=\"external\">RedisHttpSession</a>。都说不要重复造轮子。这话我是认同的，但是掌握一门技术最好的方法就是实践，在没有合适项目可以使用新技术的时候，造一个简单的轮子是不错的实践手段。</p><p><a href=\"https://github.com/x-hansong/Getty\" target=\"_blank\" rel=\"external\">Getty</a> 的缺点或者说还可以优化的点：</p><ol><li>线程的使用直接用了<code>Thread</code>类，看起来有点low。等以后水平提升了再来抽象一下。</li><li>目前只有读事件是异步的，写事件是同步的。未来将写事件也改为异步的。</li></ol></div><div class=\"wp_rp_wrap  wp_rp_plain\" ><div class=\"wp_rp_content\"><h3 class=\"related_post_title\">相关文章</h3><ul class=\"related_post wp_rp\" style=\"visibility: visible\"><li ><a href=\"http://blog.jobbole.com/79421/\" class=\"wp_rp_title\">Eric Raymond对于几大开发语言的评价</a></li><li ><a href=\"http://blog.jobbole.com/88984/\" class=\"wp_rp_title\">一个故事讲清楚 NIO</a></li><li ><a href=\"http://blog.jobbole.com/103980/\" class=\"wp_rp_title\">RedisHttpSession 的设计与实现</a></li><li ><a href=\"http://blog.jobbole.com/101171/\" class=\"wp_rp_title\">JVM 字节码执行实例分析</a></li><li ><a href=\"http://blog.jobbole.com/101710/\" class=\"wp_rp_title\">高效 Windows 工作环境 &amp;&amp; Java 开发环境搭建</a></li><li ><a href=\"http://blog.jobbole.com/93647/\" class=\"wp_rp_title\">Java 中泛型的全面解析</a></li><li ><a href=\"http://blog.jobbole.com/103979/\" class=\"wp_rp_title\">Java 线程池框架核心代码分析</a></li><li ><a href=\"http://blog.jobbole.com/31940/\" class=\"wp_rp_title\">Java 安全模型介绍</a></li><li ><a href=\"http://blog.jobbole.com/25074/\" class=\"wp_rp_title\">JTA 深度历险 &#8211; 原理与实现</a></li><li ><a href=\"http://blog.jobbole.com/23939/\" class=\"wp_rp_title\">Java对象初始化详解</a></li></ul></div></div><p><a href=\"http://blog.jobbole.com/103978/\">Getty：Java NIO 框架设计与实现</a>，首发于<a href=\"http://blog.jobbole.com\">文章 - 伯乐在线</a>。</p>") (wfw:commentRss nil "http://blog.jobbole.com/103978/feed/") (slash:comments nil "2")) (item nil (title nil "那些被岁月遗忘的 UNIX 经典著作") (link nil "http://blog.jobbole.com/103989/") (comments nil "http://blog.jobbole.com/103989/#respond") (pubDate nil "Sat, 30 Jul 2016 14:24:24 +0000") (dc:creator nil "伯小乐") (category nil "书籍与教程") (category nil "Linux") (category nil "书籍") (guid ((isPermaLink . "false")) "http://blog.jobbole.com/?p=103989") (description nil "<p>那些几乎被这个时代所遗忘的 UNIX 时代的经典著作</p><p><a href=\"http://blog.jobbole.com/103989/\">那些被岁月遗忘的 UNIX 经典著作</a>，首发于<a href=\"http://blog.jobbole.com\">文章 - 伯乐在线</a>。</p>") (content:encoded nil "<h3>1. 《<a href=\"https://www.amazon.cn/gp/product/B0011425T8/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B0011425T8&amp;linkCode=as2&amp;tag=vastwork-23\" target=\"_blank\">C程序设计语言</a>》</h3><p><img src=\"http://jbcdn2.b0.upaiyun.com/2016/07/bbbc6ec935b75358adde7189cc59338f.jpg\" /></p><p><strong>内容简介：</strong></p><p>在计算机发展的历史上，没有哪一种程序设计语言像C语言这样应用广泛。本书是C语言的设计者之一Dennis M.Ritchie和著名计算机科学家Brian W.Kernighan合著的一本介绍C语言的权威经典著作。我们现在见到的大量论述C语言程序设计的教材和专著均以此书为蓝本。本书第1版中介绍的C语言成为后来广泛使用的C语言版本——标准C的基础。人们熟知的“hello,World&#8221; 程序就是由本书首次引入的。现在，这一程序已经成为众多程序设计语言入门的第一课。</p><p><strong>作者简介</strong></p><p><strong>Brian W. Kernighan </strong>是贝尔实验室计算科学研究中心高级研究人员，著名的计算机科学家。他参加了UNIX系统、C语言、AWK语言和许多其他系统的开发，同时出版了许多在计算机领域具有影响的著作，包括《Software Tools》、《The  Elements of Programming Style》、<strong>《</strong>The Unix Programming Environment<strong>》</strong>、《The C Programming Language》、《The AWK Language》、《The Practice of Programming》等。</p><p><strong>Rob Pike</strong>，目前谷歌公司最著名的软件工程师之一，曾是贝尔实验室Unix开发团队成员，Plan9操作系统开发的主要领导人，Inferno操作系统开发的主要领导人。他是缔造Go语言和Limbo语言的核心人物。中国Linux联盟 &#8211; www.lisdn.com &#8211; 中国Linux软件开发基地，中国Linux爱好者的精神家园。</p><p><strong>网友评论：</strong></p><ul><li>这是一本不到200页的小书，传递着一种简单、优雅、平实和闲适。</li><li>把谭老师的书丢到废纸篓里是唯一正确的选择。科尼汉的书简洁明晰到了极致。我买了能买到的科尼汉所有的书， 从《unix编程环境》到《程序设计实践》，没有一本让我失望。伟大的作者，简洁风格的代表，永远的K&amp;R.</li><li>读下来毫不费力，全程都是享受。语言简练，词句清晰。 例子超级经典！总会有看到作者的代码然后觉得太巧妙了、太厉害了、太老道了！这种大师杰作，每个代码细节都让人感慨。一定要动手练习。老生常谈，看和写完全是两码事，但看这本书的代码，有种迫不及待想练习一下的期待，就好像看到一本武林秘籍，光读还不够过瘾，迫切地想找个安静的地方揣摩练习一番。</li></ul><h3>2. 《<a href=\"https://www.amazon.cn/gp/product/B00IYTQBYS/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B00IYTQBYS&amp;linkCode=as2&amp;tag=vastwork-23\" target=\"_blank\">UNIX编程环境</a>》</h3><p><img src=\"http://jbcdn2.b0.upaiyun.com/2016/07/113fee49985f04b9aa5b33a3b44a9aff.jpg\" /></p><p><strong>内容简介：</strong></p><p>《UNIX编程环境》是UINX编程领域的经典畅销书。作者本着“授之以渔”的态度，不仅介绍了UNIX系统编程的基本技巧及编程规范，更是将UNIX的编程哲学融入其中，以帮助你更加深刻地理解UNIX系统。</p><p>《UNIX编程环境》是Brian W.Kernighan和Rob Pike两位UNIX大师的合力之作，浸透了UNIX的设计思想，启发你体会编程方法、思想以及环境的奥秘。</p><p><strong>网友评论：</strong></p><ul><li>很实在的unix介绍。 书中绝无生僻的角落，对于入门来说没有什么难以理解的。但是字里行间浸透了作者设计unix的指导思想，这一点是别的入门书无法企及的。 书中提及的点滴都是实用的方法和准则，而这些充斥着在unix上一整天的工作，即使是有经验的用户学过此书后工作效率也会提升。</li><li>阅读完此书，让我见识到什么叫做简单之美。“保持简单”，这种思想在UNIX中得到了最完善的体现。据说，unix的内核最基本的方法只有6个。下一站：Unix编程艺术！</li><li>是一本经典的编程读物，有很多有启发性的例子。 这本书更注重“编程思想”的建立，仔细阅读会对UNIX的理解大有帮助。</li><li>虽然在unix上工作多年了，但是重读这本书仍然能体会到作者在文字间表达出的那种unix的正统思想。书不厚，值得多读几遍。</li><li>这是两位UNIX大师合著的关于UNIX编程方法，思想以及环境的书。是入门UNIX/Linux最好的教材。这本书不但可以带您走入UNIX世界，也向您阐述了UNIX的简约派哲学。每次在书架上看到它，总有再读以便的冲动。</li><li>想深入学习UNIX环境编程，但又觉得《UNIX环境高级编程》太厚不容易看完，而且读起来有点吃力。那么《UNIX编程环境》可以助你一臂之力，让你在UNIX的世界里走的更好。</li></ul><h3>3. 《<a href=\"https://www.amazon.cn/gp/product/B002WC7NGS/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B002WC7NGS&amp;linkCode=as2&amp;tag=vastwork-23\" target=\"_blank\">数据结构与算法分析</a>》</h3><p><img src=\"http://jbcdn2.b0.upaiyun.com/2016/07/b471aeda52dcc59aefdfb6ec370d8289.jpg\" /></p><p><strong>内容简介：</strong></p><p>本书曾被评为20世纪顶尖的30部计算机著作之一,作者Mark Allen Weiss在数据结构和算法分析方面卓有建树.他的数据结构和算法分析的著作尤其畅销,并受到广泛好评.已被世界500余所大学用作教材.</p><p><strong>网友评论：</strong></p><ul><li>这本书买了很多年,搬了这么多次工位,一直在办公室常备的书(虽然已经很少翻看). 里面使用的代码,不是所谓的伪代码,而是正经可以运行的C代码,所以新人如果能照着做一遍下来,收获应该不小.</li><li>这种程度的书确实很少能见到了。 它不在简单的地方无谓的浪费笔墨，恰到好处的把初学者带入算法和数据结构的世界。 它基本上涉及了数据结构基础的“方方面面”。很难想象这书的厚度，居然能讲这么多内容（你看看算法导论有多厚就知道我在说什么了）。 它在内容上并不乏深度。</li><li>这本书真是非常好！个人感觉很适合给初学者入门看，里面的分析数学公式恰到好处，没有算法导论的令人望而生畏，也没有国内图书的草草了事，既学习了数据结构又有刚刚好的算法分析，很容易使人产生共鸣。</li></ul><h3>4. 《<a href=\"https://www.amazon.cn/gp/product/B0198OPL16/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B0198OPL16&amp;linkCode=as2&amp;tag=vastwork-23\" target=\"_blank\">程序设计实践</a>》</h3><p><img src=\"http://jbcdn2.b0.upaiyun.com/2016/07/84e020766863d749686baff5522002cd.jpg\" /></p><p><strong>内容简介：</strong></p><p>Brian W.Kernig和Rob Pike奉献出他们的新作《程序设计实践》。可使程序员工作更有效，产出更丰厚。在这里可以看到和已成为经典之作的《Unix编程环境》同样的洞察力和权威性。</p><p>本书从排错、测试、性能、可移植性、设计、界面、风格和记法等方面，讨论了程序设计中实际的、又是非常深刻和具有广泛意义的思想、技术和方法。</p><p><strong>网友评论：</strong></p><ul><li>我看过很多类似#程序员必读XX本书#的书单，似乎在几乎所有的推荐书单里面，《程序设计实践》（英文名The Practice of Programming）都没有出现作为一本被推荐的书。</li><li>在技术博客，出版书籍充斥着各种云计算、大数据等时髦名词的今天，这本书从名字上就不是太引人注目，作为作者之一的Brian W. Kernighan这个名字似乎也很陌生，不过他还有一本书，就是被奉为C圣经的《The C Programming Language》，相信你一定听过。而另一位作者Rob Pike，可能更加陌生，不过他设计了一门最近非常红火的语言：Go。</li><li>这是一本牢牢占据经典书架最起眼位置的小册子，也是最符合KISS之道的神作之一。 抛开已有的业界的best practices，这本书还修正了我记忆中的很多错误认识，Brian Kernighan、Rob Pike的大名自然是本书最好的招牌；但作者的求实态度更值得每一个认真的programmer学习。</li><li>同样是出自大师之手，同样都是珠玑，这本书的名气实在太小。这就像做生意一样，生意好的店会越来越好，生意差的店只会越来越冷清。 但是，没有看过这本书，是自己的损失。 这本书有三强：1，实践性强；2，实践性强；3，实践性强。</li></ul><h3>5. 《<a href=\"https://www.amazon.cn/gp/product/B00KMR129E/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B00KMR129E&amp;linkCode=as2&amp;tag=vastwork-23\" target=\"_blank\">UNIX环境高级编程</a>》</h3><p><img src=\"http://jbcdn2.b0.upaiyun.com/2016/07/254c9c04e2d87b2a5fa3ad6ce84c16c7.jpg\" /></p><p><strong>内容简介：</strong></p><p>本书详细说明、讨论UNIX程序设计界面的应用技术，包括：系统调用界面及标准C函数库。全书具有鲜明的特点：在同类书籍中内容最为丰富、实用；提供了大量应用实例，其中大部分可直接引入到相关程序设计中；界面应用和UNIX内部结构紧密结合。</p><p>本书问世于1992年，作者是UNIX和网络技术领域的国际知名专家W. Richard Stevens。该书出版以来受到读者的普遍欢迎和好评，认为它是“在UNIX环境下进行程序设计的有关人员必读且经常需要查阅的首选参考书”。UNIX的原创者Dennis Ritchie则称其是“公认的优秀、匠心独具的名著”。</p><p><strong>网友评论：</strong></p><ul><li>Rich Stevens显然不是Dennis Richie, Brian Kernighan那个贝尔实验室圈子的人。他对Unix的深入了解，是自己翻烂手册、钻研系统得到的。这个切入点，和我们多数用户是一样的。所以，我们想知道的东西，也许正是Stevens关心过的。</li></ul><h3>6. 《UNIX操作系统设计》</h3><p><img src=\"http://jbcdn2.b0.upaiyun.com/2016/07/15c218de2386de5d4201a3c5b2708501.jpg\" /></p><p><strong>内容简介：</strong></p><p>本书是Linux之父Linux Torvalds曾捧读的经典著作。在本书中，作者描述了构成UNIX操作系统基础的内部算法与结构，以及它们与程序接口之间的联系。本书虽然以UNIX系统V为背景，但是介绍的算法、数据结构却并没有专门针对任何一种特定的内核，所以直到今日，本书仍然是世界上许多大学操作系统课程的必读或推荐教材。读者如果想学习UNIX，本书依然是最好的选择之一。</p><p><strong>网友评论：</strong></p><ul><li>这本书很老，但是不可错过——至少现在2013年还没有过时。它向读者展示了UNIX最开始的设计和实现，今天的各种*nix，包括但不限于各种BSD，Solaris以及Linux的结构都源自这里。另外，对于学习OS设计的同学来说，了解UNIX这样一个流行了几十年的OS的最初设计，或许能够得到一些启发。</li></ul><h3>7. 《<a href=\"https://www.amazon.cn/gp/product/B008Z1IEQ8/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B008Z1IEQ8&amp;linkCode=as2&amp;tag=vastwork-23\" target=\"_blank\">UNIX编程艺术</a>》</h3><p><img src=\"http://jbcdn2.b0.upaiyun.com/2016/07/3dc81294dee3960c969b40f92f7cb5c4.jpg\" /></p><p><strong>内容简介：</strong></p><p>本书主要介绍了Unix系统领域中的设计和开发哲学、思想文化体系、原则与经验，由公认的Unix编程大师、开源运动领袖人物之一Eric S. Raymond倾力多年写作而成。包括Unix设计者在内的多位领域专家也为本书贡献了宝贵的内容。本书内容涉及社群文化、软件开发设计与实现，覆盖面广、内容深邃，完全展现了作者极其深厚的经验积累和领域智慧。</p><p><strong>网友评论：</strong></p><ul><li>贯穿始终的 KISS 原则，很多年前就被谆谆教导过了。它被我无时无刻的都拿出来警告自己的设计过程。读完这本书，让我对 KISS 又有了一次升华。其实，这本书对我几个月来设计游戏服务器架构的影响是满大的。坚定了我每写一个程序做好一件事的决心。</li><li>相信对绝大多数 Unix 程序员而言, 书中所阐述的基本都是每天稀疏平常、实践到烂的东西。我翻来覆去读这本书的原因就是用它来照耀充满着这个宇宙空间的伟大的 Win32 社区, 品味着他们的愚蠢。对一名 Unix 程序员来讲, 这是一种黑色幽默式的消遣。同时一泄每天 Win32 喇叭给人造成的烦躁和不安的感觉。这种发泄, 让我更深深地爱上了这本书。</li><li>对于我来说，判断一本“经典”好书的标准，除了阅读当时的“震撼”之外， 还有是不是会不时回去再翻阅，是不是会不时想起书中的一些论述。这本书就完全契合我对“经典”好书的标准。</li></ul><h3>8. 《莱昂氏UNIX源代码分析》</h3><p><img src=\"http://jbcdn2.b0.upaiyun.com/2016/07/da49a2ab167934f7cdb81cb8deed4cab.png\" width=\"192\" height=\"258\" /></p><p><strong>内容简介：</strong></p><p>在20世纪70年代和80年代这一时期,莱昂的几册《源代码分析》,曾是人们争相传看的UNIX系统的&#8221;地下出版物&#8221;.我们今天来审视这一著作,尽管其中的代码已属过时,但其注释者所作的大部分注释,依然完美如初.要想学习操作系统原理,就必须阅读和理解源代码.莱昂的工作,使我们中间的大多数人都能达到这一步.</p><p><strong>网友评论：</strong></p><ul><li>非常好, 这个版本的代码非常短, 可以很快提高你对操作系统的理解, 和对c语言程序的阅读能力</li><li>学操作系统的必读书, 虽然PDP-11早已淘汰, 其中的许多东西仍然是现代unix的基础.</li><li>计算机书籍大多因为时效性短暂而不值得收藏，但这本例外。</li></ul><div class=\"wp_rp_wrap  wp_rp_plain\" ><div class=\"wp_rp_content\"><h3 class=\"related_post_title\">相关文章</h3><ul class=\"related_post wp_rp\" style=\"visibility: visible\"><li ><a href=\"http://blog.jobbole.com/15342/\" class=\"wp_rp_title\">JVM程序员的阅读清单</a></li><li ><a href=\"http://blog.jobbole.com/45387/\" class=\"wp_rp_title\">为学Linux，我看了这些书 </a></li><li ><a href=\"http://blog.jobbole.com/8139/\" class=\"wp_rp_title\">10本Linux免费电子书</a></li><li ><a href=\"http://blog.jobbole.com/1024/\" class=\"wp_rp_title\">Web开发人员应有的15本免费电子书</a></li><li ><a href=\"http://blog.jobbole.com/59424/\" class=\"wp_rp_title\">11本免费的编程电子书（英文）</a></li><li ><a href=\"http://blog.jobbole.com/41769/\" class=\"wp_rp_title\">张逸： ThoughtWorks(中国)程序员读书雷达</a></li><li ><a href=\"http://blog.jobbole.com/765/\" class=\"wp_rp_title\">9本免费的Python编程书</a></li><li ><a href=\"http://blog.jobbole.com/68621/\" class=\"wp_rp_title\">Android 应用开发推荐书单</a></li><li ><a href=\"http://blog.jobbole.com/73781/\" class=\"wp_rp_title\">电子书：初等算法</a></li><li ><a href=\"http://blog.jobbole.com/104042/\" class=\"wp_rp_title\">如何在 Linux 下检测内存泄漏</a></li></ul></div></div><p><a href=\"http://blog.jobbole.com/103989/\">那些被岁月遗忘的 UNIX 经典著作</a>，首发于<a href=\"http://blog.jobbole.com\">文章 - 伯乐在线</a>。</p>") (wfw:commentRss nil "http://blog.jobbole.com/103989/feed/") (slash:comments nil "0")) (item nil (title nil "Java 线程池框架核心代码分析") (link nil "http://blog.jobbole.com/103979/") (comments nil "http://blog.jobbole.com/103979/#respond") (pubDate nil "Sat, 30 Jul 2016 08:26:39 +0000") (dc:creator nil "肖汉松") (category nil "开发") (category nil "java") (category nil "线程池") (guid ((isPermaLink . "false")) "http://blog.jobbole.com/?p=103979") (description nil "<p>多线程编程中，为每个任务分配一个线程是不现实的，线程创建的开销和资源消耗都是很高的。线程池应运而生，成为我们管理线程的利器。Java 通过Executor接口，提供了一种标准的方法将任务的提交过程和执行过程解耦开来，并用Runnable表示任务。本文来分析一下 Java 线程池框架的实现ThreadPoolExecutor。</p><p><a href=\"http://blog.jobbole.com/103979/\">Java 线程池框架核心代码分析</a>，首发于<a href=\"http://blog.jobbole.com\">文章 - 伯乐在线</a>。</p>") (content:encoded nil "<div><h2 id=\"u524D_u8A00\">前言</h2><p>多线程编程中，为每个任务分配一个线程是不现实的，线程创建的开销和资源消耗都是很高的。线程池应运而生，成为我们管理线程的利器。Java 通过<code>Executor</code>接口，提供了一种标准的方法将任务的提交过程和执行过程解耦开来，并用<code>Runnable</code>表示任务。</p><p>下面，我们来分析一下 Java 线程池框架的实现<code>ThreadPoolExecutor</code>。</p><p><em>下面的分析基于JDK1.7</em></p><h2 id=\"u751F_u547D_u5468_u671F\">生命周期</h2><p><code>ThreadPoolExecutor</code>中，使用<code>CAPACITY</code>的高3位来表示运行状态，分别是：</p><ol><li>RUNNING：接收新任务，并且处理任务队列中的任务</li><li>SHUTDOWN：不接收新任务，但是处理任务队列的任务</li><li>STOP：不接收新任务，不出来任务队列，同时中断所有进行中的任务</li><li>TIDYING：所有任务已经被终止，工作线程数量为 0，到达该状态会执行<code>terminated()</code></li><li>TERMINATED：<code>terminated()</code>执行完毕</li></ol><p><img src=\"http://7xjtfr.com1.z0.glb.clouddn.com/executor_lifecycle.png\" alt=\"状态转换图\" /><br /><code>ThreadPoolExecutor</code>中用原子类来表示状态位</p><pre class=\"crayon-plain-tag\">private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));</pre><p></p><h2 id=\"u7EBF_u7A0B_u6C60_u6A21_u578B\">线程池模型</h2><h3 id=\"u6838_u5FC3_u53C2_u6570\">核心参数</h3><ul><li><code>corePoolSize</code>：最小存活的工作线程数量（如果设置<code>allowCoreThreadTimeOut</code>，那么该值为 0）</li><li><code>maximumPoolSize</code>：最大的线程数量，受限于<code>CAPACITY</code></li><li><code>keepAliveTime</code>：对应线程的存活时间，时间单位由TimeUnit指定</li><li><code>workQueue</code>：工作队列，存储待执行的任务</li><li><code>RejectExecutionHandler</code>：拒绝策略，线程池满后会触发</li></ul><p><strong>线程池的最大容量</strong>：<code>CAPACITY</code>中的前三位用作标志位，也就是说工作线程的最大容量为<code>(2^29)-1</code></p><h3 id=\"u56DB_u79CD_u6A21_u578B\">四种模型</h3><ul><li><code>CachedThreadPool</code>：一个可缓存的线程池，如果线程池的当前规模超过了处理需求时，那么将回收空闲的线程，当需求增加时，则可以添加新的线程，线程池的规模不存在任何的限制。</li><li><code>FixedThreadPool</code>：一个固定大小的线程池，提交一个任务时就创建一个线程，直到达到线程池的最大数量，这时线程池的大小将不再变化。</li><li><code>SingleThreadPool</code>：一个单线程的线程池，它只有一个工作线程来执行任务，可以确保按照任务在队列中的顺序来串行执行，如果这个线程异常结束将创建一个新的线程来执行任务。</li><li><code>ScheduledThreadPool</code>：一个固定大小的线程池，并且以延迟或者定时的方式来执行任务，类似于Timer。</li></ul><h2 id=\"u6267_u884C_u4EFB_u52A1_execute\">执行任务 execute</h2><p>核心逻辑：</p><ol><li>当前线程数量 corePoolSize，直接开启新的核心线程执行任务<code>addWorker(command, true)</code></li><li>当前线程数量 &gt;= <code>corePoolSize</code>，且任务加入工作队列成功
<ol><li>检查线程池当前状态是否处于<code>RUNNING</code></li><li>如果否，则拒绝该任务</li><li>如果是，判断当前线程数量是否为 0，如果为 0，就增加一个工作线程。</li></ol></li><li>开启普通线程执行任务<code>addWorker(command, false)</code>，开启失败就拒绝该任务</li></ol><p>从上面的分析可以总结出线程池运行的四个阶段：</p><ol><li><code>poolSize 且队列为空，此时会新建线程来处理提交的任务</code></li><li><code>poolSize == corePoolSize</code>，此时提交的任务进入工作队列，工作线程从队列中获取任务执行，此时队列不为空且未满。</li><li><code>poolSize == corePoolSize</code>，并且队列已满，此时也会新建线程来处理提交的任务，但是<code>poolSize </code></li><li><code>poolSize == maxPoolSize</code>，并且队列已满，此时会触发拒绝策略</li></ol><h2 id=\"u62D2_u7EDD_u7B56_u7565\">拒绝策略</h2><p>前面我们提到任务无法执行会被拒绝，<code>RejectedExecutionHandler</code>是处理被拒绝任务的接口。下面是四种拒绝策略。</p><ul><li><code>AbortPolicy</code>：默认策略，终止任务，抛出RejectedException</li><li><code>CallerRunsPolicy</code>：在调用者线程执行当前任务，不抛异常</li><li><code>DiscardPolicy</code>： 抛弃策略，直接丢弃任务，不抛异常</li><li><code>DiscardOldersPolicy</code>：抛弃最老的任务，执行当前任务，不抛异常</li></ul><h2 id=\"u7EBF_u7A0B_u6C60_u4E2D_u7684_Worker\">线程池中的 Worker</h2><p><code>Worker</code>继承了<code>AbstractQueuedSynchronizer</code>和<code>Runnable</code>，前者给<code>Worker</code>提供锁的功能，后者执行工作线程的主要方法<code>runWorker(Worker w)</code>（从任务队列捞任务执行）。Worker 引用存在<code>workers</code>集合里面，用<code>mainLock</code>守护。</p><pre class=\"crayon-plain-tag\">private final ReentrantLock mainLock = new ReentrantLock();
private final HashSet workers = new HashSet();</pre><p></p><h3 id=\"u6838_u5FC3_u51FD_u6570_runWorker\">核心函数 runWorker</h3><p>下面是简化的逻辑，注意：每个工作线程的<code>run</code>都执行下面的函数</p><pre class=\"crayon-plain-tag\">final void runWorker(Worker w) {
    Thread wt = Thread.currentThread();
    Runnable task = w.firstTask;
    w.firstTask = null;
    while (task != null || (task = getTask()) != null) {
        w.lock();
        beforeExecute(wt, task);
        task.run();
        afterExecute(task, thrown);
        w.unlock();
    }
    processWorkerExit(w, completedAbruptly);
}</pre><p></p><ol><li>从<code>getTask()</code>中获取任务</li><li>锁住 worker</li><li>执行<code>beforeExecute(wt, task)</code>，这是<code>ThreadPoolExecutor</code>提供给子类的扩展方法</li><li>运行任务，如果该worker有配置了首次任务，则先执行首次任务且只执行一次。</li><li>执行<code>afterExecute(task, thrown);</code></li><li>解锁 worker</li><li>如果获取到的任务为 null，关闭 worker</li></ol><h2 id=\"u83B7_u53D6_u4EFB_u52A1_getTask\">获取任务 getTask</h2><p>线程池内部的任务队列是一个阻塞队列，具体实现在构造时传入。</p><pre class=\"crayon-plain-tag\">private final BlockingQueue workQueue;</pre><p><code>getTask()</code>从任务队列中获取任务，支持阻塞和超时等待任务，四种情况会导致返回<code>null</code>，让<code>worker</code>关闭。</p><ol><li>现有的线程数量超过最大线程数量</li><li>线程池处于<code>STOP</code>状态</li><li>线程池处于<code>SHUTDOWN</code>状态且工作队列为空</li><li>线程等待任务超时，且线程数量超过保留线程数量</li></ol><p>核心逻辑：根据<code>timed</code>在阻塞队列上超时等待或者阻塞等待任务，等待任务超时会导致工作线程被关闭。</p><pre class=\"crayon-plain-tag\">timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;
Runnable r = timed ?
    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :
    workQueue.take();</pre><p>在以下两种情况下等待任务会超时：</p><ol><li>允许核心线程等待超时，即<code>allowCoreThreadTimeOut(true)</code></li><li>当前线程是普通线程，此时<code>wc &gt; corePoolSize</code></li></ol><p>工作队列使用的是<code>BlockingQueue</code>，这里就不展开了，后面再写一篇详细的分析。</p><h2 id=\"u603B_u7ED3\">总结</h2><ul><li><code>ThreadPoolExecutor</code>基于生产者-消费者模式，提交任务的操作相当于生产者，执行任务的线程相当于消费者。</li><li><code>Executors</code>提供了四种基于<code>ThreadPoolExecutor</code>构造线程池模型的方法，除此之外，我们还可以直接继承<code>ThreadPoolExecutor</code>，重写<code>beforeExecute</code>和<code>afterExecute</code>方法来定制线程池任务执行过程。</li><li>使用有界队列还是无界队列需要根据具体情况考虑，工作队列的大小和线程的数量也是需要好好考虑的。</li><li>拒绝策略推荐使用<code>CallerRunsPolicy</code>，该策略不会抛弃任务，也不会抛出异常，而是将任务回退到调用者线程中执行。</li></ul></div><div class=\"wp_rp_wrap  wp_rp_plain\" ><div class=\"wp_rp_content\"><h3 class=\"related_post_title\">相关文章</h3><ul class=\"related_post wp_rp\" style=\"visibility: visible\"><li ><a href=\"http://blog.jobbole.com/101926/\" class=\"wp_rp_title\">C#多线程之旅（3）：线程池</a></li><li ><a href=\"http://blog.jobbole.com/79421/\" class=\"wp_rp_title\">Eric Raymond对于几大开发语言的评价</a></li><li ><a href=\"http://blog.jobbole.com/102976/\" class=\"wp_rp_title\">jdk-logging、log4j、logback日志介绍及原理</a></li><li ><a href=\"http://blog.jobbole.com/71730/\" class=\"wp_rp_title\">Web应用扩展系列（2）：如何确定Web应用线程池的大小</a></li><li ><a href=\"http://blog.jobbole.com/87944/\" class=\"wp_rp_title\">MYSQL线程池总结(一)</a></li><li ><a href=\"http://blog.jobbole.com/101830/\" class=\"wp_rp_title\">Java集合框架源码剖析：LinkedList</a></li><li ><a href=\"http://blog.jobbole.com/100842/\" class=\"wp_rp_title\">C++ 线程池实现原理</a></li><li ><a href=\"http://blog.jobbole.com/87949/\" class=\"wp_rp_title\">MySQL线程池总结(二)</a></li><li ><a href=\"http://blog.jobbole.com/87988/\" class=\"wp_rp_title\">Nginx 引入线程池，提升 9 倍性能</a></li><li ><a href=\"http://blog.jobbole.com/66078/\" class=\"wp_rp_title\">Java 8 中 HashMap 的性能提升 </a></li></ul></div></div><p><a href=\"http://blog.jobbole.com/103979/\">Java 线程池框架核心代码分析</a>，首发于<a href=\"http://blog.jobbole.com\">文章 - 伯乐在线</a>。</p>") (wfw:commentRss nil "http://blog.jobbole.com/103979/feed/") (slash:comments nil "0")) (item nil (title nil "RedisHttpSession 的设计与实现") (link nil "http://blog.jobbole.com/103980/") (comments nil "http://blog.jobbole.com/103980/#respond") (pubDate nil "Sat, 30 Jul 2016 04:19:48 +0000") (dc:creator nil "肖汉松") (category nil "IT技术") (category nil "java") (category nil "Redis") (category nil "RedisHttpSession") (guid ((isPermaLink . "false")) "http://blog.jobbole.com/?p=103980") (description nil "<p>RedisHttpSession 是我的一个 Java 开源项目，通过将 Session 存储在 Redis 中实现多服务器间共享 Session，同时这一过程是完全透明的。主要用于支持 RESTfuls API。下面我将对其核心类进行分析，阐述它的设计以及实现细节。</p><p><a href=\"http://blog.jobbole.com/103980/\">RedisHttpSession 的设计与实现</a>，首发于<a href=\"http://blog.jobbole.com\">文章 - 伯乐在线</a>。</p>") (content:encoded nil "<div><h2 id=\"u524D_u8A00\">前言</h2><p><a href=\"https://github.com/x-hansong/RedisHttpSession\" target=\"_blank\" rel=\"external\">RedisHttpSession</a> 是我的一个 Java 开源项目，通过将 Session 存储在 Redis 中实现多服务器间共享 Session，同时这一过程是完全透明的。主要用于支持 RESTfuls API。下面我将对其核心类进行分析，阐述它的设计以及实现细节。</p><h2 id=\"RedisHttpSession\">RedisHttpSession</h2><p>这个类实现了<code>HttpSession</code>接口，用于替换默认的<code>HttpSession</code>实现。<code>RedisHttpSession</code>将<code>HttpSession</code>的接口方法重写了一遍，将<code>HttpSession</code>的属性存储到了 Redis 中。</p><p>每个<code>RedisHttpSession</code>都有一个 UUID 与之对应，该字段加上<code>session:</code>前缀作为存储在 Redis 中的键值。例如：</p><pre class=\"crayon-plain-tag\">localhost:63679&gt; keys *
1) \"session:fd9ec3cf-fb9b-4672-ade6-67a810e7db9f\"
2) \"session:cbaa057c-85a4-475d-b399-38c320e85dcc\"
3) \"session:13e030f5-de3d-458f-8d25-fd5643c40ff0\"
4) \"session:262596b3-3d13-4df1-8328-714153c1ae83\"
5) \"session:0b7d04c6-eaac-4eed-a9aa-8366f25f04f0\"</pre><p>同时，<code>RedisHttpSession</code>中的属性是直接序列化成字节数组存储在 Redis 中的，存储在对应键中的哈希表里面。例如：</p><pre class=\"crayon-plain-tag\">localhost:63679&gt; hgetall session:fd9ec3cf-fb9b-4672-ade6-67a810e7db9f
1) \"lastAccessedTime\"
2) \"\\xac\\xed\\x00\\x05sr\\x00\\x0ejava.lang.Long;\\x8b\\xe4\\x90\\xcc\\x8f#\\xdf\\x02\\x00\\x01J\\x00\\x05valuexr\\x00\\x10java.lang.Number\\x86\\xac\\x95\\x1d\\x0b\\x94\\xe0\\x8b\\x02\\x00\\x00xp\\x00\\x00\\x01T\\x91\\x03\\\"\\xec\"
3) \"maxInactiveInterval\"
4) \"\\xac\\xed\\x00\\x05sr\\x00\\x11java.lang.Integer\\x12\\xe2\\xa0\\xa4\\xf7\\x81\\x878\\x02\\x00\\x01I\\x00\\x05valuexr\\x00\\x10java.lang.Number\\x86\\xac\\x95\\x1d\\x0b\\x94\\xe0\\x8b\\x02\\x00\\x00xp\\x00\\x00\\a\\b\"
5) \"creationTime\"
6) \"\\xac\\xed\\x00\\x05sr\\x00\\x0ejava.lang.Long;\\x8b\\xe4\\x90\\xcc\\x8f#\\xdf\\x02\\x00\\x01J\\x00\\x05valuexr\\x00\\x10java.lang.Number\\x86\\xac\\x95\\x1d\\x0b\\x94\\xe0\\x8b\\x02\\x00\\x00xp\\x00\\x00\\x01T\\x91\\x03\\\"\\xb4\"</pre><p>另外，Session 的自动过期是通过 Redis 设置键的过期时间实现的。</p><h2 id=\"RedisHttpSessionProxy\">RedisHttpSessionProxy</h2><p><code>RedisHttpSessionProxy</code>是<code>RedisHttpSession</code>的代理类，使用了 JDK 的动态代理。为什么要引入代理？这是基于下面的考虑做出的设计。</p><ol><li>由于 Session 存储在 Redis 中，在执行每个<code>RedisHttpSession</code>的接口方法之前都需要检查 Redis 连接是否可用。</li><li>访问一个已经被注销的 Session 需要抛出异常。</li><li>每次访问 Session 需要刷新过期时间和最后访问时间。</li></ol><p>基于上面的考虑，对于每个<code>RedisHttpSession</code>的接口方法，我们都需要进行重复的操作，因此使用动态代理对每个接口方法进行增强是最合适的。代码如下：</p><pre class=\"crayon-plain-tag\">public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
    RedisHttpSession session = (RedisHttpSession) originalObj;
    //check redis connection
    RedisConnection connection = session.getRedisConnection();
    if (!connection.isConnected()){
        connection.close();
        session.setRedisConnection(repository.getRedisConnection());
    }
    //For every methods of interface, check it valid or not
    if (session.isInvalidated()){
        throw new IllegalStateException(\"The HttpSession has already be invalidated.\");
    } else {
        Object result =  method.invoke(originalObj, args);
        //if not invalidate method, refresh expireTime and lastAccessedTime;
        if (!method.getName().equals(\"invalidate\")) {
            session.refresh();
            session.setLastAccessedTime(System.currentTimeMillis());
        }
        return result;
    }
}</pre><p></p><h2 id=\"RedisHttpSessionFilter\">RedisHttpSessionFilter</h2><p><code>RedisHttpSessionFilter</code>作为过滤器，将请求和响应替换成<code>RedisSessionRequestWrapper</code>和<code>RedisSessionResponseWrapper</code>，利用了装饰器模式动态的给请求和响应进行增强：</p><ol><li><code>RedisSessionRequestWrapper</code>：重写了<code>getSession</code>，替换默认的<code>HttpSession</code>实现为<code>RedisHttpSession</code>。</li><li><code>RedisSessionResponseWrapper</code>：在响应的头部中加入<code>x-auth-token</code>字段，作为 Session 的 ID。客户端之后的请求都需要附带该字段，以便服务端识别对应的 Session。</li></ol><h2 id=\"u603B_u7ED3\">总结</h2><p><a href=\"https://github.com/x-hansong/RedisHttpSession\" target=\"_blank\" rel=\"external\">RedisHttpSession</a> 利用 Filter 将请求的 Session 替换成 <code>RedisHttpSession</code>，在过滤阶段偷梁换柱，在之后对 Session 的操作都无需关心其内部实现，整个过程都是透明的。</p></div><div class=\"wp_rp_wrap  wp_rp_plain\" ><div class=\"wp_rp_content\"><h3 class=\"related_post_title\">相关文章</h3><ul class=\"related_post wp_rp\" style=\"visibility: visible\"><li ><a href=\"http://blog.jobbole.com/94518/\" class=\"wp_rp_title\">Redis 未授权访问缺陷可轻易导致系统被黑</a></li><li ><a href=\"http://blog.jobbole.com/103106/\" class=\"wp_rp_title\">Redis 和 Memcached 的区别</a></li><li ><a href=\"http://blog.jobbole.com/88064/\" class=\"wp_rp_title\">Redis 与网络流量整形</a></li><li ><a href=\"http://blog.jobbole.com/88569/\" class=\"wp_rp_title\">Hadoop的Server及其线程模型分析</a></li><li ><a href=\"http://blog.jobbole.com/101496/\" class=\"wp_rp_title\">也谈谈 Redis 和 Memcached 的区别</a></li><li ><a href=\"http://blog.jobbole.com/88170/\" class=\"wp_rp_title\">10 个 Redis 建议/技巧</a></li><li ><a href=\"http://blog.jobbole.com/71095/\" class=\"wp_rp_title\">深入理解Redis主键失效原理及实现机制</a></li><li ><a href=\"http://blog.jobbole.com/95780/\" class=\"wp_rp_title\">Redis 与搜索热词推荐</a></li><li ><a href=\"http://blog.jobbole.com/97145/\" class=\"wp_rp_title\">Redis 集群的合纵与连横</a></li><li ><a href=\"http://blog.jobbole.com/79421/\" class=\"wp_rp_title\">Eric Raymond对于几大开发语言的评价</a></li></ul></div></div><p><a href=\"http://blog.jobbole.com/103980/\">RedisHttpSession 的设计与实现</a>，首发于<a href=\"http://blog.jobbole.com\">文章 - 伯乐在线</a>。</p>") (wfw:commentRss nil "http://blog.jobbole.com/103980/feed/") (slash:comments nil "0")))) ("编写高质量代码" "<p style=\"text-align: justify\">我们知道，<strong>int</strong>和<strong>double</strong>能表示的数值的范围不同。其中，<strong>64</strong>位有符号整数的范围是[<strong>-9223372036854775808</strong>,<strong>9223372036854775807</strong>]，而<strong>64</strong>位无符号整数的范围是[<strong>0</strong>,<strong>18446744073709551615</strong>]。这两个区间有一定的<strong>overlap</strong>，而<strong>double</strong>可以表示的范围更大。</p><p style=\"text-align: justify\">现在，需要编写两个函数:给定一个<strong>double</strong>型的<strong>value</strong>，判断这个<strong>value</strong>是否是一个合法的<strong>int64_t</strong>或者<strong>uint64_t</strong>。本文说的“合法”，是指数值上落在了范围内。</p><p></p><pre class=\"crayon-plain-tag\">bool is_valid_uint64(const Double &amp;value);
bool is_valid_int64(const Double &amp;value);</pre><p></p><p style=\"text-align: justify\">这里我们用<strong>Double</strong>而不是<strong>double</strong>，原因是我们的<strong>double</strong>不是基础数据类型，而是通过一定方法实现的<strong>ADT</strong>，这个<strong>ADT</strong>的成员函数有：</p><p></p><pre class=\"crayon-plain-tag\">class Double
{
public:
int get_next_digit(bool &amp;is_decimal);
bool is_zero();
bool is_neg();
};</pre><p></p><p style=\"text-align: justify\">通过调用<code>get_next_digit</code>，可以返回一个数字，不断调用它，可以得到所有<strong>digits</strong>。举个例子，对于值为<strong>45.67</strong>的一个<strong>Double</strong>对象，调用它的<code>get_next_digit</code>成员函数将依次得到</p><p style=\"text-align: justify\">4 is_decimal = false //表示整数部分</p><p style=\"text-align: justify\">5 is_decimal = false //表示整数部分</p><p style=\"text-align: justify\">6 is_decimal = true //表示小数部分</p><p style=\"text-align: justify\">7 is_decimal = true //表示小数部分</p><p style=\"text-align: justify\">当<code>get_next_digit</code>返回<strong>-1</strong>时，表示读取完毕。</p><p style=\"text-align: justify\">如何利用<strong>Double</strong>类里的成员函数，来实现<code>is_valid_uint64</code>和<code>is_valid_int64</code>这两个函数呢？</p><p style=\"text-align: justify\">一些新手可能会写这样的代码：</p><p></p><pre class=\"crayon-plain-tag\">bool is_valid_uint64(const Double &amp;value)
{
bool is_valid = true;
int digits[2000];
int counts = 0;
if (value.is_zero()) {
is_valid = true;
} else if(value.is_neg()) {
is_valid = false;
} else {
bool is_decimal = false;
int digit = 0;
while((digit=value.get_next_digit(is_decimal)) != -1) {
if (is_decimal) {
is_valid = false;
break;
} else {
digits[counts++] = digit;
}
}
uint64_t tmp = 0;
uint64_t base = 1;
for (int i = counts - 1; i &gt;= 0; i++) {
tmp += digits[i] * base;
if (tmp &gt; UINT64_MAX) {
is_valid = false;
break;
}
base *= 10;
}
}
return is_valid;
}
bool is_valid_int64(const Double &amp;value)
{
bool is_valid = true;
int digits[2000];
int counts = 0;
if (value.is_zero()) {
is_valid = true;
} else if(value.is_neg()) {
bool is_decimal = false;
int digit = 0;
while((digit=value.get_next_digit(is_decimal)) != -1) {
if (is_decimal) {
is_valid = false;
break;
} else {
digits[counts++] = digit;
}
}
uint64_t tmp = 0;
uint64_t base = 1;
for (int i = counts - 1; i &gt;= 0; i++) {
tmp += digits[i] * base;
tmp *= -1;
if (tmp  INT64_MIN) {
is_valid = false;
break;
}
base *= 10;
}
} else {
bool is_decimal = false;
int digit = 0;
while((digit=value.get_next_digit(is_decimal)) != -1) {
if (is_decimal) {
is_valid = false;
break;
} else {
digits[counts++] = digit;
}
}
uint64_t tmp = 0;
uint64_t base = 1;
for (int i = counts - 1; i &gt;= 0; i++) {
tmp += digits[i] * base;
if (tmp &gt; INT64_MAX) {
is_valid = false;
break;
}
base *= 10;
}
}
return is_valid;
}</pre><p></p><p style=\"text-align: justify\">这样的代码，存在诸多问题。</p><h2 id=\"section\" style=\"text-align: justify\">设计问题</h2><p style=\"text-align: justify\">不难发现，两个函数存在很多相似甚至相同的代码；而同一个函数内部，也有不少代码重复。重复的东西往往不是好的。重构？</p><h2 id=\"section-1\" style=\"text-align: justify\">性能问题</h2><p style=\"text-align: justify\">先获得所有digits，然后从最低位开始向最高位构造值，效率较低。难道没有可以从最高位开始，边获得边计算，不需要临时数组存储所有digits的方法吗？</p><h2 id=\"section-2\" style=\"text-align: justify\">正确性问题</h2><p style=\"text-align: justify\">随便举几个例子：</p><p style=\"text-align: justify\">第<strong>24</strong>行，<code>tmp += digits[i] * base</code>;有没有考虑到可能的溢出呢？</p><p style=\"text-align: justify\">第<strong>68</strong>行，难道有小数部分就一定不是合法的<strong>int64</strong>吗？那么，<strong>123.000</strong>？嗯？</p><h2 id=\"section-3\" style=\"text-align: justify\">规范问题</h2><p style=\"text-align: justify\">帅哥，这么多代码，一行注释都没有，这样真的好吗？</p><p style=\"text-align: justify\">因此，毫无疑问，这是烂代码，不合格的代码，需要重写的代码。</p><p style=\"text-align: justify\">以下是我个人认为比较好的设计和实现，仅供参考。</p><p></p><pre class=\"crayon-plain-tag\">bool is_valid_uint64(const Double &amp;value)
{
bool ret = false;
check_range(value, &amp;ret, NULL);
return ret;
}
bool is_valid_int64(const Double &amp;value)
{
bool ret = false;
check_range(value, NULL, &amp;ret);
return ret;
}
void check_range(const Double &amp;value,
bool *is_valid_uint64,
bool *is_valid_int64) const
{
/*
* 对于一个负数的value，它不可能是一个合法的uint64.
* 因此，只剩下三种可能：
* I 输入的value是负数，判断是否是合法的int64
* II 输入的value是正数，判断是否是合法的uint64
* III 输入的value是正数，判断是否是合法的int64
* 对于第II、III这两种情况：只要判断value的值是否超过uint64、int64的上界即可
* 对于第I种情况，我们利用-A &gt; -B 等价于 A
* 因此，在第I种情况里，可以判断value的绝对值，是否超过int64的最小值的绝对值即可。
* （int64的最小值的绝对值？那不就是int64的最大值？哦，不！）
* 因此，不管哪种情况，判断绝对值是否超过某个上界即可。
* 这三种情况，上界不一样。把三个上界存到了一个二维数组THRESHOLD里
*/
bool *is_valid = NULL;
static const int FLAG_INT64 = 0;
static const int FLAG_UINT64 = 1;
static const int SIGN_NEG = 0;
static const int SIGN_POS = 1;
int flag = FLAG_INT64;
if (NULL != is_valid_uint64) {
is_valid = is_valid_uint64;
flag = FLAG_UINT64;
} else {
is_valid = is_valid_int64;
}
*is_valid = true;
if (value.is_zero()) {
//do nothing。0是合法的uint64，也是合法的int64
} else {
int sign = value.is_neg() ? SIGN_NEG : SIGN_POS;
if ((SIGN_NEG == sign) &amp;&amp; (FLAG_UINT64 == flag)) {
*is_valid = false;//负数不可能是合法的uint64
} else {
uint64_t valueUint = 0;
static uint64_t ABS_INT64_MIN = 9223372036854775808ULL;
//int64        uint64
static uint64_t THRESHOLD[2][2] = { {ABS_INT64_MIN, 0}, //neg
{INT64_MAX,     UINT64_MAX} }; //pos
int digit = 0;
bool is_decimal = false;
while ((digit = value.get_next_digit(is_decimal)) != -1) {
if (!is_decimal) {
//为了防止溢出，我们不能这么写:
//\"value * 10 + digit &gt; THRESHOLD[index]\"
if (valueUint &gt; (THRESHOLD[sign][flag] - digit) / 10) {
*is_valid = false;
break;
} else {
valueUint = valueUint * 10 + digit;//霍纳法则（也叫秦九韶算法）
}
} else {
if (!digit) {
*is_valid = false; //小数部分必须是0；否则不可能是合法的uint64、int64
break;
}
}
}
}
}
}</pre><p></p><h2 id=\"section\" style=\"text-align: justify\">代码规范</h2><p style=\"text-align: justify\">团队的代码规范，一般由领导和大佬们制定后，大家统一实行。这里面有几个问题：</p><h3 id=\"section-1\" style=\"text-align: justify\">真的需要代码规范吗？</h3><p style=\"text-align: justify\">言下之意，制定和执行代码规范是否浪费时间？</p><p style=\"text-align: justify\">答案是：It depends。如果项目很庞大、代码质量要求很高，那么，制定和执行代码规范所花费的时间，将大大少于后期因为不规范开发带来的种种调试和维护成本。如果是小打小闹的代码，就无所谓了。</p><h3 id=\"section-2\" style=\"text-align: justify\">代码规范的制定为什么这么难？</h3><p style=\"text-align: justify\">原因众多，其中一个很重要的部分是团队每个人的口味和观点不尽相同。就代码风格而言，有人喜欢对内置类型变量i使用i++，有人坚持认为应该使用++i不管i是不是复杂类型。因此，制定代码规范需要在讨论之后最后拍板决定，这里面甚至需要独裁！是的，独裁！</p><h3 id=\"section-3\" style=\"text-align: justify\">代码规范制定需要注意什么事项？</h3><p style=\"text-align: justify\">如果代码规范限制太松，那么等于没有规范；如果太严，大大影响开发效率。这里面的尺度，需要根据项目需要、团队成员特点全面考量，进行取舍。</p><p style=\"text-align: justify\">需要注意的是，没有任何一种代码规范是完美的。例如，在C++中，如果启用异常，那么代码的流程将会被各种异常处理中断，各种try catch throw让代码很不美观；如果禁用异常，也就是在开发的过程中不能使用异常特性，那么团队成员可能因为长期没有接触这项语言feature而造成知识和技能短板。</p><h3 id=\"section-4\" style=\"text-align: justify\">代码风格举例</h3><p style=\"text-align: justify\">举两个我认为比较重要、比较新鲜、比较有趣的代码风格。</p><p style=\"text-align: justify\">1，使用引用需要判空吗？</p><p></p><pre class=\"crayon-plain-tag\">void f(int &amp;p);
void g(int *p);</pre><p></p><p style=\"text-align: justify\">我们都知道，在g中，使用*p前需要对p是否为NULL进行判断，那么f呢？如果质量非常关键、代码安全非常重要的场景，那么实际上，也是需要的。因为调用者可能这样：</p><p></p><pre class=\"crayon-plain-tag\">int *q = NULL;
//......
f(*q);</pre><p></p><p style=\"text-align: justify\">因此，需要在f里增加<code>if(NULL == &amp;p)</code>的判断。</p><p style=\"text-align: justify\">2，级联if else语句。</p><p style=\"text-align: justify\">首先看一个我个人认为不好的代码风格：</p><p></p><pre class=\"crayon-plain-tag\">int f(int a, int b)
{
if (a &gt;= 1) {
if (b &gt;= 1) {
if (a &gt;= b) {
//do sth
} else {
//error1
}
} else {
//error2
}
} else {
//error3
}
}</pre><p></p><p style=\"text-align: justify\">这个函数的核心在于do sth部分。其实我们可以改写为级联if－else形式，如下：</p><p></p><pre class=\"crayon-plain-tag\">int f(int a, int b)
{
if (a &lt; 1) {
//error3
} else if (b &lt; 1) {
//error2
} else if (a &lt; b) {
//error1
} else {
//so, a&gt;=1 &amp;&amp; b&gt;=1 &amp;&amp; a&gt;=b
//do sth
}
}</pre><p></p><p style=\"text-align: justify\">是不是优美多了？前面只做一些错误处理、前期准备、参数检查等，最后的else分支做实实在在的功能性事情。</p><h2 id=\"code-review\" style=\"text-align: justify\">Code Review</h2><h3 id=\"code-review-1\" style=\"text-align: justify\">什么是Code Review？</h3><p style=\"text-align: justify\">很多人把它翻译为代码审查，我觉得太政治味了。程序员尤其是新手写完代码后，可能会有风格问题（比如不符合团队的代码规范）、安全性问题(比如忘记指针判空)、优雅性问题(比如大量冗余代码)、正确性问题（比如算法设计错误），那么在发布代码到公共库之前，提交给师兄或者mentor，让他帮你review一下代码，并提出可能的问题和建议，让你好好修改。这样的过程，就叫做Code Review。</p><h3 id=\"section-5\" style=\"text-align: justify\">我的天呐，那这不是很占用时间？</h3><p style=\"text-align: justify\">是的。一个写代码，一个看代码，看代码的时间可能并不比全新写一份代码少。那么，这又是何必呢？</p><p style=\"text-align: justify\">主要的原因有：</p><p style=\"text-align: justify\">1，review确实占用了开发时间，然而开发，或者说写代码，其实只占很少的时间比例。很多时间花在debug、调试、写文档、需求分析、设计算法、维护等等上。</p><p style=\"text-align: justify\">2，代码质量非常重要，这点时间投入是值得的。与其后期苦逼追bug，不如前期多投入点时间和人力。</p><p style=\"text-align: justify\">3，培养新人，让新手更快成长。</p><h3 id=\"code-review-2\" style=\"text-align: justify\">如何更好的执行Code Review</h3><p style=\"text-align: justify\">这里给几点建议：</p><p style=\"text-align: justify\">1，不走过场。走过场，还不如不要这个流程。</p><p style=\"text-align: justify\">2，作为Reviewer，看不懂代码就把作者拉过来，当面询问，不要不懂装懂，也不要爱面子不好意思问。</p><p style=\"text-align: justify\">3，作为Coder，心里要有感激之情。真的。不要得了便宜还卖乖，感恩reviewer，感激reviewer对自己的进步和成长所做出的贡献，所花费的心血。中国人里狼心狗肺、忘恩负义、不懂感恩的人还算少吗？</p><p style=\"text-align: justify\">4，作为Coder，给Reviewer Review之前，请先做单元测试并确保通过，并自己尝试先整体看一遍自己本次提交的代码。注意，不要给别人提还没调试通过的代码，这是非常不尊重别人的表现。</p><h2 id=\"section-6\" style=\"text-align: justify\">质量保证</h2><p style=\"text-align: justify\">1，测试不是专属QA的活儿，对自己写的代码提供质量保证，是程序员的职责。QA要负责的，是系统的质量，不是模块的质量。</p><p style=\"text-align: justify\">2，测试，需要意识，需要坚持。我发现C++程序员、前端程序员的测试意识或者说质量意识最强；数据科学家或者数据工程师的质量意识最差，很多人甚至不写测试用例。当然，这不怪他们，毕竟，有时候代码里有个bug，准确率和召回率会更高。</p><p style=\"text-align: justify\">3，测试用例的编写和设计需要保证一定的代码覆盖率，力求让每个分支和流程的代码都走到，然后分析运行结果是否是符合期望的，不要只考虑正确路径上的那些分支。</p><p style=\"text-align: justify\">4，测试用例的编写和设计力求全面，考虑到方方面面。以非常经典的二分搜索为例：</p><p style=\"text-align: justify\">int binary_search(int *p, int n, int target, int &amp;idx);</p><p style=\"text-align: justify\">binary_search函数返回值为0表示成功执行，输出参数idx返回target在有序数组p中(第一次出现)的位置，－1表示不存在。</p><p style=\"text-align: justify\">那么测试用例至少应该涵盖：</p><ul style=\"text-align: justify\"><li>p为NULL的情况</li><li>数组大小n分别为负数、0、1、2时情况</li><li>数组p不是有序数组的情况</li><li>target在数组中出现0次、1次、n次的情况</li></ul><p style=\"text-align: justify\">你是否都考虑到了呢？</p><p style=\"text-align: justify\">4，有时候，自己书写测试用例显得刀耕火种，现在已经有很多辅助的工具，读者可以自行google一下。</p><div class=\"wp_rp_wrap  wp_rp_plain\" id=\"wp_rp_first\"><div class=\"wp_rp_content\"><h3 class=\"related_post_title\">相关文章</h3><ul class=\"related_post wp_rp\" style=\"visibility: visible\"><li ><a href=\"http://blog.jobbole.com/104042/\" class=\"wp_rp_title\">如何在 Linux 下检测内存泄漏</a></li><li ><a href=\"http://blog.jobbole.com/103102/\" class=\"wp_rp_title\">C++虚表，你搞懂了吗？</a></li><li ><a href=\"http://blog.jobbole.com/93699/\" class=\"wp_rp_title\">趣文：C++ 程序员离职之前要做的事</a></li><li ><a href=\"http://blog.jobbole.com/88050/\" class=\"wp_rp_title\">Notepad++源码编译及其分析</a></li><li ><a href=\"http://blog.jobbole.com/103669/\" class=\"wp_rp_title\">C++11 中的 Defaulted 和 Deleted 函数</a></li><li ><a href=\"http://blog.jobbole.com/36088/\" class=\"wp_rp_title\">你可能不知道的陷阱：C#委托和事件的困惑</a></li><li ><a href=\"http://blog.jobbole.com/87586/\" class=\"wp_rp_title\">标准模板库（STL）使用入门（上）</a></li><li ><a href=\"http://blog.jobbole.com/101441/\" class=\"wp_rp_title\">漫谈 C++：良好的编程习惯与编程要点</a></li><li ><a href=\"http://blog.jobbole.com/83497/\" class=\"wp_rp_title\">在C++中实现Python的切片</a></li><li ><a href=\"http://blog.jobbole.com/82628/\" class=\"wp_rp_title\">C++之父：C++ 的五个普遍误解（3）</a></li></ul></div></div><p><a href=\"http://blog.jobbole.com/104080/\">编写高质量代码</a>，首发于<a href=\"http://blog.jobbole.com\">文章 - 伯乐在线</a>。</p>" "http://blog.jobbole.com/104080/" (22432 251) old 8 nil nil ((title nil "编写高质量代码") (link nil "http://blog.jobbole.com/104080/") (comments nil "http://blog.jobbole.com/104080/#respond") (pubDate nil "Tue, 02 Aug 2016 02:10:03 +0000") (dc:creator nil "ABOER") (category nil "IT技术") (category nil "C++") (guid ((isPermaLink . "false")) "http://blog.jobbole.com/?p=104080") (description nil "<p>本文介绍如何编写高质量的C++代码。从微观角度，以一个实际的例子，从正确、高效、易读等特性着手，介绍如何编写高质量的代码。从宏观出发，从软件开发流程入手，着重介绍其中的几个方面，包括代码规范、Code Review、测试等。</p><p><a href=\"http://blog.jobbole.com/104080/\">编写高质量代码</a>，首发于<a href=\"http://blog.jobbole.com\">文章 - 伯乐在线</a>。</p>") (content:encoded nil "<p style=\"text-align: justify\">我们知道，<strong>int</strong>和<strong>double</strong>能表示的数值的范围不同。其中，<strong>64</strong>位有符号整数的范围是[<strong>-9223372036854775808</strong>,<strong>9223372036854775807</strong>]，而<strong>64</strong>位无符号整数的范围是[<strong>0</strong>,<strong>18446744073709551615</strong>]。这两个区间有一定的<strong>overlap</strong>，而<strong>double</strong>可以表示的范围更大。</p><p style=\"text-align: justify\">现在，需要编写两个函数:给定一个<strong>double</strong>型的<strong>value</strong>，判断这个<strong>value</strong>是否是一个合法的<strong>int64_t</strong>或者<strong>uint64_t</strong>。本文说的“合法”，是指数值上落在了范围内。</p><p></p><pre class=\"crayon-plain-tag\">bool is_valid_uint64(const Double &amp;value);

bool is_valid_int64(const Double &amp;value);</pre><p></p><p style=\"text-align: justify\">这里我们用<strong>Double</strong>而不是<strong>double</strong>，原因是我们的<strong>double</strong>不是基础数据类型，而是通过一定方法实现的<strong>ADT</strong>，这个<strong>ADT</strong>的成员函数有：</p><p></p><pre class=\"crayon-plain-tag\">class Double
{
  public:
    int get_next_digit(bool &amp;is_decimal);
    bool is_zero();
    bool is_neg();
};</pre><p></p><p style=\"text-align: justify\">通过调用<code>get_next_digit</code>，可以返回一个数字，不断调用它，可以得到所有<strong>digits</strong>。举个例子，对于值为<strong>45.67</strong>的一个<strong>Double</strong>对象，调用它的<code>get_next_digit</code>成员函数将依次得到</p><p style=\"text-align: justify\">4 is_decimal = false //表示整数部分</p><p style=\"text-align: justify\">5 is_decimal = false //表示整数部分</p><p style=\"text-align: justify\">6 is_decimal = true //表示小数部分</p><p style=\"text-align: justify\">7 is_decimal = true //表示小数部分</p><p style=\"text-align: justify\">当<code>get_next_digit</code>返回<strong>-1</strong>时，表示读取完毕。</p><p style=\"text-align: justify\">如何利用<strong>Double</strong>类里的成员函数，来实现<code>is_valid_uint64</code>和<code>is_valid_int64</code>这两个函数呢？</p><p style=\"text-align: justify\">一些新手可能会写这样的代码：</p><p></p><pre class=\"crayon-plain-tag\">bool is_valid_uint64(const Double &amp;value)
{
  bool is_valid = true;
  int digits[2000];
  int counts = 0;
  if (value.is_zero()) {
    is_valid = true;
  } else if(value.is_neg()) {
    is_valid = false;
  } else {
    bool is_decimal = false;
    int digit = 0;
    while((digit=value.get_next_digit(is_decimal)) != -1) {
      if (is_decimal) {
        is_valid = false;
        break;
      } else {
        digits[counts++] = digit;
      }
    }
    uint64_t tmp = 0;
    uint64_t base = 1;
    for (int i = counts - 1; i &gt;= 0; i++) {
      tmp += digits[i] * base;
      if (tmp &gt; UINT64_MAX) {
        is_valid = false;
        break;
      }
      base *= 10;
    }
  }
  return is_valid;
}
bool is_valid_int64(const Double &amp;value)
{
  bool is_valid = true;
  int digits[2000];
  int counts = 0;
  if (value.is_zero()) {
    is_valid = true;
  } else if(value.is_neg()) {
    bool is_decimal = false;
    int digit = 0;
    while((digit=value.get_next_digit(is_decimal)) != -1) {
      if (is_decimal) {
        is_valid = false;
        break;
      } else {
        digits[counts++] = digit;
      }
    }
    uint64_t tmp = 0;
    uint64_t base = 1;
    for (int i = counts - 1; i &gt;= 0; i++) {
      tmp += digits[i] * base;
      tmp *= -1;
      if (tmp  INT64_MIN) {
        is_valid = false;
        break;
      }
      base *= 10;
    }
  } else {
    bool is_decimal = false;
    int digit = 0;
    while((digit=value.get_next_digit(is_decimal)) != -1) {
      if (is_decimal) {
        is_valid = false;
        break;
      } else {
        digits[counts++] = digit;
      }
    }
    uint64_t tmp = 0;
    uint64_t base = 1;
    for (int i = counts - 1; i &gt;= 0; i++) {
      tmp += digits[i] * base;
      if (tmp &gt; INT64_MAX) {
        is_valid = false;
        break;
      }
      base *= 10;
    }
  }
  return is_valid;
}</pre><p></p><p style=\"text-align: justify\">这样的代码，存在诸多问题。</p><h2 id=\"section\" style=\"text-align: justify\">设计问题</h2><p style=\"text-align: justify\">不难发现，两个函数存在很多相似甚至相同的代码；而同一个函数内部，也有不少代码重复。重复的东西往往不是好的。重构？</p><h2 id=\"section-1\" style=\"text-align: justify\">性能问题</h2><p style=\"text-align: justify\">先获得所有digits，然后从最低位开始向最高位构造值，效率较低。难道没有可以从最高位开始，边获得边计算，不需要临时数组存储所有digits的方法吗？</p><h2 id=\"section-2\" style=\"text-align: justify\">正确性问题</h2><p style=\"text-align: justify\">随便举几个例子：</p><p style=\"text-align: justify\">第<strong>24</strong>行，<code>tmp += digits[i] * base</code>;有没有考虑到可能的溢出呢？</p><p style=\"text-align: justify\">第<strong>68</strong>行，难道有小数部分就一定不是合法的<strong>int64</strong>吗？那么，<strong>123.000</strong>？嗯？</p><h2 id=\"section-3\" style=\"text-align: justify\">规范问题</h2><p style=\"text-align: justify\">帅哥，这么多代码，一行注释都没有，这样真的好吗？</p><p style=\"text-align: justify\">因此，毫无疑问，这是烂代码，不合格的代码，需要重写的代码。</p><p style=\"text-align: justify\">以下是我个人认为比较好的设计和实现，仅供参考。</p><p></p><pre class=\"crayon-plain-tag\">bool is_valid_uint64(const Double &amp;value)

{

  bool ret = false;

  check_range(value, &amp;ret, NULL);

  return ret;

}



bool is_valid_int64(const Double &amp;value)

{

  bool ret = false;

  check_range(value, NULL, &amp;ret);

  return ret;

}



void check_range(const Double &amp;value,

                 bool *is_valid_uint64,

                 bool *is_valid_int64) const

{

  /*

   * 对于一个负数的value，它不可能是一个合法的uint64.

   * 因此，只剩下三种可能：

   * I 输入的value是负数，判断是否是合法的int64

   * II 输入的value是正数，判断是否是合法的uint64

   * III 输入的value是正数，判断是否是合法的int64

   * 对于第II、III这两种情况：只要判断value的值是否超过uint64、int64的上界即可

   * 对于第I种情况，我们利用-A &gt; -B 等价于 A 

   * 因此，在第I种情况里，可以判断value的绝对值，是否超过int64的最小值的绝对值即可。

   * （int64的最小值的绝对值？那不就是int64的最大值？哦，不！）

   * 因此，不管哪种情况，判断绝对值是否超过某个上界即可。

   * 这三种情况，上界不一样。把三个上界存到了一个二维数组THRESHOLD里

  */



  bool *is_valid = NULL;

  static const int FLAG_INT64 = 0;

  static const int FLAG_UINT64 = 1;

  static const int SIGN_NEG = 0;

  static const int SIGN_POS = 1;

  int flag = FLAG_INT64;

  if (NULL != is_valid_uint64) {

    is_valid = is_valid_uint64;

    flag = FLAG_UINT64;

  } else {

    is_valid = is_valid_int64;

  }

  *is_valid = true;

  if (value.is_zero()) {

    //do nothing。0是合法的uint64，也是合法的int64

  } else {

    int sign = value.is_neg() ? SIGN_NEG : SIGN_POS;

    if ((SIGN_NEG == sign) &amp;&amp; (FLAG_UINT64 == flag)) {

      *is_valid = false;//负数不可能是合法的uint64

    } else {

      uint64_t valueUint = 0;

      static uint64_t ABS_INT64_MIN = 9223372036854775808ULL;

                                         //int64        uint64

      static uint64_t THRESHOLD[2][2] = { {ABS_INT64_MIN, 0}, //neg

                                         {INT64_MAX,     UINT64_MAX} }; //pos

      int digit = 0;

      bool is_decimal = false;

      while ((digit = value.get_next_digit(is_decimal)) != -1) {

        if (!is_decimal) {

          //为了防止溢出，我们不能这么写:

          //\"value * 10 + digit &gt; THRESHOLD[index]\"

          if (valueUint &gt; (THRESHOLD[sign][flag] - digit) / 10) {

            *is_valid = false;

            break;

          } else {

            valueUint = valueUint * 10 + digit;//霍纳法则（也叫秦九韶算法）

          }

        } else {

          if (!digit) {

            *is_valid = false; //小数部分必须是0；否则不可能是合法的uint64、int64

            break;

          }

        }

      }

    }

  }

}</pre><p></p><h2 id=\"section\" style=\"text-align: justify\">代码规范</h2><p style=\"text-align: justify\">团队的代码规范，一般由领导和大佬们制定后，大家统一实行。这里面有几个问题：</p><h3 id=\"section-1\" style=\"text-align: justify\">真的需要代码规范吗？</h3><p style=\"text-align: justify\">言下之意，制定和执行代码规范是否浪费时间？</p><p style=\"text-align: justify\">答案是：It depends。如果项目很庞大、代码质量要求很高，那么，制定和执行代码规范所花费的时间，将大大少于后期因为不规范开发带来的种种调试和维护成本。如果是小打小闹的代码，就无所谓了。</p><h3 id=\"section-2\" style=\"text-align: justify\">代码规范的制定为什么这么难？</h3><p style=\"text-align: justify\">原因众多，其中一个很重要的部分是团队每个人的口味和观点不尽相同。就代码风格而言，有人喜欢对内置类型变量i使用i++，有人坚持认为应该使用++i不管i是不是复杂类型。因此，制定代码规范需要在讨论之后最后拍板决定，这里面甚至需要独裁！是的，独裁！</p><h3 id=\"section-3\" style=\"text-align: justify\">代码规范制定需要注意什么事项？</h3><p style=\"text-align: justify\">如果代码规范限制太松，那么等于没有规范；如果太严，大大影响开发效率。这里面的尺度，需要根据项目需要、团队成员特点全面考量，进行取舍。</p><p style=\"text-align: justify\">需要注意的是，没有任何一种代码规范是完美的。例如，在C++中，如果启用异常，那么代码的流程将会被各种异常处理中断，各种try catch throw让代码很不美观；如果禁用异常，也就是在开发的过程中不能使用异常特性，那么团队成员可能因为长期没有接触这项语言feature而造成知识和技能短板。</p><h3 id=\"section-4\" style=\"text-align: justify\">代码风格举例</h3><p style=\"text-align: justify\">举两个我认为比较重要、比较新鲜、比较有趣的代码风格。</p><p style=\"text-align: justify\">1，使用引用需要判空吗？</p><p></p><pre class=\"crayon-plain-tag\">void f(int &amp;p);
void g(int *p);</pre><p></p><p style=\"text-align: justify\">我们都知道，在g中，使用*p前需要对p是否为NULL进行判断，那么f呢？如果质量非常关键、代码安全非常重要的场景，那么实际上，也是需要的。因为调用者可能这样：</p><p></p><pre class=\"crayon-plain-tag\">int *q = NULL;
//......
f(*q);</pre><p></p><p style=\"text-align: justify\">因此，需要在f里增加<code>if(NULL == &amp;p)</code>的判断。</p><p style=\"text-align: justify\">2，级联if else语句。</p><p style=\"text-align: justify\">首先看一个我个人认为不好的代码风格：</p><p></p><pre class=\"crayon-plain-tag\">int f(int a, int b)
{
  if (a &gt;= 1) {
    if (b &gt;= 1) {
      if (a &gt;= b) {
        //do sth
      } else {
        //error1
      }
    } else {
      //error2
    }
  } else {
    //error3
  }
}</pre><p></p><p style=\"text-align: justify\">这个函数的核心在于do sth部分。其实我们可以改写为级联if－else形式，如下：</p><p></p><pre class=\"crayon-plain-tag\">int f(int a, int b)
{
  if (a &lt; 1) {
    //error3
  } else if (b &lt; 1) {
    //error2
  } else if (a &lt; b) {
    //error1
  } else {
    //so, a&gt;=1 &amp;&amp; b&gt;=1 &amp;&amp; a&gt;=b
    //do sth
  }
}</pre><p></p><p style=\"text-align: justify\">是不是优美多了？前面只做一些错误处理、前期准备、参数检查等，最后的else分支做实实在在的功能性事情。</p><h2 id=\"code-review\" style=\"text-align: justify\">Code Review</h2><h3 id=\"code-review-1\" style=\"text-align: justify\">什么是Code Review？</h3><p style=\"text-align: justify\">很多人把它翻译为代码审查，我觉得太政治味了。程序员尤其是新手写完代码后，可能会有风格问题（比如不符合团队的代码规范）、安全性问题(比如忘记指针判空)、优雅性问题(比如大量冗余代码)、正确性问题（比如算法设计错误），那么在发布代码到公共库之前，提交给师兄或者mentor，让他帮你review一下代码，并提出可能的问题和建议，让你好好修改。这样的过程，就叫做Code Review。</p><h3 id=\"section-5\" style=\"text-align: justify\">我的天呐，那这不是很占用时间？</h3><p style=\"text-align: justify\">是的。一个写代码，一个看代码，看代码的时间可能并不比全新写一份代码少。那么，这又是何必呢？</p><p style=\"text-align: justify\">主要的原因有：</p><p style=\"text-align: justify\">1，review确实占用了开发时间，然而开发，或者说写代码，其实只占很少的时间比例。很多时间花在debug、调试、写文档、需求分析、设计算法、维护等等上。</p><p style=\"text-align: justify\">2，代码质量非常重要，这点时间投入是值得的。与其后期苦逼追bug，不如前期多投入点时间和人力。</p><p style=\"text-align: justify\">3，培养新人，让新手更快成长。</p><h3 id=\"code-review-2\" style=\"text-align: justify\">如何更好的执行Code Review</h3><p style=\"text-align: justify\">这里给几点建议：</p><p style=\"text-align: justify\">1，不走过场。走过场，还不如不要这个流程。</p><p style=\"text-align: justify\">2，作为Reviewer，看不懂代码就把作者拉过来，当面询问，不要不懂装懂，也不要爱面子不好意思问。</p><p style=\"text-align: justify\">3，作为Coder，心里要有感激之情。真的。不要得了便宜还卖乖，感恩reviewer，感激reviewer对自己的进步和成长所做出的贡献，所花费的心血。中国人里狼心狗肺、忘恩负义、不懂感恩的人还算少吗？</p><p style=\"text-align: justify\">4，作为Coder，给Reviewer Review之前，请先做单元测试并确保通过，并自己尝试先整体看一遍自己本次提交的代码。注意，不要给别人提还没调试通过的代码，这是非常不尊重别人的表现。</p><h2 id=\"section-6\" style=\"text-align: justify\">质量保证</h2><p style=\"text-align: justify\">1，测试不是专属QA的活儿，对自己写的代码提供质量保证，是程序员的职责。QA要负责的，是系统的质量，不是模块的质量。</p><p style=\"text-align: justify\">2，测试，需要意识，需要坚持。我发现C++程序员、前端程序员的测试意识或者说质量意识最强；数据科学家或者数据工程师的质量意识最差，很多人甚至不写测试用例。当然，这不怪他们，毕竟，有时候代码里有个bug，准确率和召回率会更高。</p><p style=\"text-align: justify\">3，测试用例的编写和设计需要保证一定的代码覆盖率，力求让每个分支和流程的代码都走到，然后分析运行结果是否是符合期望的，不要只考虑正确路径上的那些分支。</p><p style=\"text-align: justify\">4，测试用例的编写和设计力求全面，考虑到方方面面。以非常经典的二分搜索为例：</p><p style=\"text-align: justify\">int binary_search(int *p, int n, int target, int &amp;idx);</p><p style=\"text-align: justify\">binary_search函数返回值为0表示成功执行，输出参数idx返回target在有序数组p中(第一次出现)的位置，－1表示不存在。</p><p style=\"text-align: justify\">那么测试用例至少应该涵盖：</p><ul style=\"text-align: justify\"><li>p为NULL的情况</li><li>数组大小n分别为负数、0、1、2时情况</li><li>数组p不是有序数组的情况</li><li>target在数组中出现0次、1次、n次的情况</li></ul><p style=\"text-align: justify\">你是否都考虑到了呢？</p><p style=\"text-align: justify\">4，有时候，自己书写测试用例显得刀耕火种，现在已经有很多辅助的工具，读者可以自行google一下。</p><div class=\"wp_rp_wrap  wp_rp_plain\" id=\"wp_rp_first\"><div class=\"wp_rp_content\"><h3 class=\"related_post_title\">相关文章</h3><ul class=\"related_post wp_rp\" style=\"visibility: visible\"><li ><a href=\"http://blog.jobbole.com/104042/\" class=\"wp_rp_title\">如何在 Linux 下检测内存泄漏</a></li><li ><a href=\"http://blog.jobbole.com/103102/\" class=\"wp_rp_title\">C++虚表，你搞懂了吗？</a></li><li ><a href=\"http://blog.jobbole.com/93699/\" class=\"wp_rp_title\">趣文：C++ 程序员离职之前要做的事</a></li><li ><a href=\"http://blog.jobbole.com/88050/\" class=\"wp_rp_title\">Notepad++源码编译及其分析</a></li><li ><a href=\"http://blog.jobbole.com/103669/\" class=\"wp_rp_title\">C++11 中的 Defaulted 和 Deleted 函数</a></li><li ><a href=\"http://blog.jobbole.com/36088/\" class=\"wp_rp_title\">你可能不知道的陷阱：C#委托和事件的困惑</a></li><li ><a href=\"http://blog.jobbole.com/87586/\" class=\"wp_rp_title\">标准模板库（STL）使用入门（上）</a></li><li ><a href=\"http://blog.jobbole.com/101441/\" class=\"wp_rp_title\">漫谈 C++：良好的编程习惯与编程要点</a></li><li ><a href=\"http://blog.jobbole.com/83497/\" class=\"wp_rp_title\">在C++中实现Python的切片</a></li><li ><a href=\"http://blog.jobbole.com/82628/\" class=\"wp_rp_title\">C++之父：C++ 的五个普遍误解（3）</a></li></ul></div></div><p><a href=\"http://blog.jobbole.com/104080/\">编写高质量代码</a>，首发于<a href=\"http://blog.jobbole.com\">文章 - 伯乐在线</a>。</p>") (wfw:commentRss nil "http://blog.jobbole.com/104080/feed/") (slash:comments nil "0"))) ("NASA 的 10 大编程规则" "<p>大型复杂的软件项目会使用某种编程标准或准则。这些准则组成了软件编写的基本规则。</p><ul><li>代码应该如何组织？</li><li>应该以及不应该使用哪些语言特征？</li></ul><p>为了确保有效，这些规则要简短并且足够具体，以便理解和记忆。</p><p>那些为 NASA 工作的世界顶级程序员，在开发安全关键代码的时候遵守着一套准则。实际上包括 NASA 的喷气推进实验室（ NASA’s Jet Propulsion Laboratory ，JPL）在内的很多组织，主要使用 C 语言进行代码编写。</p><p>原因是，C 语言有大量的支持性工具，包括逻辑模型提取器、调试器、稳定的编译环境，以及在代码分析器和度量工具上拥有强大的资源。</p><p>有时候非常有必要遵循编程规则，特别是当代码的正确性与你的生活息息相关的时候 — 用来控制你乘坐的飞机的代码，用来控制将宇航员送入轨道的太空船的代码，或者用来控制你家几英里远的核电站的代码。这里介绍的 NASA 的 10 大编程规则，主要偏重于安全参数，这 10 大规则是由 NASA 喷气推进实验室（JPL）的首席科学家 Gerard J. Holzmann 提出的。这些准则也可以用于其他编程语言。</p><p><img id=\"pic\" class=\" \" src=\"http://ww3.sinaimg.cn/large/7cc829d3gw1f6ddtv31s1j20lc09yabi.jpg\" /></p><h3>第 1 条规则 — 简单的控制流</h3><p>用非常简单的控制流结构体来编写程序 — 不要用 setjmp 或者 longjmp 结构体，goto 语句，以及直接或间接的递归调用。</p><p><b></b><strong>理由：</strong>简单的控制流能够提高代码的清晰度以及拥有更强大的验证能力。不使用递归，就不会产生循环函数调用关系图，同时这也证明应该是有界的执行过程确实是有界的。</p><h3>第 2 条规则 — 循环设置固定的上限</h3><p>所有的循环必须有一个固定的上限。对于检查工具来说，在给定循环次数的情况下，可以通过静态分析证实循环结果不超过预设的上限。如果工具不能静态检测出循环上限，那么这条规则就不适用。</p><p><b></b><strong>理由：</strong>设置循环边界、不使用递归能够阻止代码失控。但是这个原则并不适用于迭代，迭代意味着无穷无尽（比如进程调度）。 这种情况下就该使用相反的规则 — 必须可以静态地检测到迭代不会终止。</p><h3>第 3 条规则 — 没有动态内存分配</h3><p>初始化之后不要使用动态内存分配。</p><p><b></b><strong>理由：</strong>内存分配运算符比如 malloc 以及 garbage collectors 通常伴有不可预测的行为，这些行为会严重影响性能。甚至还可能因为程序员的错误而发生内存错误，包括：</p><ul><li>试图分配比物理内存更多的内存空间</li><li>忘记释放内存</li><li>继续使用已经释放了的内存</li><li>超出内存分配的边界</li></ul><p>将所有的模块强制存放在固定的、预先分配的内存空间中，可以消除这类问题，同时验证内存的使用情况也会更加容易。</p><p>在堆中内存分配不足的情况下进行动态申请内存的一种方法是使用栈内存。</p><h3>第 4 条规则 — 没有大函数</h3><p>如果以一行一条声明和一行一条语句这样标准的格式来写，那么函数的长度不应该超过一张纸。这也就是说一个函数不应该超过 60 行代码。</p><p><b></b><strong>理由：</strong>冗长的函数通常等于糟糕的代码结构。每个函数应该是一个易懂可证实的逻辑单元。而理解一个多屏幕长的逻辑单元是很困难的。</p><h3>第 5 条原则 — 低断言使用密度</h3><p>代码断言的密度应该低至平均每个函数两个。断言是用来检查现实执行中不会发生的不正常情况。它应该被定义为布尔测试。当断言失败，应当立即采取恢复措施。</p><p>如果静态检测工具证明断言永远不会失败或者条件永远不为真，这条规则就无效。</p><p><b></b><strong>理由：</strong>工业编码工作统计显示，单元测试中每 10 到 100 行代码至少发现一个代码瑕疵。随着断言的密度增长，有瑕疵的代码被拦截的几率越大。作为强大的防御型代码策略，断言的使用也是非常重要的。断言可以用来验证函数的前后条件、参数以及函数和循环不变式的返回值。在测试完效率关键代码后，断言可以选择性地禁用。</p><h3>第 6 条规则 — 最小范围内声明数据对象</h3><p>这条规则支持数据隐藏的基本原则。所有的数据对象必须在尽可能最小范围内声明。</p><p><b></b><strong>理由：</strong>如果一个对象不在该范围内，其值也不能被引用或者销毁。这条规则阻止了变量的重复和冲突性的使用，这些行为会使错误诊断更加复杂。</p><h3>第 7 条规则 — 检查参数和返回值</h3><p>当函数的返回值为非空的时候，每次函数调用都应该检查其返回值，并且每个被调用的函数还要检查所带参数的有效性。</p><p>在最严格的模式下，这条规则意味着printf和文件关闭语句的返回值也要检查</p><p><b></b><strong>理由：</strong>如果一个错误的返回值和一个正确的返回值没有什么区别的话，这个时候就有必要精确检查返回值。在函数中有调用 close 和 prinf 语句的情况下，函数返回值是 void 能够被接受，表明程序员故意（并且不是偶然）忽略返回值。</p><h3>第 8 条规则 — 限制使用预处理器</h3><p>预处理器的使用应该限制在头文件和宏定义中。不允许使用递归宏调用，拼接符和可变参数列表。即使在大型程序的开发工作中，如果使用了超过一两个条件编译指令必须要有充足的理由，这么做超出了统一的代码标准，同样也是为了避免同样的头文件包含多重释义。每次这么做必须在代码中要有由基于工具的检查器进行标记并且要有充分的理由。</p><p><b></b><strong>理由：</strong>C 语言的预处理器是一个非常强大并且难懂的工具，它能够破坏代码的清晰性并迷惑基于文本的检查器。即使手上有正式语言定义，在无尽的预处理器代码中，代码的结构也是很难理解的。</p><p>条件编译也同样需要谨慎，10 个条件编译指令代码中就会有 1024（2^10）个不同版本的代码，这也增加了测试的工作量。</p><h3>第 9 条规则 — 限制使用指针</h3><p>必须要限制指针的使用。最多只允许使用一级指针解引用。指针解引用操作不可以隐藏在类型声明或宏定义中。还有，不允许使用函数指针。</p><p><b></b><strong>理由：</strong>即使是专家，也很容易误用指针。指针使得它们（尤其是基于工具的静态分析器）很难跟踪或分析程序中的数据流。函数指针还限制了静态分析器的检查类型，只有在理由非常充分的情况才能使用函数指针。如果使用函数指针，几乎不可能使用工具来证明缺少的递归，所以必须有足以弥补这部分缺失的分析能力的替代方法。</p><h3>第 10 条规则 — 所有代码必须能编译通过</h3><p>从开发的第一天起，所有的代码都必须通过编译。所有的编译器警告必须遵循编译器可使用警告。在编译器可使用警告范围内，编译的代码必须没有警告。</p><p>所有代码必须每天至少使用一个（最好多于一个）最新的静态源代码分析器进行检查，而且以0警告通过所有的分析。</p><p><b></b><strong>理由：</strong>市场上有很多相当有效的源代码分析软件，其中一些还是免费的。软件开发项目没有任何理由不去使用这个现成的技术</p><p>如果编译器或者分析器被搞混淆了（报出错误的警告），那么应该重写使其混淆的这部分代码。</p><p><b></b><strong>NASA 是这么评价这些规则的：</strong></p><blockquote><p>“它们就像车里的安全带：刚开始用会有点不舒服，但是过了一段时间就会成为一种习惯，你会无法想象不使用它们的日子。”</p></blockquote><div class=\"wp_rp_wrap  wp_rp_plain\" ><div class=\"wp_rp_content\"><h3 class=\"related_post_title\">相关文章</h3><ul class=\"related_post wp_rp\" style=\"visibility: visible\"><li ><a href=\"http://blog.jobbole.com/70604/\" class=\"wp_rp_title\">Hello World：美用激光束从太空传回高清视频</a></li><li ><a href=\"http://blog.jobbole.com/75812/\" class=\"wp_rp_title\">21个挑战题，几杯咖啡的时间，来试试</a></li><li ><a href=\"http://blog.jobbole.com/42886/\" class=\"wp_rp_title\">编程从业5年总结的14条经验</a></li><li ><a href=\"http://blog.jobbole.com/101161/\" class=\"wp_rp_title\">.NET 编程基础知识</a></li><li ><a href=\"http://blog.jobbole.com/15801/\" class=\"wp_rp_title\">也谈编程改革</a></li><li ><a href=\"http://blog.jobbole.com/98633/\" class=\"wp_rp_title\">StackOverflow 这么大，它的架构是怎么样的？</a></li><li ><a href=\"http://blog.jobbole.com/18144/\" class=\"wp_rp_title\">张砷镓：我所信奉的编程哲学 </a></li><li ><a href=\"http://blog.jobbole.com/98541/\" class=\"wp_rp_title\">Facebook 工程师是如何高效工作的？</a></li><li ><a href=\"http://blog.jobbole.com/26294/\" class=\"wp_rp_title\">把 hello 打印 10 次</a></li><li ><a href=\"http://blog.jobbole.com/100737/\" class=\"wp_rp_title\">编程超过 30 年，我是如何避开倦怠期的？</a></li></ul></div></div><p><a href=\"http://blog.jobbole.com/104016/\">NASA 的 10 大编程规则</a>，首发于<a href=\"http://blog.jobbole.com\">文章 - 伯乐在线</a>。</p>" "http://blog.jobbole.com/104016/" (22431 29433) old 9 nil nil ((title nil "NASA 的 10 大编程规则") (link nil "http://blog.jobbole.com/104016/") (comments nil "http://blog.jobbole.com/104016/#comments") (pubDate nil "Mon, 01 Aug 2016 16:04:09 +0000") (dc:creator nil "西西里的仔仔") (category nil "开发") (category nil "NASA") (category nil "编程") (guid ((isPermaLink . "false")) "http://blog.jobbole.com/?p=104016") (description nil "<p>那些为 NASA 工作的世界顶级程序员，在开发安全关键代码的时候遵守着一套准则。它们就像车里的安全带：刚开始用会有点不舒服，但是过了一段时间就会成为一种习惯，你会无法想象不使用它们的日子。</p><p><a href=\"http://blog.jobbole.com/104016/\">NASA 的 10 大编程规则</a>，首发于<a href=\"http://blog.jobbole.com\">文章 - 伯乐在线</a>。</p>") (content:encoded nil "<p>大型复杂的软件项目会使用某种编程标准或准则。这些准则组成了软件编写的基本规则。</p><ul><li>代码应该如何组织？</li><li>应该以及不应该使用哪些语言特征？</li></ul><p>为了确保有效，这些规则要简短并且足够具体，以便理解和记忆。</p><p>那些为 NASA 工作的世界顶级程序员，在开发安全关键代码的时候遵守着一套准则。实际上包括 NASA 的喷气推进实验室（ NASA’s Jet Propulsion Laboratory ，JPL）在内的很多组织，主要使用 C 语言进行代码编写。</p><p>原因是，C 语言有大量的支持性工具，包括逻辑模型提取器、调试器、稳定的编译环境，以及在代码分析器和度量工具上拥有强大的资源。</p><p>有时候非常有必要遵循编程规则，特别是当代码的正确性与你的生活息息相关的时候 — 用来控制你乘坐的飞机的代码，用来控制将宇航员送入轨道的太空船的代码，或者用来控制你家几英里远的核电站的代码。这里介绍的 NASA 的 10 大编程规则，主要偏重于安全参数，这 10 大规则是由 NASA 喷气推进实验室（JPL）的首席科学家 Gerard J. Holzmann 提出的。这些准则也可以用于其他编程语言。</p><p><img id=\"pic\" class=\" \" src=\"http://ww3.sinaimg.cn/large/7cc829d3gw1f6ddtv31s1j20lc09yabi.jpg\" /></p><h3>第 1 条规则 — 简单的控制流</h3><p>用非常简单的控制流结构体来编写程序 — 不要用 setjmp 或者 longjmp 结构体，goto 语句，以及直接或间接的递归调用。</p><p><b></b><strong>理由：</strong>简单的控制流能够提高代码的清晰度以及拥有更强大的验证能力。不使用递归，就不会产生循环函数调用关系图，同时这也证明应该是有界的执行过程确实是有界的。</p><h3>第 2 条规则 — 循环设置固定的上限</h3><p>所有的循环必须有一个固定的上限。对于检查工具来说，在给定循环次数的情况下，可以通过静态分析证实循环结果不超过预设的上限。如果工具不能静态检测出循环上限，那么这条规则就不适用。</p><p><b></b><strong>理由：</strong>设置循环边界、不使用递归能够阻止代码失控。但是这个原则并不适用于迭代，迭代意味着无穷无尽（比如进程调度）。 这种情况下就该使用相反的规则 — 必须可以静态地检测到迭代不会终止。</p><h3>第 3 条规则 — 没有动态内存分配</h3><p>初始化之后不要使用动态内存分配。</p><p><b></b><strong>理由：</strong>内存分配运算符比如 malloc 以及 garbage collectors 通常伴有不可预测的行为，这些行为会严重影响性能。甚至还可能因为程序员的错误而发生内存错误，包括：</p><ul><li>试图分配比物理内存更多的内存空间</li><li>忘记释放内存</li><li>继续使用已经释放了的内存</li><li>超出内存分配的边界</li></ul><p>将所有的模块强制存放在固定的、预先分配的内存空间中，可以消除这类问题，同时验证内存的使用情况也会更加容易。</p><p>在堆中内存分配不足的情况下进行动态申请内存的一种方法是使用栈内存。</p><h3>第 4 条规则 — 没有大函数</h3><p>如果以一行一条声明和一行一条语句这样标准的格式来写，那么函数的长度不应该超过一张纸。这也就是说一个函数不应该超过 60 行代码。</p><p><b></b><strong>理由：</strong>冗长的函数通常等于糟糕的代码结构。每个函数应该是一个易懂可证实的逻辑单元。而理解一个多屏幕长的逻辑单元是很困难的。</p><h3>第 5 条原则 — 低断言使用密度</h3><p>代码断言的密度应该低至平均每个函数两个。断言是用来检查现实执行中不会发生的不正常情况。它应该被定义为布尔测试。当断言失败，应当立即采取恢复措施。</p><p>如果静态检测工具证明断言永远不会失败或者条件永远不为真，这条规则就无效。</p><p><b></b><strong>理由：</strong>工业编码工作统计显示，单元测试中每 10 到 100 行代码至少发现一个代码瑕疵。随着断言的密度增长，有瑕疵的代码被拦截的几率越大。作为强大的防御型代码策略，断言的使用也是非常重要的。断言可以用来验证函数的前后条件、参数以及函数和循环不变式的返回值。在测试完效率关键代码后，断言可以选择性地禁用。</p><h3>第 6 条规则 — 最小范围内声明数据对象</h3><p>这条规则支持数据隐藏的基本原则。所有的数据对象必须在尽可能最小范围内声明。</p><p><b></b><strong>理由：</strong>如果一个对象不在该范围内，其值也不能被引用或者销毁。这条规则阻止了变量的重复和冲突性的使用，这些行为会使错误诊断更加复杂。</p><h3>第 7 条规则 — 检查参数和返回值</h3><p>当函数的返回值为非空的时候，每次函数调用都应该检查其返回值，并且每个被调用的函数还要检查所带参数的有效性。</p><p>在最严格的模式下，这条规则意味着printf和文件关闭语句的返回值也要检查</p><p><b></b><strong>理由：</strong>如果一个错误的返回值和一个正确的返回值没有什么区别的话，这个时候就有必要精确检查返回值。在函数中有调用 close 和 prinf 语句的情况下，函数返回值是 void 能够被接受，表明程序员故意（并且不是偶然）忽略返回值。</p><h3>第 8 条规则 — 限制使用预处理器</h3><p>预处理器的使用应该限制在头文件和宏定义中。不允许使用递归宏调用，拼接符和可变参数列表。即使在大型程序的开发工作中，如果使用了超过一两个条件编译指令必须要有充足的理由，这么做超出了统一的代码标准，同样也是为了避免同样的头文件包含多重释义。每次这么做必须在代码中要有由基于工具的检查器进行标记并且要有充分的理由。</p><p><b></b><strong>理由：</strong>C 语言的预处理器是一个非常强大并且难懂的工具，它能够破坏代码的清晰性并迷惑基于文本的检查器。即使手上有正式语言定义，在无尽的预处理器代码中，代码的结构也是很难理解的。</p><p>条件编译也同样需要谨慎，10 个条件编译指令代码中就会有 1024（2^10）个不同版本的代码，这也增加了测试的工作量。</p><h3>第 9 条规则 — 限制使用指针</h3><p>必须要限制指针的使用。最多只允许使用一级指针解引用。指针解引用操作不可以隐藏在类型声明或宏定义中。还有，不允许使用函数指针。</p><p><b></b><strong>理由：</strong>即使是专家，也很容易误用指针。指针使得它们（尤其是基于工具的静态分析器）很难跟踪或分析程序中的数据流。函数指针还限制了静态分析器的检查类型，只有在理由非常充分的情况才能使用函数指针。如果使用函数指针，几乎不可能使用工具来证明缺少的递归，所以必须有足以弥补这部分缺失的分析能力的替代方法。</p><h3>第 10 条规则 — 所有代码必须能编译通过</h3><p>从开发的第一天起，所有的代码都必须通过编译。所有的编译器警告必须遵循编译器可使用警告。在编译器可使用警告范围内，编译的代码必须没有警告。</p><p>所有代码必须每天至少使用一个（最好多于一个）最新的静态源代码分析器进行检查，而且以0警告通过所有的分析。</p><p><b></b><strong>理由：</strong>市场上有很多相当有效的源代码分析软件，其中一些还是免费的。软件开发项目没有任何理由不去使用这个现成的技术</p><p>如果编译器或者分析器被搞混淆了（报出错误的警告），那么应该重写使其混淆的这部分代码。</p><p><b></b><strong>NASA 是这么评价这些规则的：</strong></p><blockquote><p>“它们就像车里的安全带：刚开始用会有点不舒服，但是过了一段时间就会成为一种习惯，你会无法想象不使用它们的日子。”</p></blockquote><div class=\"wp_rp_wrap  wp_rp_plain\" ><div class=\"wp_rp_content\"><h3 class=\"related_post_title\">相关文章</h3><ul class=\"related_post wp_rp\" style=\"visibility: visible\"><li ><a href=\"http://blog.jobbole.com/70604/\" class=\"wp_rp_title\">Hello World：美用激光束从太空传回高清视频</a></li><li ><a href=\"http://blog.jobbole.com/75812/\" class=\"wp_rp_title\">21个挑战题，几杯咖啡的时间，来试试</a></li><li ><a href=\"http://blog.jobbole.com/42886/\" class=\"wp_rp_title\">编程从业5年总结的14条经验</a></li><li ><a href=\"http://blog.jobbole.com/101161/\" class=\"wp_rp_title\">.NET 编程基础知识</a></li><li ><a href=\"http://blog.jobbole.com/15801/\" class=\"wp_rp_title\">也谈编程改革</a></li><li ><a href=\"http://blog.jobbole.com/98633/\" class=\"wp_rp_title\">StackOverflow 这么大，它的架构是怎么样的？</a></li><li ><a href=\"http://blog.jobbole.com/18144/\" class=\"wp_rp_title\">张砷镓：我所信奉的编程哲学 </a></li><li ><a href=\"http://blog.jobbole.com/98541/\" class=\"wp_rp_title\">Facebook 工程师是如何高效工作的？</a></li><li ><a href=\"http://blog.jobbole.com/26294/\" class=\"wp_rp_title\">把 hello 打印 10 次</a></li><li ><a href=\"http://blog.jobbole.com/100737/\" class=\"wp_rp_title\">编程超过 30 年，我是如何避开倦怠期的？</a></li></ul></div></div><p><a href=\"http://blog.jobbole.com/104016/\">NASA 的 10 大编程规则</a>，首发于<a href=\"http://blog.jobbole.com\">文章 - 伯乐在线</a>。</p>") (wfw:commentRss nil "http://blog.jobbole.com/104016/feed/") (slash:comments nil "1"))) ("计算机程序的思维逻辑 (2) ：赋值" "<p><strong>赋值</strong></p><p><a href=\"http://blog.jobbole.com/100329/\" target=\"_blank\">上节</a>我们说了数据类型和变量，通过声明变量，每个变量赋予一个数据类型和一个有意义的名字，我们就告诉了计算机我们要操作的数据。</p><p>有了数据，我们能做很多操作。但本文只说说对数据做的第一个操作：赋值。声明变量之后，就在内存分配了一块位置，但这个位置的内容是未知的，赋值就是把这块位置的内容设为一个确定的值。</p><p>Java中基本类型、数组、对象的赋值有明显不同，本文介绍基本类型和数组的赋值，关于对象后续文章会详述。</p><p>我们先来说基本类型的赋值，然后再说数组的赋值。</p><p><strong>基本类型的赋值</strong></p><p><strong>整数类型</strong></p><p>整数类型有byte, short, int和long，分别占用1/2/4/8个字节，取值范围分别是：</p><table><tbody><tr><td valign=\"top\" width=\"61\">类型名</td><td valign=\"top\" width=\"155\">取值范围</td></tr><tr><td valign=\"top\" width=\"61\">byte</td><td valign=\"top\" width=\"155\">-2^7 ~ 2^7-1</td></tr><tr><td valign=\"top\" width=\"61\">short</td><td valign=\"top\" width=\"155\">-2^15 ~ 2^15-1</td></tr><tr><td valign=\"top\" width=\"61\">int</td><td valign=\"top\" width=\"155\">-2^31 ~ 2^31-1</td></tr><tr><td valign=\"top\" width=\"61\">long</td><td valign=\"top\" width=\"155\">-2^63 ~ 2^63-1</td></tr></tbody></table><p>我们用^表示指数，2^7即2的7次方。这个范围我们不需要记的那么清楚，有个大概范围认识就可以了，大多数日常应用，一般用int就可以了。后续文章会从二进制的角度进一步分析表示范围为什么会是这样的。</p><p>赋值形式很简单，直接把熟悉的数字常量形式赋值给变量即可，对应的内存空间的值就从未知变成了确定的常量。但常量不能超过对应类型的表示范围。例如：</p><div><pre class=\"crayon-plain-tag\">byte b = 23;
short s = 3333;
int i = 9999;
long l = 32323;</pre></div><p>但是，在给long类型赋值时，如果常量超过了int的表示范围，需要在常量后面加大写或小写的L，即L或l，例如:</p><div><pre class=\"crayon-plain-tag\">long a = 3232343433L;</pre></div><p>这个是由于数字常量默认为是int类型。</p><p><strong>小数类型</strong></p><p>小数类型有float和double，占用的内存空间分别是4和8个字节，有不同的取值范围和精度，double表示的范围更大，精度更高，具体来说：</p><table><tbody><tr><td valign=\"top\" width=\"58\">类型名</td><td valign=\"top\" width=\"196\">取值范围</td></tr><tr><td valign=\"top\" width=\"58\">float</td><td valign=\"top\" width=\"196\">1.4E-45 ~ 3.4E+38</p><p>-3.4E+38 ~-1.4E-45</td></tr><tr><td valign=\"top\" width=\"58\">double</td><td valign=\"top\" width=\"196\">4.9E-324 ~1.7E+308</p><p>-1.7E+308 ~ -4.9E-324</td></tr></tbody></table><p>取值范围看上去很奇怪，一般我们也不需要记住，有个大概印象就可以了。E表示以10为底的指数，E后面的+号和-号代表正指数和负指数，例如：1.4E-45表示1.4乘以10的-45次方。后续文章会进一步分析小数的二进制表示。</p><p>对于double，直接把熟悉的小数表示赋值给变量即可，例如：</p><div><pre class=\"crayon-plain-tag\">double d = 333.33;</pre></div><p>但对于float，需要在数字后面加大写F或小写f，例如：</p><div><pre class=\"crayon-plain-tag\">float f = 333.33f;</pre></div><p>这个是由于小数常量默认为是double类型。</p><p>除了小数，也可以把整数直接赋值给float或double，例如：</p><div><pre class=\"crayon-plain-tag\">float f = 33;
double d = 3333333333333L;</pre></div><p><strong>boolean类型</strong></p><p>这个很简单，直接使用true或false赋值，分别表示真和假，例如：</p><div><pre class=\"crayon-plain-tag\">boolean b = true;
b = false;</pre></div><p><strong>字符类型</strong></p><p>字符类型char用于表示一个字符，这个字符可以是中文字符，也可以是英文字符。在内存中，Java用两个字节表示一个字符。赋值时把常量字符用单引号括起来，不要使用双引号，例如：</p><div><pre class=\"crayon-plain-tag\">char c = 'A';
char z = '中';</pre></div><p>关于字符类型有一些细节，后续文章会进一步深度解析。</p><p><strong>一些说明</strong><strong><br /></strong></p><p>上面介绍的赋值都是直接给变量设置一个常量值。但也可以把变量赋给变量，例如：</p><div><pre class=\"crayon-plain-tag\">int a = 100;
int b = a;</pre></div><p>变量可以进行各种运算（后续文章讲解），也可以将变量的运算结果赋给变量，例如：</p><div><pre class=\"crayon-plain-tag\">int a = 1;
int b = 2;
int c = 2*a+b; //2乘以a的值再加上b的值赋给c</pre></div><p>上面介绍的赋值都是在声明变量的时候就进行了赋值，但这不是必须的，可以先声明变量，随后再进行赋值。</p><p><strong>数组类型</strong></p><p><strong>赋值语法</strong></p><p>基本类型的数组有三种赋值形式，如下所示：</p><div><pre class=\"crayon-plain-tag\">1. int[] arr = {1,2,3};
2. int[] arr = new int[]{1,2,3};
3. int[] arr = new int[3];
arr[0]=1; arr[1]=2; arr[2]=3;</pre></div><p>第一种和第二种都是预先知道数组的内容，而第三种是先分配长度，然后再给每个元素赋值。</p><p>第三种形式中，即使没有给每个元素赋值，每个元素也都有一个默认值，这个默认值跟数组类型有关。数值类型的值为0，boolean为false, char为空字符。</p><p>数组长度可以动态确定，如下所示：</p><div><pre class=\"crayon-plain-tag\">int length = ... ;//根据一些条件动态计算
int arr = new int[length];</pre></div><p>虽然可以动态确定，但定了之后就不可以变，数组有一个length属性，但只能读，不能改。</p><p>一个小细节，不能在给定初始值的同时还给定长度，即如下格式是不允许的：</p><div><pre class=\"crayon-plain-tag\">int[] arr = new int[3]{1,2,3}</pre></div><p>这是可以理解的，因为初始值已经决定了长度，再给个长度，如果还不一致，计算机将无所适从。</p><p><strong>数组和基本类型的区别</strong></p><p>一个基本类型变量，内存中只会有一块对应的内存空间。但数组有两块，一块用于存储数组内容本身，另一块用于存储内容的位置。</p><p>用一个例子来说明，有一个int变量a，和一个int数组变量arr，其代码，变量对应的内存地址和内存内容如下所示：</p><table><tbody><tr><td valign=\"top\" width=\"123\">代码</td><td valign=\"top\" width=\"66\">内存地址</td><td valign=\"top\" width=\"77\">内存数据</td></tr><tr><td valign=\"top\" width=\"123\">int a = 100;</td><td valign=\"top\" width=\"66\">1000</td><td valign=\"top\" width=\"77\">100</td></tr><tr><td valign=\"top\" width=\"123\">int[] arr = {1,2,3};</td><td valign=\"top\" width=\"66\">2000</td><td valign=\"top\" width=\"77\">3000</td></tr><tr><td valign=\"top\" width=\"123\"></td><td valign=\"top\" width=\"66\">3000</td><td valign=\"top\" width=\"77\">1</td></tr><tr><td valign=\"top\" width=\"123\"></td><td valign=\"top\" width=\"66\">3004</td><td valign=\"top\" width=\"77\">2</td></tr><tr><td colspan=\"1\" rowspan=\"1\" valign=\"top\" width=\"123\"></td><td colspan=\"1\" rowspan=\"1\" valign=\"top\" width=\"66\">3008</td><td colspan=\"1\" rowspan=\"1\" valign=\"top\" width=\"77\">3</td></tr></tbody></table><p>基本类型a的内存地址是1000，这个位置存储的就是它的值100。</p><p>数组类型arr的内存地址是2000，这个位置存储的值是一个位置3000，3000开始的位置存储的才是实际的数据1,2,3。</p><p><strong>为什么数组要用两块空间</strong></p><p>不能只用一块空间吗？我们来看下面这个代码：</p><div><pre class=\"crayon-plain-tag\">int[] arrA = {1,2,3};
int[] arrB = {4,5,6,7};
arrA = arrB;</pre></div><p>这个代码中，arrA初始的长度是3，arrB的长度是4，后来将arrB的值赋给了arrA。如果arrA对应的内存空间是直接存储的数组内容，那么它将没有足够的空间去容纳arrB的所有元素。</p><p>用两块空间存储，这个就简单的多，arrA存储的值就变成了和arrB的一样，存储的都是数组内容{4,5,6,7}的地址，此后访问arrA就和arrB是一样的了，而arrA {1,2,3}的内存空间由于无人引用会被垃圾回收，如下所示：</p><blockquote><p>arrA        {1,2,3}</p><p>\\</p><p>\\</p><p>arrB  -&gt;  {4,5,6,7}</p></blockquote><p>由上，也可以看出，给数组变量赋值和给数组中元素赋值是两回事。给数组中元素赋值是改变数组内容，而给数组变量赋值则会让变量指向一个不同的位置。</p><p>上面我们说数组的长度是不可以变的，不可变指的是数组的内容空间，一经分配，长度就不能再变了，但是可以改变数组变量的值，让它指向一个长度不同的空间，就像上例中arrA后来指向了arrB一样。</p><p><strong>小结</strong></p><p>给变量赋值就是将变量对应的内存空间设置为一个明确的值，有了值之后，变量可以被加载到CPU，CPU可以对这些值进行各种运算，运算后的结果又可以被赋值给变量，保存到内存中。</p><p>数据可以进行哪些运算？如何进行运算呢？</p><div class=\"wp_rp_wrap  wp_rp_plain\" ><div class=\"wp_rp_content\"><h3 class=\"related_post_title\">相关文章</h3><ul class=\"related_post wp_rp\" style=\"visibility: visible\"><li ><a href=\"http://blog.jobbole.com/98633/\" class=\"wp_rp_title\">StackOverflow 这么大，它的架构是怎么样的？</a></li><li ><a href=\"http://blog.jobbole.com/99151/\" class=\"wp_rp_title\">聊聊创业团队的项目管理如何面向开发人员优化</a></li><li ><a href=\"http://blog.jobbole.com/102415/\" class=\"wp_rp_title\">DNS 原理入门</a></li><li ><a href=\"http://blog.jobbole.com/101136/\" class=\"wp_rp_title\">坐在马桶上看算法（9）：巧妙的邻接表</a></li><li ><a href=\"http://blog.jobbole.com/100081/\" class=\"wp_rp_title\">MySQL 读写分离介绍及搭建</a></li><li ><a href=\"http://blog.jobbole.com/100346/\" class=\"wp_rp_title\">浅谈并发与并行（1）</a></li><li ><a href=\"http://blog.jobbole.com/100361/\" class=\"wp_rp_title\">最快最简单的排序算法：桶排序</a></li><li ><a href=\"http://blog.jobbole.com/100631/\" class=\"wp_rp_title\">坐在马桶上看算法（4）：小哼买书</a></li><li ><a href=\"http://blog.jobbole.com/103456/\" class=\"wp_rp_title\">八大排序算法</a></li><li ><a href=\"http://blog.jobbole.com/101231/\" class=\"wp_rp_title\">如何写出正确的二分法以及分析</a></li></ul></div></div><p><a href=\"http://blog.jobbole.com/100330/\">计算机程序的思维逻辑 (2) ：赋值</a>，首发于<a href=\"http://blog.jobbole.com\">文章 - 伯乐在线</a>。</p>" "http://blog.jobbole.com/100330/" (22431 3443) old 10 nil nil ((title nil "计算机程序的思维逻辑 (2) ：赋值") (link nil "http://blog.jobbole.com/100330/") (comments nil "http://blog.jobbole.com/100330/#respond") (pubDate nil "Mon, 01 Aug 2016 08:50:59 +0000") (dc:creator nil "老马") (category nil "IT技术") (category nil "赋值") (guid ((isPermaLink . "false")) "http://blog.jobbole.com/?p=100330") (description nil "<p>上节我们说了数据类型和变量，通过声明变量，每个变量赋予一个数据类型和一个有意义的名字，我们就告诉了计算机我们要操作的数据。

有了数据，我们能做很多操作。但本文只说说对数据做的第一个操作：赋值。</p><p><a href=\"http://blog.jobbole.com/100330/\">计算机程序的思维逻辑 (2) ：赋值</a>，首发于<a href=\"http://blog.jobbole.com\">文章 - 伯乐在线</a>。</p>") (content:encoded nil "<p><strong>赋值</strong></p><p><a href=\"http://blog.jobbole.com/100329/\" target=\"_blank\">上节</a>我们说了数据类型和变量，通过声明变量，每个变量赋予一个数据类型和一个有意义的名字，我们就告诉了计算机我们要操作的数据。</p><p>有了数据，我们能做很多操作。但本文只说说对数据做的第一个操作：赋值。声明变量之后，就在内存分配了一块位置，但这个位置的内容是未知的，赋值就是把这块位置的内容设为一个确定的值。</p><p>Java中基本类型、数组、对象的赋值有明显不同，本文介绍基本类型和数组的赋值，关于对象后续文章会详述。</p><p>我们先来说基本类型的赋值，然后再说数组的赋值。</p><p><strong>基本类型的赋值</strong></p><p><strong>整数类型</strong></p><p>整数类型有byte, short, int和long，分别占用1/2/4/8个字节，取值范围分别是：</p><table><tbody><tr><td valign=\"top\" width=\"61\">类型名</td><td valign=\"top\" width=\"155\">取值范围</td></tr><tr><td valign=\"top\" width=\"61\">byte</td><td valign=\"top\" width=\"155\">-2^7 ~ 2^7-1</td></tr><tr><td valign=\"top\" width=\"61\">short</td><td valign=\"top\" width=\"155\">-2^15 ~ 2^15-1</td></tr><tr><td valign=\"top\" width=\"61\">int</td><td valign=\"top\" width=\"155\">-2^31 ~ 2^31-1</td></tr><tr><td valign=\"top\" width=\"61\">long</td><td valign=\"top\" width=\"155\">-2^63 ~ 2^63-1</td></tr></tbody></table><p>我们用^表示指数，2^7即2的7次方。这个范围我们不需要记的那么清楚，有个大概范围认识就可以了，大多数日常应用，一般用int就可以了。后续文章会从二进制的角度进一步分析表示范围为什么会是这样的。</p><p>赋值形式很简单，直接把熟悉的数字常量形式赋值给变量即可，对应的内存空间的值就从未知变成了确定的常量。但常量不能超过对应类型的表示范围。例如：</p><div><pre class=\"crayon-plain-tag\">byte b = 23;
short s = 3333;
int i = 9999;
long l = 32323;</pre></div><p>但是，在给long类型赋值时，如果常量超过了int的表示范围，需要在常量后面加大写或小写的L，即L或l，例如:</p><div><pre class=\"crayon-plain-tag\">long a = 3232343433L;</pre></div><p>这个是由于数字常量默认为是int类型。</p><p><strong>小数类型</strong></p><p>小数类型有float和double，占用的内存空间分别是4和8个字节，有不同的取值范围和精度，double表示的范围更大，精度更高，具体来说：</p><table><tbody><tr><td valign=\"top\" width=\"58\">类型名</td><td valign=\"top\" width=\"196\">取值范围</td></tr><tr><td valign=\"top\" width=\"58\">float</td><td valign=\"top\" width=\"196\">1.4E-45 ~ 3.4E+38</p><p>-3.4E+38 ~-1.4E-45</td></tr><tr><td valign=\"top\" width=\"58\">double</td><td valign=\"top\" width=\"196\">4.9E-324 ~1.7E+308</p><p>-1.7E+308 ~ -4.9E-324</td></tr></tbody></table><p>取值范围看上去很奇怪，一般我们也不需要记住，有个大概印象就可以了。E表示以10为底的指数，E后面的+号和-号代表正指数和负指数，例如：1.4E-45表示1.4乘以10的-45次方。后续文章会进一步分析小数的二进制表示。</p><p>对于double，直接把熟悉的小数表示赋值给变量即可，例如：</p><div><pre class=\"crayon-plain-tag\">double d = 333.33;</pre></div><p>但对于float，需要在数字后面加大写F或小写f，例如：</p><div><pre class=\"crayon-plain-tag\">float f = 333.33f;</pre></div><p>这个是由于小数常量默认为是double类型。</p><p>除了小数，也可以把整数直接赋值给float或double，例如：</p><div><pre class=\"crayon-plain-tag\">float f = 33;
double d = 3333333333333L;</pre></div><p><strong>boolean类型</strong></p><p>这个很简单，直接使用true或false赋值，分别表示真和假，例如：</p><div><pre class=\"crayon-plain-tag\">boolean b = true;
b = false;</pre></div><p><strong>字符类型</strong></p><p>字符类型char用于表示一个字符，这个字符可以是中文字符，也可以是英文字符。在内存中，Java用两个字节表示一个字符。赋值时把常量字符用单引号括起来，不要使用双引号，例如：</p><div><pre class=\"crayon-plain-tag\">char c = 'A';
char z = '中';</pre></div><p>关于字符类型有一些细节，后续文章会进一步深度解析。</p><p><strong>一些说明</strong><strong><br /></strong></p><p>上面介绍的赋值都是直接给变量设置一个常量值。但也可以把变量赋给变量，例如：</p><div><pre class=\"crayon-plain-tag\">int a = 100;
int b = a;</pre></div><p>变量可以进行各种运算（后续文章讲解），也可以将变量的运算结果赋给变量，例如：</p><div><pre class=\"crayon-plain-tag\">int a = 1;
int b = 2;
int c = 2*a+b; //2乘以a的值再加上b的值赋给c</pre></div><p>上面介绍的赋值都是在声明变量的时候就进行了赋值，但这不是必须的，可以先声明变量，随后再进行赋值。</p><p><strong>数组类型</strong></p><p><strong>赋值语法</strong></p><p>基本类型的数组有三种赋值形式，如下所示：</p><div><pre class=\"crayon-plain-tag\">1. int[] arr = {1,2,3};

2. int[] arr = new int[]{1,2,3};

3. int[] arr = new int[3];
    arr[0]=1; arr[1]=2; arr[2]=3;</pre></div><p>第一种和第二种都是预先知道数组的内容，而第三种是先分配长度，然后再给每个元素赋值。</p><p>第三种形式中，即使没有给每个元素赋值，每个元素也都有一个默认值，这个默认值跟数组类型有关。数值类型的值为0，boolean为false, char为空字符。</p><p>数组长度可以动态确定，如下所示：</p><div><pre class=\"crayon-plain-tag\">int length = ... ;//根据一些条件动态计算
int arr = new int[length];</pre></div><p>虽然可以动态确定，但定了之后就不可以变，数组有一个length属性，但只能读，不能改。</p><p>一个小细节，不能在给定初始值的同时还给定长度，即如下格式是不允许的：</p><div><pre class=\"crayon-plain-tag\">int[] arr = new int[3]{1,2,3}</pre></div><p>这是可以理解的，因为初始值已经决定了长度，再给个长度，如果还不一致，计算机将无所适从。</p><p><strong>数组和基本类型的区别</strong></p><p>一个基本类型变量，内存中只会有一块对应的内存空间。但数组有两块，一块用于存储数组内容本身，另一块用于存储内容的位置。</p><p>用一个例子来说明，有一个int变量a，和一个int数组变量arr，其代码，变量对应的内存地址和内存内容如下所示：</p><table><tbody><tr><td valign=\"top\" width=\"123\">代码</td><td valign=\"top\" width=\"66\">内存地址</td><td valign=\"top\" width=\"77\">内存数据</td></tr><tr><td valign=\"top\" width=\"123\">int a = 100;</td><td valign=\"top\" width=\"66\">1000</td><td valign=\"top\" width=\"77\">100</td></tr><tr><td valign=\"top\" width=\"123\">int[] arr = {1,2,3};</td><td valign=\"top\" width=\"66\">2000</td><td valign=\"top\" width=\"77\">3000</td></tr><tr><td valign=\"top\" width=\"123\"></td><td valign=\"top\" width=\"66\">3000</td><td valign=\"top\" width=\"77\">1</td></tr><tr><td valign=\"top\" width=\"123\"></td><td valign=\"top\" width=\"66\">3004</td><td valign=\"top\" width=\"77\">2</td></tr><tr><td colspan=\"1\" rowspan=\"1\" valign=\"top\" width=\"123\"></td><td colspan=\"1\" rowspan=\"1\" valign=\"top\" width=\"66\">3008</td><td colspan=\"1\" rowspan=\"1\" valign=\"top\" width=\"77\">3</td></tr></tbody></table><p>基本类型a的内存地址是1000，这个位置存储的就是它的值100。</p><p>数组类型arr的内存地址是2000，这个位置存储的值是一个位置3000，3000开始的位置存储的才是实际的数据1,2,3。</p><p><strong>为什么数组要用两块空间</strong></p><p>不能只用一块空间吗？我们来看下面这个代码：</p><div><pre class=\"crayon-plain-tag\">int[] arrA = {1,2,3};

int[] arrB = {4,5,6,7};
arrA = arrB;</pre></div><p>这个代码中，arrA初始的长度是3，arrB的长度是4，后来将arrB的值赋给了arrA。如果arrA对应的内存空间是直接存储的数组内容，那么它将没有足够的空间去容纳arrB的所有元素。</p><p>用两块空间存储，这个就简单的多，arrA存储的值就变成了和arrB的一样，存储的都是数组内容{4,5,6,7}的地址，此后访问arrA就和arrB是一样的了，而arrA {1,2,3}的内存空间由于无人引用会被垃圾回收，如下所示：</p><blockquote><p>arrA        {1,2,3}</p><p>\\</p><p>\\</p><p>arrB  -&gt;  {4,5,6,7}</p></blockquote><p>由上，也可以看出，给数组变量赋值和给数组中元素赋值是两回事。给数组中元素赋值是改变数组内容，而给数组变量赋值则会让变量指向一个不同的位置。</p><p>上面我们说数组的长度是不可以变的，不可变指的是数组的内容空间，一经分配，长度就不能再变了，但是可以改变数组变量的值，让它指向一个长度不同的空间，就像上例中arrA后来指向了arrB一样。</p><p><strong>小结</strong></p><p>给变量赋值就是将变量对应的内存空间设置为一个明确的值，有了值之后，变量可以被加载到CPU，CPU可以对这些值进行各种运算，运算后的结果又可以被赋值给变量，保存到内存中。</p><p>数据可以进行哪些运算？如何进行运算呢？</p><div class=\"wp_rp_wrap  wp_rp_plain\" ><div class=\"wp_rp_content\"><h3 class=\"related_post_title\">相关文章</h3><ul class=\"related_post wp_rp\" style=\"visibility: visible\"><li ><a href=\"http://blog.jobbole.com/98633/\" class=\"wp_rp_title\">StackOverflow 这么大，它的架构是怎么样的？</a></li><li ><a href=\"http://blog.jobbole.com/99151/\" class=\"wp_rp_title\">聊聊创业团队的项目管理如何面向开发人员优化</a></li><li ><a href=\"http://blog.jobbole.com/102415/\" class=\"wp_rp_title\">DNS 原理入门</a></li><li ><a href=\"http://blog.jobbole.com/101136/\" class=\"wp_rp_title\">坐在马桶上看算法（9）：巧妙的邻接表</a></li><li ><a href=\"http://blog.jobbole.com/100081/\" class=\"wp_rp_title\">MySQL 读写分离介绍及搭建</a></li><li ><a href=\"http://blog.jobbole.com/100346/\" class=\"wp_rp_title\">浅谈并发与并行（1）</a></li><li ><a href=\"http://blog.jobbole.com/100361/\" class=\"wp_rp_title\">最快最简单的排序算法：桶排序</a></li><li ><a href=\"http://blog.jobbole.com/100631/\" class=\"wp_rp_title\">坐在马桶上看算法（4）：小哼买书</a></li><li ><a href=\"http://blog.jobbole.com/103456/\" class=\"wp_rp_title\">八大排序算法</a></li><li ><a href=\"http://blog.jobbole.com/101231/\" class=\"wp_rp_title\">如何写出正确的二分法以及分析</a></li></ul></div></div><p><a href=\"http://blog.jobbole.com/100330/\">计算机程序的思维逻辑 (2) ：赋值</a>，首发于<a href=\"http://blog.jobbole.com\">文章 - 伯乐在线</a>。</p>") (wfw:commentRss nil "http://blog.jobbole.com/100330/feed/") (slash:comments nil "0"))) ("JDK8 Stream API中Collectors中toMap方法的问题以及解决方案" "<p>使用Collectors.toMap方法时的两个问题：</p><p>1、当key重复时，会抛出异常：java.lang.IllegalStateException: Duplicate key **<br />
2、当value为null时，会抛出异常：java.lang.NullPointerException</p><p>首先这个不是JDK的bug，只是不符合我们的预期。</p><p>大家通常希望这个方法是可以容错的，遇到重复的key就使用后者替换，而且HashMap的value可以是null。</p><p>下面举个小例子。</p><p>首先是元素类Emp：</p><pre class=\"crayon-plain-tag\">public class Emp {
private Integer id;
private String name;
public Emp(Integer id, String name) {
super();
this.id = id;
this.name = name;
System.out.println(this);
}
public Integer getId() {
return id;
}
public String getName() {
return name;
}
@Override
public String toString() {
return \"id: \" + id + \", name: \" + name;
}
}</pre><p>然后是测试类：</p><pre class=\"crayon-plain-tag\">import java.util.Map;
import java.util.stream.Collectors;
import java.util.stream.IntStream;
import java.util.stream.Stream;
public class Test {
public static void main(String[] args) {
Emp[] emps = IntStream.range(0, 10).mapToObj(x -&gt; new Emp(x % 3, \"name\" + x))
.toArray(Emp[]::new);
Map&lt;Integer, String&gt; map = Stream.of(emps).collect(Collectors.toMap(Emp::getId, Emp::getName));
System.out.println(map);
}
}</pre><p>生成10个对象，其中id只能为0，1，2，用id做key，name做value，运行结果如下：</p><pre class=\"crayon-plain-tag\">id: 0, name: name0
id: 1, name: name1
id: 2, name: name2
id: 0, name: name3
id: 1, name: name4
id: 2, name: name5
id: 0, name: name6
id: 1, name: name7
id: 2, name: name8
id: 0, name: name9
Exception in thread \"main\" java.lang.IllegalStateException: Duplicate key name0
at java.util.stream.Collectors.lambda$throwingMerger$0(Collectors.java:133)
at java.util.HashMap.merge(HashMap.java:1253)
at java.util.stream.Collectors.lambda$toMap$58(Collectors.java:1320)
at java.util.stream.ReduceOps$3ReducingSink.accept(ReduceOps.java:169)
at java.util.Spliterators$ArraySpliterator.forEachRemaining(Spliterators.java:948)
at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:481)
at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:471)
at java.util.stream.ReduceOps$ReduceOp.evaluateSequential(ReduceOps.java:708)
at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)
at java.util.stream.ReferencePipeline.collect(ReferencePipeline.java:499)
at Test.main(Test.java:11)</pre><p>提示key重复了。</p><p>接下来看另一种情况：</p><pre class=\"crayon-plain-tag\">import java.util.Map;
import java.util.stream.Collectors;
import java.util.stream.IntStream;
import java.util.stream.Stream;
public class Test {
public static void main(String[] args) {
Emp[] emps = IntStream.range(0, 10).mapToObj(x -&gt; new Emp(x, x % 5 == 0 ? null : \"name\" + x))
.toArray(Emp[]::new);
Map&lt;Integer, String&gt; map = Stream.of(emps).collect(Collectors.toMap(Emp::getId, Emp::getName));
System.out.println(map);
}
}</pre><p>这个是让emps数组中出现两个value为null的元素，运行结果如下：</p><pre class=\"crayon-plain-tag\">id: 0, name: null
id: 1, name: name1
id: 2, name: name2
id: 3, name: name3
id: 4, name: name4
id: 5, name: null
id: 6, name: name6
id: 7, name: name7
id: 8, name: name8
id: 9, name: name9
Exception in thread \"main\" java.lang.NullPointerException
at java.util.HashMap.merge(HashMap.java:1224)
at java.util.stream.Collectors.lambda$toMap$58(Collectors.java:1320)
at java.util.stream.ReduceOps$3ReducingSink.accept(ReduceOps.java:169)
at java.util.Spliterators$ArraySpliterator.forEachRemaining(Spliterators.java:948)
at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:481)
at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:471)
at java.util.stream.ReduceOps$ReduceOp.evaluateSequential(ReduceOps.java:708)
at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)
at java.util.stream.ReferencePipeline.collect(ReferencePipeline.java:499)
at Test.main(Test.java:11)</pre><p>提示value是null。</p><p>这个是因为调用了HashMap的merge方法，方法不接受这种数据。因此需要手动实现，实现方式也很简单，只要调用map的put方法就可以了。</p><pre class=\"crayon-plain-tag\">import java.util.Collections;
import java.util.EnumSet;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;
import java.util.function.BiConsumer;
import java.util.function.BinaryOperator;
import java.util.function.Function;
import java.util.function.Supplier;
import java.util.stream.Collector;
public class ForceToMapCollector&lt;T, K, V&gt; implements Collector&lt;T, Map&lt;K, V&gt;, Map&lt;K, V&gt;&gt; {
private Function&lt;? super T, ? extends K&gt; keyMapper;
private Function&lt;? super T, ? extends V&gt; valueMapper;
public ForceToMapCollector(Function&lt;? super T, ? extends K&gt; keyMapper,
Function&lt;? super T, ? extends V&gt; valueMapper) {
super();
this.keyMapper = keyMapper;
this.valueMapper = valueMapper;
}
@Override
public BiConsumer&lt;Map&lt;K, V&gt;, T&gt; accumulator() {
return (map, element) -&gt; map.put(keyMapper.apply(element), valueMapper.apply(element));
}
@Override
public Supplier&lt;Map&lt;K, V&gt;&gt; supplier() {
return HashMap::new;
}
@Override
public BinaryOperator&lt;Map&lt;K, V&gt;&gt; combiner() {
return null;
}
@Override
public Function&lt;Map&lt;K, V&gt;, Map&lt;K, V&gt;&gt; finisher() {
return null;
}
@Override
public Set&lt;Characteristics&gt; characteristics() {
return Collections.unmodifiableSet(EnumSet.of(Collector.Characteristics.IDENTITY_FINISH));
}
}</pre><p></p><pre class=\"crayon-plain-tag\">import java.util.Map;
import java.util.function.Function;
import java.util.stream.Collector;
public final class MyCollectors {
public static &lt;T, K, V&gt; Collector&lt;T, ?, Map&lt;K, V&gt;&gt; toMap(Function&lt;T, K&gt; f1, Function&lt;T, V&gt; f2) {
return new ForceToMapCollector&lt;T, K, V&gt;(f1, f2);
}
}</pre><p>测试类如下：</p><pre class=\"crayon-plain-tag\">import java.util.Map;
import java.util.stream.IntStream;
import java.util.stream.Stream;
public class Test {
public static void main(String[] args) {
Emp[] emps = IntStream.range(0, 10).mapToObj(x -&gt; new Emp(x % 3, x % 5 == 0 ? null : \"name\" + x))
.toArray(Emp[]::new);
Map&lt;Integer, String&gt; map = Stream.of(emps).collect(MyCollectors.toMap(Emp::getId, Emp::getName));
System.out.println(map);
}
}</pre><p>包含了上面两种可能产生异常的情况，运行结果如下：</p><pre class=\"crayon-plain-tag\">id: 0, name: null
id: 1, name: name1
id: 2, name: name2
id: 0, name: name3
id: 1, name: name4
id: 2, name: null
id: 0, name: name6
id: 1, name: name7
id: 2, name: name8
id: 0, name: name9
{0=name9, 1=name7, 2=name8}</pre><p>解决了上面的问题，满足了容错需求。</p><p>由于Stream API用的不是很广泛，如果网友们有更好的实现方案，希望告知，多谢！</p><div class=\"wp_rp_wrap  wp_rp_plain\" ><div class=\"wp_rp_content\"><h3 class=\"related_post_title\">相关文章</h3><ul class=\"related_post wp_rp\" style=\"visibility: visible\"><li ><a href=\"http://blog.jobbole.com/90693/\" class=\"wp_rp_title\">ASP.NET MVC随想录（3）：创建自定义的Middleware中间件</a></li><li ><a href=\"http://blog.jobbole.com/79421/\" class=\"wp_rp_title\">Eric Raymond对于几大开发语言的评价</a></li><li ><a href=\"http://blog.jobbole.com/20400/\" class=\"wp_rp_title\">理解ThreadLocal</a></li><li ><a href=\"http://blog.jobbole.com/103325/\" class=\"wp_rp_title\">ThreadLocal 那点事儿</a></li><li ><a href=\"http://blog.jobbole.com/92815/\" class=\"wp_rp_title\">.NET 基础拾遗（3）: 字符串、集合和流</a></li><li ><a href=\"http://blog.jobbole.com/66078/\" class=\"wp_rp_title\">Java 8 中 HashMap 的性能提升 </a></li><li ><a href=\"http://blog.jobbole.com/77812/\" class=\"wp_rp_title\">空指针的救星</a></li><li ><a href=\"http://blog.jobbole.com/102378/\" class=\"wp_rp_title\">深入探索Java 8 Lambda表达式</a></li><li ><a href=\"http://blog.jobbole.com/16474/\" class=\"wp_rp_title\">Java编程提高性能时需注意的地方</a></li><li ><a href=\"http://blog.jobbole.com/37273/\" class=\"wp_rp_title\">Java的内存回收机制</a></li></ul></div></div><p><a href=\"http://blog.jobbole.com/104067/\">JDK8 Stream API中Collectors中toMap方法的问题以及解决方案</a>，首发于<a href=\"http://blog.jobbole.com\">文章 - 伯乐在线</a>。</p>" "http://blog.jobbole.com/104067/" (22431 904) old 11 nil nil ((title nil "JDK8 Stream API中Collectors中toMap方法的问题以及解决方案") (link nil "http://blog.jobbole.com/104067/") (comments nil "http://blog.jobbole.com/104067/#comments") (pubDate nil "Mon, 01 Aug 2016 08:08:40 +0000") (dc:creator nil "theboboy") (category nil "开发") (category nil "java") (guid ((isPermaLink . "false")) "http://blog.jobbole.com/?p=104067") (description nil "<p>JDK8 Stream API中Collectors中toMap方法的问题
1、key不能重复
2、value不能是null</p><p><a href=\"http://blog.jobbole.com/104067/\">JDK8 Stream API中Collectors中toMap方法的问题以及解决方案</a>，首发于<a href=\"http://blog.jobbole.com\">文章 - 伯乐在线</a>。</p>") (content:encoded nil "<p>使用Collectors.toMap方法时的两个问题：</p><p>1、当key重复时，会抛出异常：java.lang.IllegalStateException: Duplicate key **<br />
2、当value为null时，会抛出异常：java.lang.NullPointerException</p><p>首先这个不是JDK的bug，只是不符合我们的预期。</p><p>大家通常希望这个方法是可以容错的，遇到重复的key就使用后者替换，而且HashMap的value可以是null。</p><p>下面举个小例子。</p><p>首先是元素类Emp：</p><pre class=\"crayon-plain-tag\">public class Emp {

	private Integer id;

	private String name;

	public Emp(Integer id, String name) {
		super();
		this.id = id;
		this.name = name;
		System.out.println(this);
	}

	public Integer getId() {
		return id;
	}

	public String getName() {
		return name;
	}

	@Override
	public String toString() {
		return \"id: \" + id + \", name: \" + name;
	}

}</pre><p>然后是测试类：</p><pre class=\"crayon-plain-tag\">import java.util.Map;
import java.util.stream.Collectors;
import java.util.stream.IntStream;
import java.util.stream.Stream;

public class Test {

	public static void main(String[] args) {
		Emp[] emps = IntStream.range(0, 10).mapToObj(x -&gt; new Emp(x % 3, \"name\" + x))
				.toArray(Emp[]::new);
		Map&lt;Integer, String&gt; map = Stream.of(emps).collect(Collectors.toMap(Emp::getId, Emp::getName));
		System.out.println(map);
	}

}</pre><p>生成10个对象，其中id只能为0，1，2，用id做key，name做value，运行结果如下：</p><pre class=\"crayon-plain-tag\">id: 0, name: name0
id: 1, name: name1
id: 2, name: name2
id: 0, name: name3
id: 1, name: name4
id: 2, name: name5
id: 0, name: name6
id: 1, name: name7
id: 2, name: name8
id: 0, name: name9
Exception in thread \"main\" java.lang.IllegalStateException: Duplicate key name0
	at java.util.stream.Collectors.lambda$throwingMerger$0(Collectors.java:133)
	at java.util.HashMap.merge(HashMap.java:1253)
	at java.util.stream.Collectors.lambda$toMap$58(Collectors.java:1320)
	at java.util.stream.ReduceOps$3ReducingSink.accept(ReduceOps.java:169)
	at java.util.Spliterators$ArraySpliterator.forEachRemaining(Spliterators.java:948)
	at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:481)
	at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:471)
	at java.util.stream.ReduceOps$ReduceOp.evaluateSequential(ReduceOps.java:708)
	at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)
	at java.util.stream.ReferencePipeline.collect(ReferencePipeline.java:499)
	at Test.main(Test.java:11)</pre><p>提示key重复了。</p><p>接下来看另一种情况：</p><pre class=\"crayon-plain-tag\">import java.util.Map;
import java.util.stream.Collectors;
import java.util.stream.IntStream;
import java.util.stream.Stream;

public class Test {

	public static void main(String[] args) {
		Emp[] emps = IntStream.range(0, 10).mapToObj(x -&gt; new Emp(x, x % 5 == 0 ? null : \"name\" + x))
				.toArray(Emp[]::new);
		Map&lt;Integer, String&gt; map = Stream.of(emps).collect(Collectors.toMap(Emp::getId, Emp::getName));
		System.out.println(map);
	}

}</pre><p>这个是让emps数组中出现两个value为null的元素，运行结果如下：</p><pre class=\"crayon-plain-tag\">id: 0, name: null
id: 1, name: name1
id: 2, name: name2
id: 3, name: name3
id: 4, name: name4
id: 5, name: null
id: 6, name: name6
id: 7, name: name7
id: 8, name: name8
id: 9, name: name9
Exception in thread \"main\" java.lang.NullPointerException
	at java.util.HashMap.merge(HashMap.java:1224)
	at java.util.stream.Collectors.lambda$toMap$58(Collectors.java:1320)
	at java.util.stream.ReduceOps$3ReducingSink.accept(ReduceOps.java:169)
	at java.util.Spliterators$ArraySpliterator.forEachRemaining(Spliterators.java:948)
	at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:481)
	at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:471)
	at java.util.stream.ReduceOps$ReduceOp.evaluateSequential(ReduceOps.java:708)
	at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)
	at java.util.stream.ReferencePipeline.collect(ReferencePipeline.java:499)
	at Test.main(Test.java:11)</pre><p>提示value是null。</p><p>这个是因为调用了HashMap的merge方法，方法不接受这种数据。因此需要手动实现，实现方式也很简单，只要调用map的put方法就可以了。</p><pre class=\"crayon-plain-tag\">import java.util.Collections;
import java.util.EnumSet;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;
import java.util.function.BiConsumer;
import java.util.function.BinaryOperator;
import java.util.function.Function;
import java.util.function.Supplier;
import java.util.stream.Collector;

public class ForceToMapCollector&lt;T, K, V&gt; implements Collector&lt;T, Map&lt;K, V&gt;, Map&lt;K, V&gt;&gt; {

	private Function&lt;? super T, ? extends K&gt; keyMapper;

	private Function&lt;? super T, ? extends V&gt; valueMapper;

	public ForceToMapCollector(Function&lt;? super T, ? extends K&gt; keyMapper,
			Function&lt;? super T, ? extends V&gt; valueMapper) {
		super();
		this.keyMapper = keyMapper;
		this.valueMapper = valueMapper;
	}

	@Override
	public BiConsumer&lt;Map&lt;K, V&gt;, T&gt; accumulator() {
		return (map, element) -&gt; map.put(keyMapper.apply(element), valueMapper.apply(element));
	}

	@Override
	public Supplier&lt;Map&lt;K, V&gt;&gt; supplier() {
		return HashMap::new;
	}

	@Override
	public BinaryOperator&lt;Map&lt;K, V&gt;&gt; combiner() {
		return null;
	}

	@Override
	public Function&lt;Map&lt;K, V&gt;, Map&lt;K, V&gt;&gt; finisher() {
		return null;
	}

	@Override
	public Set&lt;Characteristics&gt; characteristics() {
		return Collections.unmodifiableSet(EnumSet.of(Collector.Characteristics.IDENTITY_FINISH));
	}

}</pre><p></p><pre class=\"crayon-plain-tag\">import java.util.Map;
import java.util.function.Function;
import java.util.stream.Collector;

public final class MyCollectors {

	public static &lt;T, K, V&gt; Collector&lt;T, ?, Map&lt;K, V&gt;&gt; toMap(Function&lt;T, K&gt; f1, Function&lt;T, V&gt; f2) {
		return new ForceToMapCollector&lt;T, K, V&gt;(f1, f2);
	}

}</pre><p>测试类如下：</p><pre class=\"crayon-plain-tag\">import java.util.Map;
import java.util.stream.IntStream;
import java.util.stream.Stream;

public class Test {

	public static void main(String[] args) {
		Emp[] emps = IntStream.range(0, 10).mapToObj(x -&gt; new Emp(x % 3, x % 5 == 0 ? null : \"name\" + x))
				.toArray(Emp[]::new);
		Map&lt;Integer, String&gt; map = Stream.of(emps).collect(MyCollectors.toMap(Emp::getId, Emp::getName));
		System.out.println(map);
	}

}</pre><p>包含了上面两种可能产生异常的情况，运行结果如下：</p><pre class=\"crayon-plain-tag\">id: 0, name: null
id: 1, name: name1
id: 2, name: name2
id: 0, name: name3
id: 1, name: name4
id: 2, name: null
id: 0, name: name6
id: 1, name: name7
id: 2, name: name8
id: 0, name: name9
{0=name9, 1=name7, 2=name8}</pre><p>解决了上面的问题，满足了容错需求。</p><p>由于Stream API用的不是很广泛，如果网友们有更好的实现方案，希望告知，多谢！</p><div class=\"wp_rp_wrap  wp_rp_plain\" ><div class=\"wp_rp_content\"><h3 class=\"related_post_title\">相关文章</h3><ul class=\"related_post wp_rp\" style=\"visibility: visible\"><li ><a href=\"http://blog.jobbole.com/90693/\" class=\"wp_rp_title\">ASP.NET MVC随想录（3）：创建自定义的Middleware中间件</a></li><li ><a href=\"http://blog.jobbole.com/79421/\" class=\"wp_rp_title\">Eric Raymond对于几大开发语言的评价</a></li><li ><a href=\"http://blog.jobbole.com/20400/\" class=\"wp_rp_title\">理解ThreadLocal</a></li><li ><a href=\"http://blog.jobbole.com/103325/\" class=\"wp_rp_title\">ThreadLocal 那点事儿</a></li><li ><a href=\"http://blog.jobbole.com/92815/\" class=\"wp_rp_title\">.NET 基础拾遗（3）: 字符串、集合和流</a></li><li ><a href=\"http://blog.jobbole.com/66078/\" class=\"wp_rp_title\">Java 8 中 HashMap 的性能提升 </a></li><li ><a href=\"http://blog.jobbole.com/77812/\" class=\"wp_rp_title\">空指针的救星</a></li><li ><a href=\"http://blog.jobbole.com/102378/\" class=\"wp_rp_title\">深入探索Java 8 Lambda表达式</a></li><li ><a href=\"http://blog.jobbole.com/16474/\" class=\"wp_rp_title\">Java编程提高性能时需注意的地方</a></li><li ><a href=\"http://blog.jobbole.com/37273/\" class=\"wp_rp_title\">Java的内存回收机制</a></li></ul></div></div><p><a href=\"http://blog.jobbole.com/104067/\">JDK8 Stream API中Collectors中toMap方法的问题以及解决方案</a>，首发于<a href=\"http://blog.jobbole.com\">文章 - 伯乐在线</a>。</p>") (wfw:commentRss nil "http://blog.jobbole.com/104067/feed/") (slash:comments nil "2"))) ("“懒惰” Linux 管理员的 10 个关键技巧" "<p>好的系统管理员区分在效率上。如果一位高效的系统管理员能在 10 分钟内完成一件他人需要 2 个小时才能完成的任务，那么他应该受到奖励（得到更多报酬），因为他为公司节约了时间，而时间就是金钱，不是吗？</p><p>技巧是为了提高管理效率。虽然本文不打算对<em>所有</em> 技巧进行讨论，但是我会介绍 “懒惰” 管理员所用的 10 个基本法宝。这些技巧可以节约时间 —— 即使没有因为高效而得到更多的报酬，但至少可以有更多的时间去玩。</p><h2 id=\"T1\">技巧 1：卸载无响应的 DVD 驱动器</h2><p>网络新手的经历：按下服务器（运行基于 Redmond 的操作系统）DVD 驱动器上的 Eject 按钮时，它会立即弹出。他然后抱怨说，在大多数企业 Linux 服务器中，如果在那个目录中运行某个进程，弹出就不会发生。作为一名长期的 Linux 管理员，我会重启机器。如果我不清楚正在运行什么，以及为何不释放 DVD 驱动器，我则会弹出磁盘。但这样效率很低。</p><p>下面介绍如何找到保持 DVD 驱动器的进程，并轻松弹出 DVD 驱动器：首先进行模拟。在 DVD 驱动器中放入磁盘，打开一个终端，装载 DVD 驱动器：</p><pre class=\"crayon-plain-tag\"># mount /media/cdrom
# cd /media/cdrom
# while [ 1 ]; do echo \"All your drives are belong to us!\"; sleep 30; done</pre><p>现在打开第二个终端并试着弹出 DVD 驱动器：</p><pre class=\"crayon-plain-tag\"># eject</pre><p>将得到以下消息：</p><p><code>umount: /media/cdrom: device is busy</code></p><p>在释放该设备之前，让我们找出谁在使用它。</p><pre class=\"crayon-plain-tag\"># fuser /media/cdrom</pre><p>进程正在运行，无法弹出磁盘其实是我们的错误。</p><p>现在，如果您是根用户，可以随意终止进程：</p><pre class=\"crayon-plain-tag\"># fuser -k /media/cdrom</pre><p>现在终于可以卸载驱动器了：</p><pre class=\"crayon-plain-tag\"># eject</pre><p><code>fuser</code> 很正常。</p><h2 id=\"T2\">技巧 2：恢复出现问题的屏幕</h2><p>尝试以下操作：</p><pre class=\"crayon-plain-tag\"># cat /bin/cat</pre><p>注意！终端就想垃圾一样。输入的所有内容非常零乱。那么该怎么做呢？</p><p>输入 <code>reset</code>。但是，输入 <code>reset</code> 与 输入 <code>reboot</code> 或 <code>shutdown</code> 太接近了。吓得手心冒汗了吧 — 特别是在生产机器上执行这个操作时。</p><p>放心吧，在进行此操作时，机器不会重启。继续操作：</p><pre class=\"crayon-plain-tag\"># reset</pre><p>现在屏幕恢复正常了。这比关闭窗口后再次登陆好多了，特别是必须经过 5 台机器和 SSH 才能到达这台机器时。</p><h2 id=\"T3\">技巧 3：屏幕协作</h2><p>来自产品工程的高级维护用户 David 打电话说：“为什么我不能在您部署的这些新机器上编译 supercode.c”。</p><p>您会问他：“您运行的是什么机器？”</p><p>David 答道：“ Posh”。（这个虚够的公司将它的 5 台生产服务器以纪念 Spice Girls 的方式命名）。这下您可以大显身手了，另一台机器由 David 操作：</p><pre class=\"crayon-plain-tag\"># su - david</pre><p>转到 posh：</p><pre class=\"crayon-plain-tag\"># ssh posh</pre><p>到达之后，运行以下代码：</p><pre class=\"crayon-plain-tag\"># screen -S foo</pre><p>然后呼叫 David：</p><p>“David，在终端运行命令 <code># screen -x foo</code>”。</p><p>这使您和 David 的会话在 Linux shell 中联接在一起。您可以输入，他也可以输入，但彼此可以看到对方所做的事情。这避免了进入其他层次，而且双方都有相同的控制权。这样做的好处是 David 可以观察到您的故障诊断技巧，并能准确了解如何解决问题。</p><p>最后大家都能看到问题所在：David 的编译脚本对一个不在此新服务器上的旧目录进行了硬编码。将它装载后再次编译即可解决问题，然后 David 继续工作。您则可以继续之前的娱乐活动。</p><p>关于此技巧需要注意的一点是，双方需要以同一用户登录。<code>screen</code> 命令还可以：实现多个窗口和拆分屏幕。请阅读手册页获取更多相关信息。</p><p>对于 <code>screen</code> 会话，我还有最后一个技巧。要从中分离并让它打开，请输入</p><pre class=\"crayon-plain-tag\">Ctrl-A D</pre><p>（即按住 <strong>Ctrl</strong> 键并点击 <strong>A</strong> 键。然后按 <strong>D</strong> 键）。</p><p>然后通过再次运行 <code>screen -x foo</code> 命令可以重新拼接起来。</p><h2 id=\"T4\">技巧 4：找回根密码</h2><p>如果忘记根密码，就必须重新安装整台机器。更惨的是，许多人都会这样做。但是启动机器并更改密码却十分简单。这并非在所有情况下都适用（比如设置了一个 GRUB 密码，但也忘记了），但这里介绍一个 Cent OS Linux 示例，说明一般情况下的操作。</p><p>首先重启系统。重启时会跳出如图 1 所示的 GRUB 屏幕。移动箭头键，这样可以保留在此屏幕上，而不是进入正常启动。</p><h5 id=\"fig1\">图 1. 重启后的 GRUB 屏幕</h5><p><img class=\"alignnone size-full wp-image-104057\" src=\"http://jbcdn2.b0.upaiyun.com/2016/08/908274ca8bae11a3d0ee929945bed136.jpg\" alt=\"figure1\" /></p><p>然后，使用箭头键选择要启动的内核，并输入 <strong>E</strong> 编辑内核行。然后便可看到如图 2 所示的屏幕：</p><h5 id=\"fig2\">图 2：准备编辑内核行</h5><p><img class=\"alignnone size-full wp-image-104058\" src=\"http://jbcdn2.b0.upaiyun.com/2016/08/0ffb52eba45605e896a7b78cb83739c7.jpg\" alt=\"figure2\" /></p><p>再次使用箭头键突出显示以 <code>kernel</code> 开始的行，按 <strong>E</strong> 编辑内核参数。到达如图 3 所示的屏幕时，在图 3 中所示的参数后追加数字 1 即可：</p><h5 id=\"fig3\">图 3. 在参数后追加数字 1</h5><p><img class=\"alignnone size-full wp-image-104059\" src=\"http://jbcdn2.b0.upaiyun.com/2016/08/0529dad8172eae86f9194b573b5500b1.jpg\" alt=\"figure3\" /></p><p>然后按 <strong>Enter</strong> 和 <strong>B</strong>，内核会启动到单用户模式。然后运行 <code>passwd</code> 命令，更改用户根密码：</p><pre class=\"crayon-plain-tag\">sh-3.00# passwd
New UNIX password:
Retype new UNIX password:
passwd: all authentication tokens updated successfully
现在可以重启了，机器将使用新密码启动。</pre><p>&nbsp;</p><h2 id=\"T5\">技巧 5：SSH 后门</h2><p>有很多次，我所在的站点需要某人的远程支持，而他却被公司防火强阻挡在外。很少有人意识到，如果能通过防火墙到达外部，那么也能轻松实现让外部的信息进来。 从本意讲，这称为 “在防火墙上砸一个洞”。我称之为 <em>SSH 后门</em>。为了使用它，必须有一台作为中介的连接到 Internet 的机器。 在本例中，将这样台机器称为 blackbox.example.com。公司防火墙后面的机器称为 ginger。此技术支持的机器称为 tech。图 4 解释了设置过程。</p><h5 id=\"fig4\">图 4. 在防火墙上砸一个洞</h5><p><img class=\"alignnone size-full wp-image-104060\" src=\"http://jbcdn2.b0.upaiyun.com/2016/08/bffe845bc378958de3345dd580a59ecc.gif\" alt=\"figure4\" /></p><p>以下是操作步骤：</p><ol><ol><li>检查什么是允许做的，但要确保您问对了人。大多数人都担心您打开了防火墙，但他们不明白这是完全加密的。而且，必须破解外部机器才能进入公司内部。不过，您可能属于 “敢作敢为” 型的人物。自己进行判断应该选择的方式，但不如意时不抱怨别人。</li></ol></ol><ul><li>使用 <code>-R</code> 标记通过 SSH 从 ginger 连接到 blackbox.example.com。假设您是 ginger 上的根用户，tech 需要根用户 ID 来帮助使用系统。使用 <code>-R</code> 标记将 blackbox 上端口 2222 的说明转发到 ginger 的端口 22 上。这就设置了 SSH 通道。注意，只有 SSH 通信可以进入 ginger：您不会将 ginger 放在无保护的 Internet 上。可以使用以下语法实现此操作：<br /><pre class=\"crayon-plain-tag\">~# ssh -R 2222:localhost:22 thedude@blackbox.example.com</pre><br />
进入 blackbox 后，只需一直保持登录状态。我总是输入以下命令：<br /><pre class=\"crayon-plain-tag\">thedude@blackbox:~$ while [ 1 ]; do date; sleep 300; done</pre><br />
使机器保持忙碌状态。然后最小化窗口。</li><li>现在指示 tech 上的朋友使用 SSH 连接到 blackbox，而不需要使用任何特殊的 SSH 标记。但必须把密码给他们：<br /><pre class=\"crayon-plain-tag\">root@tech:~# ssh thedude@blackbox.example.com</pre></li><li>tech 位于 blackbox 上后，可以使用以下命令从 SSH 连接到 ginger：<br /><pre class=\"crayon-plain-tag\">thedude@blackbox:~$: ssh -p 2222 root@localhost</pre></li><li>Tech 将提示输入密码。应该输入 ginger 的根密码。</li><li>现在您和来自 tech 的支持可以一起工作并解决问题。甚至需要一起使用屏幕！（参见 技巧 4）。</li></ul><h2 id=\"T6\">技巧 6：通过 SSH 通道进行远程 VNC 会话</h2><p>VNC 或虚拟网络计算已经存在很长时间了。通常，当远程服务器上的某类图形程序只能在此服务器上使用时，我才需要 VNC。</p><p>例如，假设在 <a href=\"#T5\">技巧 5</a> 中，ginger 是一台存储服务器。许多设备都使用 GUI 程序来管理存储控制器。这些 GUI 管理工具通常需要通过一个网络直接连接到存储服务器，而这个网络有时保存在专用的子网络中。因此，只能通过 ginger 访问这个 GUI。</p><p>可以尝试使用 <code>-X</code> 选项通过 SSH 连接到 ginger 并启动它，但这对带宽要求很高，您需要忍受等待的痛苦。VNC 是一个网络友好的工具，几乎适用于所有操作系统。</p><p>假设设置与技巧 5 中的一样，但希望 tech 能访问 VNC 而不是 SSH。对于这种情况，需要进行一些类似的操作，不过转发的是 VNC 端口。执行以下操作步骤：</p><ol><li>在 ginger 上启动一个 VNC 服务器会话。运行以下命令：<br /><pre class=\"crayon-plain-tag\">root@ginger:~# vncserver -geometry 1024x768 -depth 24 :99</pre><br />
这些选项指示启动服务器，分辨率为 1024×768，像素深度为每像素 24 位。如果使用较慢的连接设置，8 也许是更好的选项。使用 <code>:99</code> 指定可访问 VNC 服务器的端口。VNC 协议在 5900 处启动，因此 <code>:99</code> 表示服务器可从端口 5999 访问。</p><p>启动该会话时，要求您指定密码。用户 ID 与启动 VNC 服务器时的用户相同（本例中就是根用户）。</li><li>从 ginger 连接到 blackbox.example.com 的 SSH 将 blackbox 上的端口 5999 转发到 ginger。这通过运行以下命令在 ginger 中完成：</p><pre class=\"crayon-plain-tag\">root@ginger:~# ssh -R 5999:localhost:5999 thedude@blackbox.example.com</pre><p>运行此命令后，需要将此 SSH 会话保持为打开状态，以便保留转发到 ginger 的端口。此时，如果在 blackbox 上，那么运行以下命令即可访问 ginger 上的 VNC 会话：</p><pre class=\"crayon-plain-tag\">thedude@blackbox:~$ vncviewer localhost:99</pre><p>这将通过 SSH 将端口转发给 ginger，但我们希望通过 tech 让 VNC 访问 ginger。为此，需要另一个通道。</li><li>在 tech 中，打开一个通道，通过 SHH 将端口 5999 转发到 blackbox 上的端口 5999。这通过运行以下命令完成：</p><pre class=\"crayon-plain-tag\">root@tech:~# ssh -L 5999:localhost:5999 thedude@blackbox.example.com</pre><p>这次使用的 SSH 标记为 <code>-L</code>，它不是将 5999 放到 blackbox，而是从中获取。到达 blackbox 后，需要保持此会话为打开状态。现在即可在 tech 中使用 VNC 了！</li><li>在 tech 中，运行以下命令使 VNC 连接到 ginger：</p><pre class=\"crayon-plain-tag\">root@tech:~# vncviewer localhost:99</pre><p>.Tech 现在将拥有一个直接到 ginger 的 VNC 会话。</li></ol><p>设置虽然有点麻烦，但比为修复存储阵列而四处奔波强多了。不过多实践几次这就变得容易了。</p><p>对此技巧我还要补充一点：如果 tech 运行的是 Windows® 操作系统，并且没有命令行 SSH 客户端，那么 tech 可以运行 Putty。Putty 可以设置为通过查找侧栏中的选项来转发 SSH 端口。如果端口是 5902 而不是本例中的 5999，则可以输入图 5 中的内容。</p><h5 id=\"fig5\">图 5. Putty 可以转发用作通道的 SSH</h5><p><img class=\"alignnone size-full wp-image-104061\" src=\"http://jbcdn2.b0.upaiyun.com/2016/08/c81a100ab2da1fef06474283f5e4e771.jpg\" alt=\"figure5\" /></p><p>如果进行了此设置，那么 tech 就可以使用 VNC 连接到 localhost:2，如同 tech 正在 Linux 操作系统上运行一样。</p><h2 id=\"T7\">技巧 7：检查带宽</h2><p>设想：公司 A 有一个名为 ginger 的存储服务器，并通过名为 beckham 的客户端节点装载 NFS。公司 A 确定他们需要从 ginger 得到更多的带宽，因为有大量的节点需要 NFS 装载 ginger 的共享文件系统。</p><p>实现此操作的最常用和最便宜的方式是将两个吉比特以太网 NIC 组合在一起。这是最便宜的，因为您通常会有一个额外的可用 NIC 和一个额外的端口。</p><p>所以采取此这个方法。不过现在的问题是：到底需要多少带宽？</p><p>吉比特以太网理论上的限制是 128MBit/s。这个数字从何而来？看看这些计算：</p><p><em>1Gb = 1024Mb</em>；<em>1024Mb/8 = 128MB</em>；”b” = “bits,”、”B” = “bytes”</p><p>但实际看到的是什么呢，有什么好的测量方法呢？我推荐一个工具 iperf。可以按照以下方法获得 iperf：</p><pre class=\"crayon-plain-tag\"># wget http://dast.nlanr.net/Projects/Iperf2.0/iperf-2.0.2.tar.gz</pre><p>需要在 ginger 和 beckham 均可见的共享文件系统上安装此工具，或者在两个节点上编译并安装。我将在两个节点均可见的 bob 用户的主目录中编译它：</p><pre class=\"crayon-plain-tag\">tar zxvf iperf*gz
cd iperf-2.0.2
./configure -prefix=/home/bob/perf
make
make install</pre><p>在 ginger 上，运行：</p><pre class=\"crayon-plain-tag\"># /home/bob/perf/bin/iperf -s -f M</pre><p>这台机器将用作服务器并以 MBit/s 为单位输出执行速度。</p><p>在 beckham 节点上，运行：</p><pre class=\"crayon-plain-tag\"># /home/bob/perf/bin/iperf -c ginger -P 4 -f M -w 256k -t 60</pre><p>两个屏幕上的结果都指示了速度是多少。在使用吉比特适配器的普通服务器上，可能会看到速度约为 112MBit/s。这是 TCP 堆栈和物理电缆中的常用带宽。通过以端到端的方式连接两台服务器，每台服务器使用两个联结的以太网卡，我获得了约 220MBit/s 的带宽。</p><p>事实上，在联结的网络上看到的 NFS 约为 150-160MBit/s。这仍然表示带宽可以达到预期效果。如果看到更小的值，则应该检查是否有问题。</p><p>我最近碰到一种情况，即通过连接驱动程序连接两个使用了不同驱动程序的 NIC。这导致性能非常低，带宽约为 20MBit/s，比不连接以太网卡时的带宽还小！</p><h2 id=\"T8\">技巧 8：命令行脚本和实用程序</h2><p>Linux 系统管理员通过使用权威的命令行脚本会变得更高效。这包括巧妙使用循环和知道如何使用 <code>awk</code>、<code>grep</code> 和 <code>sed</code> 等的实用程序解析数据。通常这可以减少击键次数，降低用户出错率。</p><p>例如，假设需要为即将安装的 Linux 集群生成一个新的 /etc/hosts 文件。一般的做法是在 vi 或文本编辑器中添加 IP 地址。不过，可以通过使用现有 /etc/hosts 文件并将以下内容追加到此文件来实现。在命令行上运行：</p><pre class=\"crayon-plain-tag\"># P=1; for i in $(seq -w 200); do echo \"192.168.99.$P n$i\"; P=$(expr $P + 1);
done &gt;&gt;/etc/hosts</pre><p>200 个主机名（n001 到 n200）将由 IP 地址（192.168.99.1 到 192.168.99.200）来创建。手动填充这样的文件有可能会创建重复的 IP 地址或主机名，因此这是使用内置命令行消除用户错误的好例子。请注意，这是在 bash shell（大多数 Linux 发行版的默认值）内完成的。</p><p>再举一个例子，假设要检查 Linux 集群中的各个计算节点中的内存大小是否一样。通常，拥有一个发行版或类似的 shell 是最好的。但是为了演示，以下使用 SSH。</p><p>假设 SSH 设置为不使用密码验证。然后运行：</p><pre class=\"crayon-plain-tag\"># for num in $(seq -w 200); do ssh n$num free -tm | grep Mem | awk '{print $2}';
done | sort | uniq</pre><p>这样的命令行相当简洁。（如果在其中放入正则表达式情况会更糟）。让我们对它进行细分，详细讨论各部分。</p><p>首先从 001 循环到 200。使用 <code>seq</code> 命令的 <code>-w</code> 选项在前面填充 0。 然后替换 <code>num</code> 变量，创建通过 SSH 连接的主机。有了目标主机后，向它发出命令。本例中是：</p><pre class=\"crayon-plain-tag\">free -m | grep Mem | awk '{print $2}'</pre><p>这个命令的意思是：</p><ul><li>使用 <code>free</code> 命令获取以兆字节为单位的内存大小。</li><li>获取这个命令的结果，并使用 <code>grep</code> 获取包含字符串 <code>Mem</code> 的行。</li><li>获取那一行并使用 <code>awk</code> 输出第二个字段，它是节点中的总内存。</li></ul><p>在每个节点上执行这个操作。</p><p>在每个节点上执行命令后，200 个节点的整个输出就传送（<code>|</code>d）到 <code>sort</code> 命令，以对所有内存值进行排序。</p><p>最后，使用 <code>uniq</code> 命令消除重复项。这个命令会导致以下情况中的一种：</p><ul><li>如果所有节点（n001 到 n200）拥有相同的内存大小，则只显示一个数字。这个数字就是每个操作系统看到的内存大小。</li><li>如果节点内存大小不同，将会看到几个内存大小的值。</li><li>最后，如果某个节点上的 SSH 出现故障，则会看到一些错误消息。</li></ul><p>这个命令并不是完美无缺的。如果发现与预期不同的内存值，您就不知道是哪一个节点出了问题，或者有多少个节点。为此需要发出另一个命令。</p><p>这个技巧提供了一种查看某些内容的快速方式，而且如果发生错误，您可以立刻知道。其价值在于快速检查。</p><h2 id=\"T9\">技巧 9：控制台侦察</h2><p>有些软件会向控制台输出错误消息，而控制台不一定会显示在 SHH 会话中。使用 vcs 设备可以进行检查。在 SSH 会话中，在远程服务器 <code># cat /dev/vcs1</code> 上运行以下命令。这将显示第一个控制台中的内容。也可以使用 2、3 等查看其他虚拟终端。如果某个用户在远程系统上输入，您将看到他输入的内容。</p><p>在大多数数据场中，使用远程终端服务器、KVM 甚至 Serial Over LAN 是查看这类信息的最好方式；它也提供了带外查看功能的一些好处。使用 vcs 设备能够提供一种快速带内方法，这能节省去机房查看控制台的时间。</p><h2 id=\"T10\">技巧 10：随机系统信息收集</h2><p>在 <a href=\"#T8\">技巧 8</a> 中，介绍了一个使用命令行获取有关系统中总内存信息的例子。在这个技巧中，我将介绍几个其他方法，用于从需要进行验证、故障诊断或给予远程支持的系统收集重要信息。</p><p>首先，收集关于处理器的信息。通过以下命令很容易实现：</p><pre class=\"crayon-plain-tag\"># cat /proc/cpuinfo</pre><p>这个命令给出关于处理器的速度、数量和型号的信息。在许多情况下使用 <code>grep</code> 可以得到需要的值。</p><p>我经常做的检查是确定系统中处理器的数量。因此，如果我买了一台带双核处理器的四核服务器，我可以运行以下命令：</p><pre class=\"crayon-plain-tag\"># cat /proc/cpuinfo | grep processor | wc -l</pre><p>然后我看到值应该是 8。如果不是，我会打电话给供应商，让他们给我派送另一台处理器。</p><p>我需要的另一条信息是磁盘信息。可以使用 <code>df</code> 命令获得。我总是添加 <code>-h</code> 标记，以便看到以十亿字节或兆字节为单位的输出。<code># df -h</code> 还会显示磁盘的分区情况。</p><p>列表最后是查看系统固件的方式 —— 一个获取 BIOS 级别和 NIC 上的固件信息的方法。</p><p>要检查 BIOS 版本，可以运行 <code>dmidecode</code> 命令。遗憾的是，不能轻易使用 <code>grep</code> 获取信息，所以这不是一个很有效的方法。对于我的 Lenovo T61 laptop，输出如下：</p><pre class=\"crayon-plain-tag\">#dmidecode | less
...
BIOS Information
Vendor: LENOVO
Version: 7LET52WW (1.22 )
Release Date: 08/27/2007
...</pre><p>这比重启机器并查看 POST 输出有效得多。</p><p>要检查以太网适配器的驱动程序和固件版本，请运行 <code>ethtool</code>：</p><pre class=\"crayon-plain-tag\"># ethtool -i eth0
driver: e1000
version: 7.3.20-k2-NAPI
firmware-version: 0.3-0</pre><p></p><h2 id=\"N102CC\">结束语</h2><p>可以从精通命令行的人那里学习很多技巧。最好的学习方式是：</p><ul><li>与其他人一起工作。共享屏幕会话并观察其他人是如何工作的 —— 您会发现新的做事方法。可能需要谦虚一点，让其他人引导，不过通常可以学到很多东西。</li><li>阅读手册页。认真阅读手册页，即使是熟知的命令，也能获得更深的见解。例如，您以前可能根本不知道可以使用 <code>awk</code> 进行网络编程。</li><li>解决问题。作为系统管理员，总是要解决问题，不管是您还是其他人引起的问题。这就是经验，经验可以使您更优秀、更高效。</li></ul><p>我希望至少有一个技巧能帮助您学习到您不知道的知识。像这样的基本技巧可以使您更高效，并且能增长经验，但最重要的是，技巧可以让您有更多的空闲时间去做自己感兴趣的事情，比如玩电子游戏。最好的管理员比较悠闲，因为他们不喜欢工作。他们能找到完成任务的最快方法，并且能快速完成任务，从而保持休闲的生活。</p><div class=\"wp_rp_wrap  wp_rp_plain\" ><div class=\"wp_rp_content\"><h3 class=\"related_post_title\">相关文章</h3><ul class=\"related_post wp_rp\" style=\"visibility: visible\"><li ><a href=\"http://blog.jobbole.com/97676/\" class=\"wp_rp_title\">基于 JavaScript 的操作系统你听说过吗？</a></li><li ><a href=\"http://blog.jobbole.com/53821/\" class=\"wp_rp_title\">写给系统管理员的25个PHP安全实践</a></li><li ><a href=\"http://blog.jobbole.com/93132/\" class=\"wp_rp_title\">Linux Shell 管道命令(pipe)使用及与 Shell 重定向区别</a></li><li ><a href=\"http://blog.jobbole.com/36375/\" class=\"wp_rp_title\">在服务器上排除问题的头五分钟</a></li><li ><a href=\"http://blog.jobbole.com/76103/\" class=\"wp_rp_title\">SysAdmim 必备：系统性能大牛 Brendan Gregg 分享的 Linux 性能工具</a></li><li ><a href=\"http://blog.jobbole.com/80575/\" class=\"wp_rp_title\">18款开源/商用的Linux服务器控制面板</a></li><li ><a href=\"http://blog.jobbole.com/33790/\" class=\"wp_rp_title\">高效使用 SSH 的 16 个技巧</a></li><li ><a href=\"http://blog.jobbole.com/92792/\" class=\"wp_rp_title\">Linux Shell 创建序列数组</a></li><li ><a href=\"http://blog.jobbole.com/103561/\" class=\"wp_rp_title\">从业 30 年的女系统管理员的经验分享</a></li><li ><a href=\"http://blog.jobbole.com/49497/\" class=\"wp_rp_title\">给 Linux 系统“减肥”</a></li></ul></div></div><p><a href=\"http://blog.jobbole.com/104056/\">“懒惰” Linux 管理员的 10 个关键技巧</a>，首发于<a href=\"http://blog.jobbole.com\">文章 - 伯乐在线</a>。</p>" "http://blog.jobbole.com/104056/" (22430 56598) old 12 nil nil ((title nil "“懒惰” Linux 管理员的 10 个关键技巧") (link nil "http://blog.jobbole.com/104056/") (pubDate nil "Mon, 01 Aug 2016 05:24:38 +0000") (dc:creator nil "伯小乐") (category nil "IT技术") (category nil "Linux") (category nil "系统管理员") (guid ((isPermaLink . "false")) "http://blog.jobbole.com/?p=104056") (description nil "<p>如何成为一名效率更高的系统管理员

学会这 10 个技巧后，您将成为世界上最强大的 Linux® 系统管理员，整个世界是有点夸张，但要在一个大团队中工作，这些技巧是十分必要的。学习 SHH 通道、VNC、密码恢复、控制台侦察等等。各个技巧都附有例子，可以将这些例子复制到自己的系统中。</p><p><a href=\"http://blog.jobbole.com/104056/\">“懒惰” Linux 管理员的 10 个关键技巧</a>，首发于<a href=\"http://blog.jobbole.com\">文章 - 伯乐在线</a>。</p>") (content:encoded nil "<p>好的系统管理员区分在效率上。如果一位高效的系统管理员能在 10 分钟内完成一件他人需要 2 个小时才能完成的任务，那么他应该受到奖励（得到更多报酬），因为他为公司节约了时间，而时间就是金钱，不是吗？</p><p>技巧是为了提高管理效率。虽然本文不打算对<em>所有</em> 技巧进行讨论，但是我会介绍 “懒惰” 管理员所用的 10 个基本法宝。这些技巧可以节约时间 —— 即使没有因为高效而得到更多的报酬，但至少可以有更多的时间去玩。</p><h2 id=\"T1\">技巧 1：卸载无响应的 DVD 驱动器</h2><p>网络新手的经历：按下服务器（运行基于 Redmond 的操作系统）DVD 驱动器上的 Eject 按钮时，它会立即弹出。他然后抱怨说，在大多数企业 Linux 服务器中，如果在那个目录中运行某个进程，弹出就不会发生。作为一名长期的 Linux 管理员，我会重启机器。如果我不清楚正在运行什么，以及为何不释放 DVD 驱动器，我则会弹出磁盘。但这样效率很低。</p><p>下面介绍如何找到保持 DVD 驱动器的进程，并轻松弹出 DVD 驱动器：首先进行模拟。在 DVD 驱动器中放入磁盘，打开一个终端，装载 DVD 驱动器：</p><pre class=\"crayon-plain-tag\"># mount /media/cdrom
# cd /media/cdrom
# while [ 1 ]; do echo \"All your drives are belong to us!\"; sleep 30; done</pre><p>现在打开第二个终端并试着弹出 DVD 驱动器：</p><pre class=\"crayon-plain-tag\"># eject</pre><p>将得到以下消息：</p><p><code>umount: /media/cdrom: device is busy</code></p><p>在释放该设备之前，让我们找出谁在使用它。</p><pre class=\"crayon-plain-tag\"># fuser /media/cdrom</pre><p>进程正在运行，无法弹出磁盘其实是我们的错误。</p><p>现在，如果您是根用户，可以随意终止进程：</p><pre class=\"crayon-plain-tag\"># fuser -k /media/cdrom</pre><p>现在终于可以卸载驱动器了：</p><pre class=\"crayon-plain-tag\"># eject</pre><p><code>fuser</code> 很正常。</p><h2 id=\"T2\">技巧 2：恢复出现问题的屏幕</h2><p>尝试以下操作：</p><pre class=\"crayon-plain-tag\"># cat /bin/cat</pre><p>注意！终端就想垃圾一样。输入的所有内容非常零乱。那么该怎么做呢？</p><p>输入 <code>reset</code>。但是，输入 <code>reset</code> 与 输入 <code>reboot</code> 或 <code>shutdown</code> 太接近了。吓得手心冒汗了吧 — 特别是在生产机器上执行这个操作时。</p><p>放心吧，在进行此操作时，机器不会重启。继续操作：</p><pre class=\"crayon-plain-tag\"># reset</pre><p>现在屏幕恢复正常了。这比关闭窗口后再次登陆好多了，特别是必须经过 5 台机器和 SSH 才能到达这台机器时。</p><h2 id=\"T3\">技巧 3：屏幕协作</h2><p>来自产品工程的高级维护用户 David 打电话说：“为什么我不能在您部署的这些新机器上编译 supercode.c”。</p><p>您会问他：“您运行的是什么机器？”</p><p>David 答道：“ Posh”。（这个虚够的公司将它的 5 台生产服务器以纪念 Spice Girls 的方式命名）。这下您可以大显身手了，另一台机器由 David 操作：</p><pre class=\"crayon-plain-tag\"># su - david</pre><p>转到 posh：</p><pre class=\"crayon-plain-tag\"># ssh posh</pre><p>到达之后，运行以下代码：</p><pre class=\"crayon-plain-tag\"># screen -S foo</pre><p>然后呼叫 David：</p><p>“David，在终端运行命令 <code># screen -x foo</code>”。</p><p>这使您和 David 的会话在 Linux shell 中联接在一起。您可以输入，他也可以输入，但彼此可以看到对方所做的事情。这避免了进入其他层次，而且双方都有相同的控制权。这样做的好处是 David 可以观察到您的故障诊断技巧，并能准确了解如何解决问题。</p><p>最后大家都能看到问题所在：David 的编译脚本对一个不在此新服务器上的旧目录进行了硬编码。将它装载后再次编译即可解决问题，然后 David 继续工作。您则可以继续之前的娱乐活动。</p><p>关于此技巧需要注意的一点是，双方需要以同一用户登录。<code>screen</code> 命令还可以：实现多个窗口和拆分屏幕。请阅读手册页获取更多相关信息。</p><p>对于 <code>screen</code> 会话，我还有最后一个技巧。要从中分离并让它打开，请输入</p><pre class=\"crayon-plain-tag\">Ctrl-A D</pre><p>（即按住 <strong>Ctrl</strong> 键并点击 <strong>A</strong> 键。然后按 <strong>D</strong> 键）。</p><p>然后通过再次运行 <code>screen -x foo</code> 命令可以重新拼接起来。</p><h2 id=\"T4\">技巧 4：找回根密码</h2><p>如果忘记根密码，就必须重新安装整台机器。更惨的是，许多人都会这样做。但是启动机器并更改密码却十分简单。这并非在所有情况下都适用（比如设置了一个 GRUB 密码，但也忘记了），但这里介绍一个 Cent OS Linux 示例，说明一般情况下的操作。</p><p>首先重启系统。重启时会跳出如图 1 所示的 GRUB 屏幕。移动箭头键，这样可以保留在此屏幕上，而不是进入正常启动。</p><h5 id=\"fig1\">图 1. 重启后的 GRUB 屏幕</h5><p><img class=\"alignnone size-full wp-image-104057\" src=\"http://jbcdn2.b0.upaiyun.com/2016/08/908274ca8bae11a3d0ee929945bed136.jpg\" alt=\"figure1\" /></p><p>然后，使用箭头键选择要启动的内核，并输入 <strong>E</strong> 编辑内核行。然后便可看到如图 2 所示的屏幕：</p><h5 id=\"fig2\">图 2：准备编辑内核行</h5><p><img class=\"alignnone size-full wp-image-104058\" src=\"http://jbcdn2.b0.upaiyun.com/2016/08/0ffb52eba45605e896a7b78cb83739c7.jpg\" alt=\"figure2\" /></p><p>再次使用箭头键突出显示以 <code>kernel</code> 开始的行，按 <strong>E</strong> 编辑内核参数。到达如图 3 所示的屏幕时，在图 3 中所示的参数后追加数字 1 即可：</p><h5 id=\"fig3\">图 3. 在参数后追加数字 1</h5><p><img class=\"alignnone size-full wp-image-104059\" src=\"http://jbcdn2.b0.upaiyun.com/2016/08/0529dad8172eae86f9194b573b5500b1.jpg\" alt=\"figure3\" /></p><p>然后按 <strong>Enter</strong> 和 <strong>B</strong>，内核会启动到单用户模式。然后运行 <code>passwd</code> 命令，更改用户根密码：</p><pre class=\"crayon-plain-tag\">sh-3.00# passwd
New UNIX password:
Retype new UNIX password:
passwd: all authentication tokens updated successfully

现在可以重启了，机器将使用新密码启动。</pre><p>&nbsp;</p><h2 id=\"T5\">技巧 5：SSH 后门</h2><p>有很多次，我所在的站点需要某人的远程支持，而他却被公司防火强阻挡在外。很少有人意识到，如果能通过防火墙到达外部，那么也能轻松实现让外部的信息进来。 从本意讲，这称为 “在防火墙上砸一个洞”。我称之为 <em>SSH 后门</em>。为了使用它，必须有一台作为中介的连接到 Internet 的机器。 在本例中，将这样台机器称为 blackbox.example.com。公司防火墙后面的机器称为 ginger。此技术支持的机器称为 tech。图 4 解释了设置过程。</p><h5 id=\"fig4\">图 4. 在防火墙上砸一个洞</h5><p><img class=\"alignnone size-full wp-image-104060\" src=\"http://jbcdn2.b0.upaiyun.com/2016/08/bffe845bc378958de3345dd580a59ecc.gif\" alt=\"figure4\" /></p><p>以下是操作步骤：</p><ol><ol><li>检查什么是允许做的，但要确保您问对了人。大多数人都担心您打开了防火墙，但他们不明白这是完全加密的。而且，必须破解外部机器才能进入公司内部。不过，您可能属于 “敢作敢为” 型的人物。自己进行判断应该选择的方式，但不如意时不抱怨别人。</li></ol></ol><ul><li>使用 <code>-R</code> 标记通过 SSH 从 ginger 连接到 blackbox.example.com。假设您是 ginger 上的根用户，tech 需要根用户 ID 来帮助使用系统。使用 <code>-R</code> 标记将 blackbox 上端口 2222 的说明转发到 ginger 的端口 22 上。这就设置了 SSH 通道。注意，只有 SSH 通信可以进入 ginger：您不会将 ginger 放在无保护的 Internet 上。可以使用以下语法实现此操作：<br /><pre class=\"crayon-plain-tag\">~# ssh -R 2222:localhost:22 thedude@blackbox.example.com</pre><br />
进入 blackbox 后，只需一直保持登录状态。我总是输入以下命令：<br /><pre class=\"crayon-plain-tag\">thedude@blackbox:~$ while [ 1 ]; do date; sleep 300; done</pre><br />
使机器保持忙碌状态。然后最小化窗口。</li><li>现在指示 tech 上的朋友使用 SSH 连接到 blackbox，而不需要使用任何特殊的 SSH 标记。但必须把密码给他们：<br /><pre class=\"crayon-plain-tag\">root@tech:~# ssh thedude@blackbox.example.com</pre></li><li>tech 位于 blackbox 上后，可以使用以下命令从 SSH 连接到 ginger：<br /><pre class=\"crayon-plain-tag\">thedude@blackbox:~$: ssh -p 2222 root@localhost</pre></li><li>Tech 将提示输入密码。应该输入 ginger 的根密码。</li><li>现在您和来自 tech 的支持可以一起工作并解决问题。甚至需要一起使用屏幕！（参见 技巧 4）。</li></ul><h2 id=\"T6\">技巧 6：通过 SSH 通道进行远程 VNC 会话</h2><p>VNC 或虚拟网络计算已经存在很长时间了。通常，当远程服务器上的某类图形程序只能在此服务器上使用时，我才需要 VNC。</p><p>例如，假设在 <a href=\"#T5\">技巧 5</a> 中，ginger 是一台存储服务器。许多设备都使用 GUI 程序来管理存储控制器。这些 GUI 管理工具通常需要通过一个网络直接连接到存储服务器，而这个网络有时保存在专用的子网络中。因此，只能通过 ginger 访问这个 GUI。</p><p>可以尝试使用 <code>-X</code> 选项通过 SSH 连接到 ginger 并启动它，但这对带宽要求很高，您需要忍受等待的痛苦。VNC 是一个网络友好的工具，几乎适用于所有操作系统。</p><p>假设设置与技巧 5 中的一样，但希望 tech 能访问 VNC 而不是 SSH。对于这种情况，需要进行一些类似的操作，不过转发的是 VNC 端口。执行以下操作步骤：</p><ol><li>在 ginger 上启动一个 VNC 服务器会话。运行以下命令：<br /><pre class=\"crayon-plain-tag\">root@ginger:~# vncserver -geometry 1024x768 -depth 24 :99</pre><br />
这些选项指示启动服务器，分辨率为 1024&#215;768，像素深度为每像素 24 位。如果使用较慢的连接设置，8 也许是更好的选项。使用 <code>:99</code> 指定可访问 VNC 服务器的端口。VNC 协议在 5900 处启动，因此 <code>:99</code> 表示服务器可从端口 5999 访问。</p><p>启动该会话时，要求您指定密码。用户 ID 与启动 VNC 服务器时的用户相同（本例中就是根用户）。</li><li>从 ginger 连接到 blackbox.example.com 的 SSH 将 blackbox 上的端口 5999 转发到 ginger。这通过运行以下命令在 ginger 中完成：</p><pre class=\"crayon-plain-tag\">root@ginger:~# ssh -R 5999:localhost:5999 thedude@blackbox.example.com</pre><p>运行此命令后，需要将此 SSH 会话保持为打开状态，以便保留转发到 ginger 的端口。此时，如果在 blackbox 上，那么运行以下命令即可访问 ginger 上的 VNC 会话：</p><pre class=\"crayon-plain-tag\">thedude@blackbox:~$ vncviewer localhost:99</pre><p>这将通过 SSH 将端口转发给 ginger，但我们希望通过 tech 让 VNC 访问 ginger。为此，需要另一个通道。</li><li>在 tech 中，打开一个通道，通过 SHH 将端口 5999 转发到 blackbox 上的端口 5999。这通过运行以下命令完成：</p><pre class=\"crayon-plain-tag\">root@tech:~# ssh -L 5999:localhost:5999 thedude@blackbox.example.com</pre><p>这次使用的 SSH 标记为 <code>-L</code>，它不是将 5999 放到 blackbox，而是从中获取。到达 blackbox 后，需要保持此会话为打开状态。现在即可在 tech 中使用 VNC 了！</li><li>在 tech 中，运行以下命令使 VNC 连接到 ginger：</p><pre class=\"crayon-plain-tag\">root@tech:~# vncviewer localhost:99</pre><p>.Tech 现在将拥有一个直接到 ginger 的 VNC 会话。</li></ol><p>设置虽然有点麻烦，但比为修复存储阵列而四处奔波强多了。不过多实践几次这就变得容易了。</p><p>对此技巧我还要补充一点：如果 tech 运行的是 Windows® 操作系统，并且没有命令行 SSH 客户端，那么 tech 可以运行 Putty。Putty 可以设置为通过查找侧栏中的选项来转发 SSH 端口。如果端口是 5902 而不是本例中的 5999，则可以输入图 5 中的内容。</p><h5 id=\"fig5\">图 5. Putty 可以转发用作通道的 SSH</h5><p><img class=\"alignnone size-full wp-image-104061\" src=\"http://jbcdn2.b0.upaiyun.com/2016/08/c81a100ab2da1fef06474283f5e4e771.jpg\" alt=\"figure5\" /></p><p>如果进行了此设置，那么 tech 就可以使用 VNC 连接到 localhost:2，如同 tech 正在 Linux 操作系统上运行一样。</p><h2 id=\"T7\">技巧 7：检查带宽</h2><p>设想：公司 A 有一个名为 ginger 的存储服务器，并通过名为 beckham 的客户端节点装载 NFS。公司 A 确定他们需要从 ginger 得到更多的带宽，因为有大量的节点需要 NFS 装载 ginger 的共享文件系统。</p><p>实现此操作的最常用和最便宜的方式是将两个吉比特以太网 NIC 组合在一起。这是最便宜的，因为您通常会有一个额外的可用 NIC 和一个额外的端口。</p><p>所以采取此这个方法。不过现在的问题是：到底需要多少带宽？</p><p>吉比特以太网理论上的限制是 128MBit/s。这个数字从何而来？看看这些计算：</p><p><em>1Gb = 1024Mb</em>；<em>1024Mb/8 = 128MB</em>；&#8221;b&#8221; = &#8220;bits,&#8221;、&#8221;B&#8221; = &#8220;bytes&#8221;</p><p>但实际看到的是什么呢，有什么好的测量方法呢？我推荐一个工具 iperf。可以按照以下方法获得 iperf：</p><pre class=\"crayon-plain-tag\"># wget http://dast.nlanr.net/Projects/Iperf2.0/iperf-2.0.2.tar.gz</pre><p>需要在 ginger 和 beckham 均可见的共享文件系统上安装此工具，或者在两个节点上编译并安装。我将在两个节点均可见的 bob 用户的主目录中编译它：</p><pre class=\"crayon-plain-tag\">tar zxvf iperf*gz
cd iperf-2.0.2
./configure -prefix=/home/bob/perf
make
make install</pre><p>在 ginger 上，运行：</p><pre class=\"crayon-plain-tag\"># /home/bob/perf/bin/iperf -s -f M</pre><p>这台机器将用作服务器并以 MBit/s 为单位输出执行速度。</p><p>在 beckham 节点上，运行：</p><pre class=\"crayon-plain-tag\"># /home/bob/perf/bin/iperf -c ginger -P 4 -f M -w 256k -t 60</pre><p>两个屏幕上的结果都指示了速度是多少。在使用吉比特适配器的普通服务器上，可能会看到速度约为 112MBit/s。这是 TCP 堆栈和物理电缆中的常用带宽。通过以端到端的方式连接两台服务器，每台服务器使用两个联结的以太网卡，我获得了约 220MBit/s 的带宽。</p><p>事实上，在联结的网络上看到的 NFS 约为 150-160MBit/s。这仍然表示带宽可以达到预期效果。如果看到更小的值，则应该检查是否有问题。</p><p>我最近碰到一种情况，即通过连接驱动程序连接两个使用了不同驱动程序的 NIC。这导致性能非常低，带宽约为 20MBit/s，比不连接以太网卡时的带宽还小！</p><h2 id=\"T8\">技巧 8：命令行脚本和实用程序</h2><p>Linux 系统管理员通过使用权威的命令行脚本会变得更高效。这包括巧妙使用循环和知道如何使用 <code>awk</code>、<code>grep</code> 和 <code>sed</code> 等的实用程序解析数据。通常这可以减少击键次数，降低用户出错率。</p><p>例如，假设需要为即将安装的 Linux 集群生成一个新的 /etc/hosts 文件。一般的做法是在 vi 或文本编辑器中添加 IP 地址。不过，可以通过使用现有 /etc/hosts 文件并将以下内容追加到此文件来实现。在命令行上运行：</p><pre class=\"crayon-plain-tag\"># P=1; for i in $(seq -w 200); do echo \"192.168.99.$P n$i\"; P=$(expr $P + 1);
done &gt;&gt;/etc/hosts</pre><p>200 个主机名（n001 到 n200）将由 IP 地址（192.168.99.1 到 192.168.99.200）来创建。手动填充这样的文件有可能会创建重复的 IP 地址或主机名，因此这是使用内置命令行消除用户错误的好例子。请注意，这是在 bash shell（大多数 Linux 发行版的默认值）内完成的。</p><p>再举一个例子，假设要检查 Linux 集群中的各个计算节点中的内存大小是否一样。通常，拥有一个发行版或类似的 shell 是最好的。但是为了演示，以下使用 SSH。</p><p>假设 SSH 设置为不使用密码验证。然后运行：</p><pre class=\"crayon-plain-tag\"># for num in $(seq -w 200); do ssh n$num free -tm | grep Mem | awk '{print $2}';
done | sort | uniq</pre><p>这样的命令行相当简洁。（如果在其中放入正则表达式情况会更糟）。让我们对它进行细分，详细讨论各部分。</p><p>首先从 001 循环到 200。使用 <code>seq</code> 命令的 <code>-w</code> 选项在前面填充 0。 然后替换 <code>num</code> 变量，创建通过 SSH 连接的主机。有了目标主机后，向它发出命令。本例中是：</p><pre class=\"crayon-plain-tag\">free -m | grep Mem | awk '{print $2}'</pre><p>这个命令的意思是：</p><ul><li>使用 <code>free</code> 命令获取以兆字节为单位的内存大小。</li><li>获取这个命令的结果，并使用 <code>grep</code> 获取包含字符串 <code>Mem</code> 的行。</li><li>获取那一行并使用 <code>awk</code> 输出第二个字段，它是节点中的总内存。</li></ul><p>在每个节点上执行这个操作。</p><p>在每个节点上执行命令后，200 个节点的整个输出就传送（<code>|</code>d）到 <code>sort</code> 命令，以对所有内存值进行排序。</p><p>最后，使用 <code>uniq</code> 命令消除重复项。这个命令会导致以下情况中的一种：</p><ul><li>如果所有节点（n001 到 n200）拥有相同的内存大小，则只显示一个数字。这个数字就是每个操作系统看到的内存大小。</li><li>如果节点内存大小不同，将会看到几个内存大小的值。</li><li>最后，如果某个节点上的 SSH 出现故障，则会看到一些错误消息。</li></ul><p>这个命令并不是完美无缺的。如果发现与预期不同的内存值，您就不知道是哪一个节点出了问题，或者有多少个节点。为此需要发出另一个命令。</p><p>这个技巧提供了一种查看某些内容的快速方式，而且如果发生错误，您可以立刻知道。其价值在于快速检查。</p><h2 id=\"T9\">技巧 9：控制台侦察</h2><p>有些软件会向控制台输出错误消息，而控制台不一定会显示在 SHH 会话中。使用 vcs 设备可以进行检查。在 SSH 会话中，在远程服务器 <code># cat /dev/vcs1</code> 上运行以下命令。这将显示第一个控制台中的内容。也可以使用 2、3 等查看其他虚拟终端。如果某个用户在远程系统上输入，您将看到他输入的内容。</p><p>在大多数数据场中，使用远程终端服务器、KVM 甚至 Serial Over LAN 是查看这类信息的最好方式；它也提供了带外查看功能的一些好处。使用 vcs 设备能够提供一种快速带内方法，这能节省去机房查看控制台的时间。</p><h2 id=\"T10\">技巧 10：随机系统信息收集</h2><p>在 <a href=\"#T8\">技巧 8</a> 中，介绍了一个使用命令行获取有关系统中总内存信息的例子。在这个技巧中，我将介绍几个其他方法，用于从需要进行验证、故障诊断或给予远程支持的系统收集重要信息。</p><p>首先，收集关于处理器的信息。通过以下命令很容易实现：</p><pre class=\"crayon-plain-tag\"># cat /proc/cpuinfo</pre><p>这个命令给出关于处理器的速度、数量和型号的信息。在许多情况下使用 <code>grep</code> 可以得到需要的值。</p><p>我经常做的检查是确定系统中处理器的数量。因此，如果我买了一台带双核处理器的四核服务器，我可以运行以下命令：</p><pre class=\"crayon-plain-tag\"># cat /proc/cpuinfo | grep processor | wc -l</pre><p>然后我看到值应该是 8。如果不是，我会打电话给供应商，让他们给我派送另一台处理器。</p><p>我需要的另一条信息是磁盘信息。可以使用 <code>df</code> 命令获得。我总是添加 <code>-h</code> 标记，以便看到以十亿字节或兆字节为单位的输出。<code># df -h</code> 还会显示磁盘的分区情况。</p><p>列表最后是查看系统固件的方式 —— 一个获取 BIOS 级别和 NIC 上的固件信息的方法。</p><p>要检查 BIOS 版本，可以运行 <code>dmidecode</code> 命令。遗憾的是，不能轻易使用 <code>grep</code> 获取信息，所以这不是一个很有效的方法。对于我的 Lenovo T61 laptop，输出如下：</p><pre class=\"crayon-plain-tag\">#dmidecode | less
...
BIOS Information
Vendor: LENOVO
Version: 7LET52WW (1.22 )
Release Date: 08/27/2007
...</pre><p>这比重启机器并查看 POST 输出有效得多。</p><p>要检查以太网适配器的驱动程序和固件版本，请运行 <code>ethtool</code>：</p><pre class=\"crayon-plain-tag\"># ethtool -i eth0
driver: e1000
version: 7.3.20-k2-NAPI
firmware-version: 0.3-0</pre><p></p><h2 id=\"N102CC\">结束语</h2><p>可以从精通命令行的人那里学习很多技巧。最好的学习方式是：</p><ul><li>与其他人一起工作。共享屏幕会话并观察其他人是如何工作的 —— 您会发现新的做事方法。可能需要谦虚一点，让其他人引导，不过通常可以学到很多东西。</li><li>阅读手册页。认真阅读手册页，即使是熟知的命令，也能获得更深的见解。例如，您以前可能根本不知道可以使用 <code>awk</code> 进行网络编程。</li><li>解决问题。作为系统管理员，总是要解决问题，不管是您还是其他人引起的问题。这就是经验，经验可以使您更优秀、更高效。</li></ul><p>我希望至少有一个技巧能帮助您学习到您不知道的知识。像这样的基本技巧可以使您更高效，并且能增长经验，但最重要的是，技巧可以让您有更多的空闲时间去做自己感兴趣的事情，比如玩电子游戏。最好的管理员比较悠闲，因为他们不喜欢工作。他们能找到完成任务的最快方法，并且能快速完成任务，从而保持休闲的生活。</p><div class=\"wp_rp_wrap  wp_rp_plain\" ><div class=\"wp_rp_content\"><h3 class=\"related_post_title\">相关文章</h3><ul class=\"related_post wp_rp\" style=\"visibility: visible\"><li ><a href=\"http://blog.jobbole.com/97676/\" class=\"wp_rp_title\">基于 JavaScript 的操作系统你听说过吗？</a></li><li ><a href=\"http://blog.jobbole.com/53821/\" class=\"wp_rp_title\">写给系统管理员的25个PHP安全实践</a></li><li ><a href=\"http://blog.jobbole.com/93132/\" class=\"wp_rp_title\">Linux Shell 管道命令(pipe)使用及与 Shell 重定向区别</a></li><li ><a href=\"http://blog.jobbole.com/36375/\" class=\"wp_rp_title\">在服务器上排除问题的头五分钟</a></li><li ><a href=\"http://blog.jobbole.com/76103/\" class=\"wp_rp_title\">SysAdmim 必备：系统性能大牛 Brendan Gregg 分享的 Linux 性能工具</a></li><li ><a href=\"http://blog.jobbole.com/80575/\" class=\"wp_rp_title\">18款开源/商用的Linux服务器控制面板</a></li><li ><a href=\"http://blog.jobbole.com/33790/\" class=\"wp_rp_title\">高效使用 SSH 的 16 个技巧</a></li><li ><a href=\"http://blog.jobbole.com/92792/\" class=\"wp_rp_title\">Linux Shell 创建序列数组</a></li><li ><a href=\"http://blog.jobbole.com/103561/\" class=\"wp_rp_title\">从业 30 年的女系统管理员的经验分享</a></li><li ><a href=\"http://blog.jobbole.com/49497/\" class=\"wp_rp_title\">给 Linux 系统“减肥”</a></li></ul></div></div><p><a href=\"http://blog.jobbole.com/104056/\">“懒惰” Linux 管理员的 10 个关键技巧</a>，首发于<a href=\"http://blog.jobbole.com\">文章 - 伯乐在线</a>。</p>"))) ("Linux 系统中一些针对文件系统的节能技巧" "<p>文件系统是 Linux 系统的重要组成部分，文件系统的配置和使用对整个系统的运行有着重要的影响。本文介绍了一些 Linux 系统上对文件系统的配置技巧，达到节省能耗并目的，有的技巧还可以提高系统的性能。虽然文件系统的节能成效比起 CPU 和显示器的节能来显得比较轻微，但是积少成多，绿色的地球将靠我们一点一滴来完成。</p><p>本文假设用户的主要文件系统驻留在硬盘之上。硬盘是系统 中相对于 CPU、内存等设备来说活动时间比较少的部件。如果硬盘处于空闲状态时，耗电量是很少的；而在启动进行读写的时候，耗电量会大大增加。所以通过文件系统节 能的核心思想就是，尽量减少磁盘 I/O，使硬盘更多的处于空闲状态。</p><h2 id=\"major1\">对 atime 的处理</h2><p>根 据 POSIX 的规定，Linux 以及 Unix 等系统都要为系统中的所有文件记录文件的最后访问时间，叫做 atime。对于某些应用来说，atime 是很重要的信息。比如一些邮件程序会通过邮件文件的 atime 来判断此邮件是否已读；一些备份和清理程序会根据文件在多长时间内没有被访问，来决定是否对文件进行清理和归档。</p><p>但是对于大部分应用来 说，atime 信息并不重要，而系统更新 atime 所带来的开销却是巨大的。因为系统每访问一次某个文件，就要对这个文件更新一个新的 atime 时间值。我这里所说的访问，并不是从用户角度来看的打开一个文件，而是系统底层的每一次 open 和 read 等操作。设想一下，我们每对文件进行一次读操作，都要引起一个对磁盘的写操作，即使我们要读的内容已经存在于内存的 Page Cache 中，还是要对磁盘进行一个写操作。这样引起的开销确实是巨大的，这些写操作会使磁盘更多的处于忙碌状态，这对系统性能（因为磁盘在完成一个写操作的时候会 暂时阻止其他的写操作）以及电量消耗都是不利的。</p><p>所以，如果用户可以确定自己的应用不会使用到文件的 atime 信息，则可以禁止 atime 的更新。对于整个文件系统，mount 命令的 noatime 选项可以使整个文件系统下的文件都不会进行 atime 的更新。可以使用如下命令：</p><div class=\"codesection\"><pre class=\"crayon-plain-tag\">mount -o remount,noatime  /</pre></div><p>也可以将 noatime 选项写在 /etc/fstab 文件里。</p><p>如果不想对整个文件系统禁止 atime 更新，而只是想针对某些文件或目录禁止，则可以通过 chattr 命令来完成，如下面的命令：</p><div class=\"codesection\"><pre class=\"crayon-plain-tag\">chattr -R +A /some/dir</pre></div><p>可以对某个目录及其下面的所有文件禁止 atime 更新。</p><p>除了 noatime，还有两个和 atime 相关的文件系统选项。一个是 nodiratime，此选项只针对目录禁止进行 atime 更新（注意 noatime 对文件和目录都生效，是 nodiratime 的超集）。这样就可以使 <code>ls</code>这样的命令不会更新目录的 atime 值。</p><p>对 于某些用户某些应用，atime 信息可能是必要的，比如本节一开始提到的邮件程序和备份工具。如果完全禁止 atime 更新会使这些程序无法正常工作。针对这种情况，Linux 在内核 2.6.20 中添加了一个新的 mount 选项 relatime（relative atime 的意思）。relatime 的意思是访问文件时，仅在 atime 早于文件的更改时间时对 atime 进行更新。在内核 2.6.24 中，又对 relatime 进行了扩展，在访问文件时，当 atime 已经超过某个时间（例如一天）没有更新，就对 atime 进行更新。这个扩展的意思就是调整 atime 的更新粒度。</p><p>目前 relatime 还没有被广泛的应用，因为许多 Linux 发行版的内核版本和 mount 命令还没有支持这个选项。如果你的系统支持 relatime，可以使用如下命令启用：</p><div class=\"codesection\"><pre class=\"crayon-plain-tag\">mount -o remount,relatime  /</pre></div><h2 id=\"major2\">调节 Page Cache 和 VM 系统</h2><h3 id=\"minor2.1\">调节 Page Cache</h3><p>在 Linux 的内核中，对文件的读写提供一个页面缓冲的机制（Page Cache）。Page Cache 存在于内存中，当要读取一个磁盘文件的内容时，内核首先在 Page Cache 中进行查找，如果要读取的内容已经存在 Page Cache 中，则无需在对磁盘发起实际的读操作。同样在需要写文件时，写操作也只是将内容存放于 Page Cache 中，而 Page Cache 中的更改内容由内核进程 pdflush 周期性的写回磁盘。在默认情况下，pdflush 进程每 5 秒钟醒来一次，进行数据写回操作。这个写回时间值定义在参数 <strong>/proc/sys/vm/dirty_writeback_centisecs</strong>中。如果在这 5 秒钟之间，发生电源故障或者系统崩溃，可能会引起数据丢失。如果用户的电源供应比较可靠，或者丢数据丢失的风险不是非常在意，可以适当的提高这个数据写回时间。使用如下命令查看系统当前的写回时间值：</p><div class=\"codesection\"><pre class=\"crayon-plain-tag\">cat /proc/sys/vm/dirty_writeback_centisecs
500</pre></div><p>此时间值的单位为 1/100 秒。使用如下命令可以更改此值：</p><div class=\"codesection\"><pre class=\"crayon-plain-tag\">echo 2000 &amp;gt; /proc/sys/vm/dirty_writeback_centisecs</pre></div><p>这样，就可以使 pdflush 进程 20 秒才醒来一次，从而减少对磁盘的访问频率。</p><p>还有一个参数 <strong>/proc/sys/vm/dirty_expire_centisecs</strong>控制一个更改过的页面经过多长时间后被认为是过期的、必须被写回的页面，其默认值是 3000（单位也是 1/100 秒）。用户也可以适当的增加此值，使页面更长时间的驻留在内存中。如下命令：</p><div class=\"codesection\"><pre class=\"crayon-plain-tag\">echo 4000 &amp;gt; /proc/sys/vm/dirty_expire_centisecs</pre></div><p>pdflush 进程处理的另一种情况是当可用内存量降低的时候，会将一些缓冲页面写回磁盘，释放内存。这个行为是受 <strong>/proc/sys/vm/dirty_background_ratio</strong>参数控制的，此参数的默认值为 10，意思是当所有被更改页面总大小占工作内存超过 10% 时，pdflush 会开始写回工作。用户可以增加这个比例，以增加页面驻留在内存的时间。此参数的更改方法同上面两个参数。</p><h3 id=\"minor2.2\">Swap 分区或文件</h3><p>在 默认情况下，Linux 内核并不是只有在物理内存不够用的时候才进行交换，而是为了保证尽量大的磁盘缓冲以及其他一些原因，会尽可能的将非活动的进程及内存页面交换出内存，放在 磁盘上的交换分区中。这种默认行为使得在还有大量内存可用的情况下，就会发生交换操作，而释放出的物理内存并没有被利用起来，显然这些交换操作是不必要 的。为了减少因交换引起的磁盘读写，在用户内存足够大的时候，可以考虑禁用 swap 分区。</p><h2 id=\"major3\">使用“笔记本模式”（laptop mode）</h2><p>在 2.6.6 以后，Linux 内核在 I/O 系统上支持一种“笔记本模式”。在“笔记本模式”下，内核更智能的使用 I/O 系统，它会尽量使磁盘处于低能耗的状态下。“笔记本模式”会将许多的 I/O 操作组织在一起，一次完成，而在每次的磁盘 I/O 之间是默认长达 10 分钟的非活动期，这样会大大减少磁盘启动的次数。为了完成这么长时间的非活动期，内核就要在一次活动期时完成尽可能多的 I/O 任务。在一次活动期间，要完成大量的预读，然后将所有的缓冲同步。在非活动期间，写操作会被阻挡在内存中（读操作如果无法在 Cache 中满足，则无法阻挡，因为用户无法忍受这么长时间的延迟）。“笔记本模式”会根据需要设置上节介绍的参数来达到适当的目的。</p><p>使用如下命令查看“笔记本模式”是否启用：</p><div class=\"codesection\"><pre class=\"crayon-plain-tag\">cat /proc/sys/vm/laptop_mode
0</pre></div><p>0 表示没有启用，可以使用如下命令启用：</p><div class=\"codesection\"><pre class=\"crayon-plain-tag\">echo 5 &amp;gt; /proc/sys/vm/laptop_mode</pre></div><h2 id=\"major4\">配置 syslog</h2><p>Linux 使用 syslog 记录内核和各种应用程序的日志信息。Linux 系统里存在一个 Daemon 进程 syslogd 或 sysklogd 来完成 syslog 的功能。默认设置下，syslogd 在每次记录一条日志后，都会使用同步（sync）操作强制将页面缓存同步到磁盘上。这样做是为了保证日志信息得到最大的保护，即使系统崩溃或电源故障，日 志信息可以最大可能的被写到了磁盘上。</p><p>但是在个人电脑等对日志信息要求不是如此严格的系统上，这些 sync 操作很耗费磁盘 I/O，同时耗费更多的电量。如果想禁止 syslog 的这种 sync 行为，需要修改 syslog 配置文件 /etc/syslog.conf，在不想进行 sync 操作的项目前添加一个“-”（减号）。</p><p>如将下面这一行：</p><div class=\"codesection\"><pre class=\"crayon-plain-tag\">*.info;mail.none;authpriv.none;cron.none      /var/log/messages</pre></div><p>改为：</p><div class=\"codesection\"><pre class=\"crayon-plain-tag\">*.info;mail.none;authpriv.none;cron.none      -/var/log/messages</pre></div><p>对于不是特别重要的日志信息，都可以采用以上方法禁止 sync 行为。</p><p>用户也可以根据自己的需要，将 /etc/syslog.conf 里不必要的日志项去掉，甚至可以将 syslogd 停掉，以节省磁盘 I/O。</p><h2 id=\"major5\">使用 tmpfs</h2><p>tmpfs（temporary file system）是一种基于内存的文件系统，类似于虚拟磁盘 ramdisk，但还是有很大不同。传统的 ramdisk 是一个块设备，而 tmpfs 是一个文件系统，并不是块设备，只是安装它，就可以使用。tmpfs 一开始使用很小的空间，但随着文件的复制和创建，tmpfs 文件系统会分配更多的内存，并按照需求动态地增加文件系统的空间。而且，当 tmpfs 中的文件被删除时，tmpfs 文件系统会动态地减小文件系统并释放内存资源。但是 tmpfs 中的内容会在文件系统卸载后丢失。</p><p>用户可以将 tmpfs 应用于 /tmp 目录，这样在系统运行时产生的临时文件，以及对这些临时文件的读写都只发生在内存里，而不会引起任何的磁盘 I/O。</p><p>如要使用最大为 100M 的 tmpfs 在 /tmp 目录上，可以将以下这行添加到 /etc/fstab 中：</p><div class=\"codesection\"><pre class=\"crayon-plain-tag\">tmpfs 	 /tmp 	 tmpfs 	 size=100m,mode=1777 	 0 0</pre></div><div class=\"wp_rp_wrap  wp_rp_plain\" ><div class=\"wp_rp_content\"><h3 class=\"related_post_title\">相关文章</h3><ul class=\"related_post wp_rp\" style=\"visibility: visible\"><li ><a href=\"http://blog.jobbole.com/93132/\" class=\"wp_rp_title\">Linux Shell 管道命令(pipe)使用及与 Shell 重定向区别</a></li><li ><a href=\"http://blog.jobbole.com/92792/\" class=\"wp_rp_title\">Linux Shell 创建序列数组</a></li><li ><a href=\"http://blog.jobbole.com/104042/\" class=\"wp_rp_title\">如何在 Linux 下检测内存泄漏</a></li><li ><a href=\"http://blog.jobbole.com/97676/\" class=\"wp_rp_title\">基于 JavaScript 的操作系统你听说过吗？</a></li><li ><a href=\"http://blog.jobbole.com/104056/\" class=\"wp_rp_title\">“懒惰” Linux 管理员的 10 个关键技巧</a></li><li ><a href=\"http://blog.jobbole.com/89886/\" class=\"wp_rp_title\">linux内核动态加载模块 </a></li><li ><a href=\"http://blog.jobbole.com/71671/\" class=\"wp_rp_title\">Linux 网络文件系统的数据备份及恢复机制实现</a></li><li ><a href=\"http://blog.jobbole.com/93375/\" class=\"wp_rp_title\">Linux /dev 常见特殊设备介绍与应用</a></li><li ><a href=\"http://blog.jobbole.com/93404/\" class=\"wp_rp_title\">Linux Shell man 命令详细介绍</a></li><li ><a href=\"http://blog.jobbole.com/22318/\" class=\"wp_rp_title\">使用Shell脚本对Linux系统和进程资源进行监控</a></li></ul></div></div><p><a href=\"http://blog.jobbole.com/104051/\">Linux 系统中一些针对文件系统的节能技巧</a>，首发于<a href=\"http://blog.jobbole.com\">文章 - 伯乐在线</a>。</p>" "http://blog.jobbole.com/104051/" (22430 55398) old 13 nil nil ((title nil "Linux 系统中一些针对文件系统的节能技巧") (link nil "http://blog.jobbole.com/104051/") (comments nil "http://blog.jobbole.com/104051/#respond") (pubDate nil "Mon, 01 Aug 2016 05:04:38 +0000") (dc:creator nil "黄山松") (category nil "IT技术") (category nil "Linux") (guid ((isPermaLink . "false")) "http://blog.jobbole.com/?p=104051") (description nil "<p>文件系统是 Linux 系统的重要组成部分，文件系统的配置和使用对整个系统的运行有着重要的影响。本文介绍了一些 Linux 系统上对文件系统的配置技巧，达到节省能耗并目的，有的技巧还可以提高系统的性能。虽然文件系统的节能成效比起 CPU 和显示器的节能来显得比较轻微，但是积少成多，绿色的地球将靠我们一点一滴来完成。</p><p><a href=\"http://blog.jobbole.com/104051/\">Linux 系统中一些针对文件系统的节能技巧</a>，首发于<a href=\"http://blog.jobbole.com\">文章 - 伯乐在线</a>。</p>") (content:encoded nil "<p>文件系统是 Linux 系统的重要组成部分，文件系统的配置和使用对整个系统的运行有着重要的影响。本文介绍了一些 Linux 系统上对文件系统的配置技巧，达到节省能耗并目的，有的技巧还可以提高系统的性能。虽然文件系统的节能成效比起 CPU 和显示器的节能来显得比较轻微，但是积少成多，绿色的地球将靠我们一点一滴来完成。</p><p>本文假设用户的主要文件系统驻留在硬盘之上。硬盘是系统 中相对于 CPU、内存等设备来说活动时间比较少的部件。如果硬盘处于空闲状态时，耗电量是很少的；而在启动进行读写的时候，耗电量会大大增加。所以通过文件系统节 能的核心思想就是，尽量减少磁盘 I/O，使硬盘更多的处于空闲状态。</p><h2 id=\"major1\">对 atime 的处理</h2><p>根 据 POSIX 的规定，Linux 以及 Unix 等系统都要为系统中的所有文件记录文件的最后访问时间，叫做 atime。对于某些应用来说，atime 是很重要的信息。比如一些邮件程序会通过邮件文件的 atime 来判断此邮件是否已读；一些备份和清理程序会根据文件在多长时间内没有被访问，来决定是否对文件进行清理和归档。</p><p>但是对于大部分应用来 说，atime 信息并不重要，而系统更新 atime 所带来的开销却是巨大的。因为系统每访问一次某个文件，就要对这个文件更新一个新的 atime 时间值。我这里所说的访问，并不是从用户角度来看的打开一个文件，而是系统底层的每一次 open 和 read 等操作。设想一下，我们每对文件进行一次读操作，都要引起一个对磁盘的写操作，即使我们要读的内容已经存在于内存的 Page Cache 中，还是要对磁盘进行一个写操作。这样引起的开销确实是巨大的，这些写操作会使磁盘更多的处于忙碌状态，这对系统性能（因为磁盘在完成一个写操作的时候会 暂时阻止其他的写操作）以及电量消耗都是不利的。</p><p>所以，如果用户可以确定自己的应用不会使用到文件的 atime 信息，则可以禁止 atime 的更新。对于整个文件系统，mount 命令的 noatime 选项可以使整个文件系统下的文件都不会进行 atime 的更新。可以使用如下命令：</p><div class=\"codesection\"><pre class=\"crayon-plain-tag\">mount -o remount,noatime  /</pre></div><p>也可以将 noatime 选项写在 /etc/fstab 文件里。</p><p>如果不想对整个文件系统禁止 atime 更新，而只是想针对某些文件或目录禁止，则可以通过 chattr 命令来完成，如下面的命令：</p><div class=\"codesection\"><pre class=\"crayon-plain-tag\">chattr -R +A /some/dir</pre></div><p>可以对某个目录及其下面的所有文件禁止 atime 更新。</p><p>除了 noatime，还有两个和 atime 相关的文件系统选项。一个是 nodiratime，此选项只针对目录禁止进行 atime 更新（注意 noatime 对文件和目录都生效，是 nodiratime 的超集）。这样就可以使 <code>ls</code>这样的命令不会更新目录的 atime 值。</p><p>对 于某些用户某些应用，atime 信息可能是必要的，比如本节一开始提到的邮件程序和备份工具。如果完全禁止 atime 更新会使这些程序无法正常工作。针对这种情况，Linux 在内核 2.6.20 中添加了一个新的 mount 选项 relatime（relative atime 的意思）。relatime 的意思是访问文件时，仅在 atime 早于文件的更改时间时对 atime 进行更新。在内核 2.6.24 中，又对 relatime 进行了扩展，在访问文件时，当 atime 已经超过某个时间（例如一天）没有更新，就对 atime 进行更新。这个扩展的意思就是调整 atime 的更新粒度。</p><p>目前 relatime 还没有被广泛的应用，因为许多 Linux 发行版的内核版本和 mount 命令还没有支持这个选项。如果你的系统支持 relatime，可以使用如下命令启用：</p><div class=\"codesection\"><pre class=\"crayon-plain-tag\">mount -o remount,relatime  /</pre></div><h2 id=\"major2\">调节 Page Cache 和 VM 系统</h2><h3 id=\"minor2.1\">调节 Page Cache</h3><p>在 Linux 的内核中，对文件的读写提供一个页面缓冲的机制（Page Cache）。Page Cache 存在于内存中，当要读取一个磁盘文件的内容时，内核首先在 Page Cache 中进行查找，如果要读取的内容已经存在 Page Cache 中，则无需在对磁盘发起实际的读操作。同样在需要写文件时，写操作也只是将内容存放于 Page Cache 中，而 Page Cache 中的更改内容由内核进程 pdflush 周期性的写回磁盘。在默认情况下，pdflush 进程每 5 秒钟醒来一次，进行数据写回操作。这个写回时间值定义在参数 <strong>/proc/sys/vm/dirty_writeback_centisecs</strong>中。如果在这 5 秒钟之间，发生电源故障或者系统崩溃，可能会引起数据丢失。如果用户的电源供应比较可靠，或者丢数据丢失的风险不是非常在意，可以适当的提高这个数据写回时间。使用如下命令查看系统当前的写回时间值：</p><div class=\"codesection\"><pre class=\"crayon-plain-tag\">cat /proc/sys/vm/dirty_writeback_centisecs 
 500</pre></div><p>此时间值的单位为 1/100 秒。使用如下命令可以更改此值：</p><div class=\"codesection\"><pre class=\"crayon-plain-tag\">echo 2000 &amp;gt; /proc/sys/vm/dirty_writeback_centisecs</pre></div><p>这样，就可以使 pdflush 进程 20 秒才醒来一次，从而减少对磁盘的访问频率。</p><p>还有一个参数 <strong>/proc/sys/vm/dirty_expire_centisecs</strong>控制一个更改过的页面经过多长时间后被认为是过期的、必须被写回的页面，其默认值是 3000（单位也是 1/100 秒）。用户也可以适当的增加此值，使页面更长时间的驻留在内存中。如下命令：</p><div class=\"codesection\"><pre class=\"crayon-plain-tag\">echo 4000 &amp;gt; /proc/sys/vm/dirty_expire_centisecs</pre></div><p>pdflush 进程处理的另一种情况是当可用内存量降低的时候，会将一些缓冲页面写回磁盘，释放内存。这个行为是受 <strong>/proc/sys/vm/dirty_background_ratio</strong>参数控制的，此参数的默认值为 10，意思是当所有被更改页面总大小占工作内存超过 10% 时，pdflush 会开始写回工作。用户可以增加这个比例，以增加页面驻留在内存的时间。此参数的更改方法同上面两个参数。</p><h3 id=\"minor2.2\">Swap 分区或文件</h3><p>在 默认情况下，Linux 内核并不是只有在物理内存不够用的时候才进行交换，而是为了保证尽量大的磁盘缓冲以及其他一些原因，会尽可能的将非活动的进程及内存页面交换出内存，放在 磁盘上的交换分区中。这种默认行为使得在还有大量内存可用的情况下，就会发生交换操作，而释放出的物理内存并没有被利用起来，显然这些交换操作是不必要 的。为了减少因交换引起的磁盘读写，在用户内存足够大的时候，可以考虑禁用 swap 分区。</p><h2 id=\"major3\">使用“笔记本模式”（laptop mode）</h2><p>在 2.6.6 以后，Linux 内核在 I/O 系统上支持一种“笔记本模式”。在“笔记本模式”下，内核更智能的使用 I/O 系统，它会尽量使磁盘处于低能耗的状态下。“笔记本模式”会将许多的 I/O 操作组织在一起，一次完成，而在每次的磁盘 I/O 之间是默认长达 10 分钟的非活动期，这样会大大减少磁盘启动的次数。为了完成这么长时间的非活动期，内核就要在一次活动期时完成尽可能多的 I/O 任务。在一次活动期间，要完成大量的预读，然后将所有的缓冲同步。在非活动期间，写操作会被阻挡在内存中（读操作如果无法在 Cache 中满足，则无法阻挡，因为用户无法忍受这么长时间的延迟）。“笔记本模式”会根据需要设置上节介绍的参数来达到适当的目的。</p><p>使用如下命令查看“笔记本模式”是否启用：</p><div class=\"codesection\"><pre class=\"crayon-plain-tag\">cat /proc/sys/vm/laptop_mode 
 0</pre></div><p>0 表示没有启用，可以使用如下命令启用：</p><div class=\"codesection\"><pre class=\"crayon-plain-tag\">echo 5 &amp;gt; /proc/sys/vm/laptop_mode</pre></div><h2 id=\"major4\">配置 syslog</h2><p>Linux 使用 syslog 记录内核和各种应用程序的日志信息。Linux 系统里存在一个 Daemon 进程 syslogd 或 sysklogd 来完成 syslog 的功能。默认设置下，syslogd 在每次记录一条日志后，都会使用同步（sync）操作强制将页面缓存同步到磁盘上。这样做是为了保证日志信息得到最大的保护，即使系统崩溃或电源故障，日 志信息可以最大可能的被写到了磁盘上。</p><p>但是在个人电脑等对日志信息要求不是如此严格的系统上，这些 sync 操作很耗费磁盘 I/O，同时耗费更多的电量。如果想禁止 syslog 的这种 sync 行为，需要修改 syslog 配置文件 /etc/syslog.conf，在不想进行 sync 操作的项目前添加一个“-”（减号）。</p><p>如将下面这一行：</p><div class=\"codesection\"><pre class=\"crayon-plain-tag\">*.info;mail.none;authpriv.none;cron.none      /var/log/messages</pre></div><p>改为：</p><div class=\"codesection\"><pre class=\"crayon-plain-tag\">*.info;mail.none;authpriv.none;cron.none      -/var/log/messages</pre></div><p>对于不是特别重要的日志信息，都可以采用以上方法禁止 sync 行为。</p><p>用户也可以根据自己的需要，将 /etc/syslog.conf 里不必要的日志项去掉，甚至可以将 syslogd 停掉，以节省磁盘 I/O。</p><h2 id=\"major5\">使用 tmpfs</h2><p>tmpfs（temporary file system）是一种基于内存的文件系统，类似于虚拟磁盘 ramdisk，但还是有很大不同。传统的 ramdisk 是一个块设备，而 tmpfs 是一个文件系统，并不是块设备，只是安装它，就可以使用。tmpfs 一开始使用很小的空间，但随着文件的复制和创建，tmpfs 文件系统会分配更多的内存，并按照需求动态地增加文件系统的空间。而且，当 tmpfs 中的文件被删除时，tmpfs 文件系统会动态地减小文件系统并释放内存资源。但是 tmpfs 中的内容会在文件系统卸载后丢失。</p><p>用户可以将 tmpfs 应用于 /tmp 目录，这样在系统运行时产生的临时文件，以及对这些临时文件的读写都只发生在内存里，而不会引起任何的磁盘 I/O。</p><p>如要使用最大为 100M 的 tmpfs 在 /tmp 目录上，可以将以下这行添加到 /etc/fstab 中：</p><div class=\"codesection\"><pre class=\"crayon-plain-tag\">tmpfs 	 /tmp 	 tmpfs 	 size=100m,mode=1777 	 0 0</pre></div><div class=\"wp_rp_wrap  wp_rp_plain\" ><div class=\"wp_rp_content\"><h3 class=\"related_post_title\">相关文章</h3><ul class=\"related_post wp_rp\" style=\"visibility: visible\"><li ><a href=\"http://blog.jobbole.com/93132/\" class=\"wp_rp_title\">Linux Shell 管道命令(pipe)使用及与 Shell 重定向区别</a></li><li ><a href=\"http://blog.jobbole.com/92792/\" class=\"wp_rp_title\">Linux Shell 创建序列数组</a></li><li ><a href=\"http://blog.jobbole.com/104042/\" class=\"wp_rp_title\">如何在 Linux 下检测内存泄漏</a></li><li ><a href=\"http://blog.jobbole.com/97676/\" class=\"wp_rp_title\">基于 JavaScript 的操作系统你听说过吗？</a></li><li ><a href=\"http://blog.jobbole.com/104056/\" class=\"wp_rp_title\">“懒惰” Linux 管理员的 10 个关键技巧</a></li><li ><a href=\"http://blog.jobbole.com/89886/\" class=\"wp_rp_title\">linux内核动态加载模块 </a></li><li ><a href=\"http://blog.jobbole.com/71671/\" class=\"wp_rp_title\">Linux 网络文件系统的数据备份及恢复机制实现</a></li><li ><a href=\"http://blog.jobbole.com/93375/\" class=\"wp_rp_title\">Linux /dev 常见特殊设备介绍与应用</a></li><li ><a href=\"http://blog.jobbole.com/93404/\" class=\"wp_rp_title\">Linux Shell man 命令详细介绍</a></li><li ><a href=\"http://blog.jobbole.com/22318/\" class=\"wp_rp_title\">使用Shell脚本对Linux系统和进程资源进行监控</a></li></ul></div></div><p><a href=\"http://blog.jobbole.com/104051/\">Linux 系统中一些针对文件系统的节能技巧</a>，首发于<a href=\"http://blog.jobbole.com\">文章 - 伯乐在线</a>。</p>") (wfw:commentRss nil "http://blog.jobbole.com/104051/feed/") (slash:comments nil "0"))) ("计算机程序的思维逻辑 (1)：数据和变量" "<h1>程序大概是怎么回事</h1><p>计算机就是个机器，这个机器主要由CPU、内存、硬盘和输入输出设备组成。计算机上跑着操作系统，如Windows或Linux，操作系统上运行着各种应用程序，如Word, QQ等。</p><p>操作系统将时间分成很多细小的时间片，一个时间片给一个程序用，另一个时间片给另一个程序用，并频繁地在程序间切换。不过，在应用程序看来，整个机器资源好像都归他使，操作系统给他提供了这种假象。 对程序员而言，我们写程序，基本不用考虑其他应用程序，我们想好怎么做自己的事就可以了。</p><p>应用程序看上去能做很多事情，能读写文档，能播放音乐，能聊天，能玩游戏，能下围棋 …… 但本质上，计算机只会执行预先写好的指令而已，这些指令也只是操作数据或者设备。所谓程序，基本上就是告诉计算机要操作的数据和执行的指令序列， 即对什么数据做什么操作。</p><p>比如说：</p><ul><li>读文档，就是将数据从磁盘加载到内存，然后输出到显示器上</li><li>写文档，就是将数据从内存写回磁盘。</li><li>播放音乐，就是将音乐的数据加载到内存，然后写到声卡上。</li><li>聊天，就是从键盘接收聊天数据，放到内存，然后传给网卡，通过网络传给另一个人的网卡，再从网卡传到内存，显示在显示器上。</li></ul><p>基本上，所有数据都需要放到内存进行处理，程序的很大一部分工作就是操作在内存中的数据。</p><p>本文主要就说说这个”数据”。（以Java为例）</p><h1>数据</h1><p>数据是什么？数据在计算机内部都是二进制，不方便操作，为了方便操作数据，高级语言引入了”数据类型”和”变量”的概念。</p><h3>数据类型</h3><p>数据类型用于对数据归类，方便理解和操作，对Java语言而言，有如下基本数据类型：</p><ul><li>整数类型：有四种整型 byte/short/int/long，分别有不同的取值范围</li><li>小数类型 ：有两种类型 float/double，有不同的取值范围和精度</li><li>字符类型：char，表示单个字符</li><li>真假类型：boolean，表示真假</li></ul><p>基本数据类型都有对应的数组类型，数组表示固定长度的同种数据类型的多条记录，这些数据在内存中挨在一起存放。 比如说，一个自然数可以用一个整数类型数据表示，100个连续的自然数可以用一个长度为100的整数数组表示。一个字符用一个char表示，一段文字可以用一个char数组表示。</p><p>Java是一个面向对象的语言，除了基本数据类型，其他都是对象类型 ，对象到底是什么呢？简单的说，对象是由基本数据类型、数组和其他对象组合而成的一个东西，以方便对其整体进行操作。</p><p>比如说，一个学生对象，可以由如下信息组成：</p><ul><li>姓名：一个字符数组</li><li>年龄：一个整数</li><li>性别：一个字符</li><li>入学分数：一个小数</li></ul><p>日期在Java中也是一个对象，内部表示为整形long。</p><p>就像世界万物的组成，都是由元素周期表中的108个基本元素组成的，基本数据类型就相当于化学中的基本元素，而对象就相当于世界万物。</p><h3>变量</h3><p>为了操作数据，需要把数据存放到内存中，所谓内存在程序看来就是一块有地址编号的连续的空间，放到内存中的某个位置后，为了方便地找到和操作这个数据，需要给这个位置起一个名字。编程语言通过<strong>变量</strong>这个概念来表示这个过程。</p><p>声明一个变量，比如 int a其实就是在内存中分配了一个空间，这个空间存放int数据类型，a指向这个内存空间所在的位置，通过对a操作即可操作a指向的内存空间，比如a=5这个操作即可将a指向的内存空间的值改为5。</p><p>之所以叫<strong>变</strong>量，是因为它表示的是内存中的位置，这个位置存放的值是可以变化的。</p><p>虽然变量的值是可以变化的，但名字是不变的，这个名字应该代表程序员心目中这块内存位置的意义，这个意义应该是不变的，比如说这个变量int second表示时钟秒数，在不同时间可以被赋予不同的值，但它表示的就是时钟秒数。之所以说<strong>应该</strong>是因为这不是必须的，如果你非要起一个变量名叫age但赋予它身高的值，计算机也拿你没办法。</p><p>重要的话再说一遍！变量就是给数据起名字，方便找不同的数据，它的值可以变，但含义不应变。再比如说一个合同，可以有四个变量：</p><ul><li>first_party: 含义是甲方</li><li>second_party: 含义是乙方</li><li>contract_body: 含义是合同内容</li><li>contract_sign_date: 含义是合同签署日期</li></ul><p>这些变量表示的含义是确定的，但对不同的合同，他们的值是不同的。</p><p>初学编程的人经常使用像a,b,c,hehe,haha这种无意义的名字，给变量起一个有意义的名字吧！</p><p>通过声明变量，每个变量赋予一个数据类型和一个有意义的名字，我们就告诉了计算机我们要操作的数据。</p><p>有了数据，怎么对数据进行操作呢？</p><div class=\"wp_rp_wrap  wp_rp_plain\" ><div class=\"wp_rp_content\"><h3 class=\"related_post_title\">相关文章</h3><ul class=\"related_post wp_rp\" style=\"visibility: visible\"><li ><a href=\"http://blog.jobbole.com/103192/\" class=\"wp_rp_title\">如何给变量取个简短且无歧义的名字</a></li><li ><a href=\"http://blog.jobbole.com/98633/\" class=\"wp_rp_title\">StackOverflow 这么大，它的架构是怎么样的？</a></li><li ><a href=\"http://blog.jobbole.com/93932/\" class=\"wp_rp_title\">你知道计算机在一秒内可以做多少事情吗？</a></li><li ><a href=\"http://blog.jobbole.com/50708/\" class=\"wp_rp_title\">程序员最头疼的事：命名</a></li><li ><a href=\"http://blog.jobbole.com/13593/\" class=\"wp_rp_title\">15 个变量和方法命名的最佳实践</a></li><li ><a href=\"http://blog.jobbole.com/50378/\" class=\"wp_rp_title\">变量教学：类比与方法</a></li><li ><a href=\"http://blog.jobbole.com/85891/\" class=\"wp_rp_title\">实战：上亿数据如何秒查</a></li><li ><a href=\"http://blog.jobbole.com/23274/\" class=\"wp_rp_title\">神舟飞天的秘密：揭秘神舟九号的太空计算机</a></li><li ><a href=\"http://blog.jobbole.com/32268/\" class=\"wp_rp_title\">如何编写计算机模拟器</a></li><li ><a href=\"http://blog.jobbole.com/33224/\" class=\"wp_rp_title\">计算机是如何启动的？</a></li></ul></div></div><p><a href=\"http://blog.jobbole.com/100329/\">计算机程序的思维逻辑 (1)：数据和变量</a>，首发于<a href=\"http://blog.jobbole.com\">文章 - 伯乐在线</a>。</p>" "http://blog.jobbole.com/100329/" (22430 50679) old 14 nil nil ((title nil "计算机程序的思维逻辑 (1)：数据和变量") (link nil "http://blog.jobbole.com/100329/") (comments nil "http://blog.jobbole.com/100329/#respond") (pubDate nil "Mon, 01 Aug 2016 03:45:59 +0000") (dc:creator nil "老马") (category nil "IT技术") (category nil "变量") (category nil "数据") (category nil "计算机") (guid ((isPermaLink . "false")) "http://blog.jobbole.com/?p=100329") (description nil "<p>计算机就是个机器，这个机器主要由CPU、内存、硬盘和输入输出设备组成。计算机上跑着操作系统，如Windows或Linux，操作系统上运行着各种应用程序，如Word, QQ等。</p><p><a href=\"http://blog.jobbole.com/100329/\">计算机程序的思维逻辑 (1)：数据和变量</a>，首发于<a href=\"http://blog.jobbole.com\">文章 - 伯乐在线</a>。</p>") (content:encoded nil "<h1>程序大概是怎么回事</h1><p>计算机就是个机器，这个机器主要由CPU、内存、硬盘和输入输出设备组成。计算机上跑着操作系统，如Windows或Linux，操作系统上运行着各种应用程序，如Word, QQ等。</p><p>操作系统将时间分成很多细小的时间片，一个时间片给一个程序用，另一个时间片给另一个程序用，并频繁地在程序间切换。不过，在应用程序看来，整个机器资源好像都归他使，操作系统给他提供了这种假象。 对程序员而言，我们写程序，基本不用考虑其他应用程序，我们想好怎么做自己的事就可以了。</p><p>应用程序看上去能做很多事情，能读写文档，能播放音乐，能聊天，能玩游戏，能下围棋 &#8230;&#8230; 但本质上，计算机只会执行预先写好的指令而已，这些指令也只是操作数据或者设备。所谓程序，基本上就是告诉计算机要操作的数据和执行的指令序列， 即对什么数据做什么操作。</p><p>比如说：</p><ul><li>读文档，就是将数据从磁盘加载到内存，然后输出到显示器上</li><li>写文档，就是将数据从内存写回磁盘。</li><li>播放音乐，就是将音乐的数据加载到内存，然后写到声卡上。</li><li>聊天，就是从键盘接收聊天数据，放到内存，然后传给网卡，通过网络传给另一个人的网卡，再从网卡传到内存，显示在显示器上。</li></ul><p>基本上，所有数据都需要放到内存进行处理，程序的很大一部分工作就是操作在内存中的数据。</p><p>本文主要就说说这个&#8221;数据&#8221;。（以Java为例）</p><h1>数据</h1><p>数据是什么？数据在计算机内部都是二进制，不方便操作，为了方便操作数据，高级语言引入了&#8221;数据类型&#8221;和&#8221;变量&#8221;的概念。</p><h3>数据类型</h3><p>数据类型用于对数据归类，方便理解和操作，对Java语言而言，有如下基本数据类型：</p><ul><li>整数类型：有四种整型 byte/short/int/long，分别有不同的取值范围</li><li>小数类型 ：有两种类型 float/double，有不同的取值范围和精度</li><li>字符类型：char，表示单个字符</li><li>真假类型：boolean，表示真假</li></ul><p>基本数据类型都有对应的数组类型，数组表示固定长度的同种数据类型的多条记录，这些数据在内存中挨在一起存放。 比如说，一个自然数可以用一个整数类型数据表示，100个连续的自然数可以用一个长度为100的整数数组表示。一个字符用一个char表示，一段文字可以用一个char数组表示。</p><p>Java是一个面向对象的语言，除了基本数据类型，其他都是对象类型 ，对象到底是什么呢？简单的说，对象是由基本数据类型、数组和其他对象组合而成的一个东西，以方便对其整体进行操作。</p><p>比如说，一个学生对象，可以由如下信息组成：</p><ul><li>姓名：一个字符数组</li><li>年龄：一个整数</li><li>性别：一个字符</li><li>入学分数：一个小数</li></ul><p>日期在Java中也是一个对象，内部表示为整形long。</p><p>就像世界万物的组成，都是由元素周期表中的108个基本元素组成的，基本数据类型就相当于化学中的基本元素，而对象就相当于世界万物。</p><h3>变量</h3><p>为了操作数据，需要把数据存放到内存中，所谓内存在程序看来就是一块有地址编号的连续的空间，放到内存中的某个位置后，为了方便地找到和操作这个数据，需要给这个位置起一个名字。编程语言通过<strong>变量</strong>这个概念来表示这个过程。</p><p>声明一个变量，比如 int a其实就是在内存中分配了一个空间，这个空间存放int数据类型，a指向这个内存空间所在的位置，通过对a操作即可操作a指向的内存空间，比如a=5这个操作即可将a指向的内存空间的值改为5。</p><p>之所以叫<strong>变</strong>量，是因为它表示的是内存中的位置，这个位置存放的值是可以变化的。</p><p>虽然变量的值是可以变化的，但名字是不变的，这个名字应该代表程序员心目中这块内存位置的意义，这个意义应该是不变的，比如说这个变量int second表示时钟秒数，在不同时间可以被赋予不同的值，但它表示的就是时钟秒数。之所以说<strong>应该</strong>是因为这不是必须的，如果你非要起一个变量名叫age但赋予它身高的值，计算机也拿你没办法。</p><p>重要的话再说一遍！变量就是给数据起名字，方便找不同的数据，它的值可以变，但含义不应变。再比如说一个合同，可以有四个变量：</p><ul><li>first_party: 含义是甲方</li><li>second_party: 含义是乙方</li><li>contract_body: 含义是合同内容</li><li>contract_sign_date: 含义是合同签署日期</li></ul><p>这些变量表示的含义是确定的，但对不同的合同，他们的值是不同的。</p><p>初学编程的人经常使用像a,b,c,hehe,haha这种无意义的名字，给变量起一个有意义的名字吧！</p><p>通过声明变量，每个变量赋予一个数据类型和一个有意义的名字，我们就告诉了计算机我们要操作的数据。</p><p>有了数据，怎么对数据进行操作呢？</p><div class=\"wp_rp_wrap  wp_rp_plain\" ><div class=\"wp_rp_content\"><h3 class=\"related_post_title\">相关文章</h3><ul class=\"related_post wp_rp\" style=\"visibility: visible\"><li ><a href=\"http://blog.jobbole.com/103192/\" class=\"wp_rp_title\">如何给变量取个简短且无歧义的名字</a></li><li ><a href=\"http://blog.jobbole.com/98633/\" class=\"wp_rp_title\">StackOverflow 这么大，它的架构是怎么样的？</a></li><li ><a href=\"http://blog.jobbole.com/93932/\" class=\"wp_rp_title\">你知道计算机在一秒内可以做多少事情吗？</a></li><li ><a href=\"http://blog.jobbole.com/50708/\" class=\"wp_rp_title\">程序员最头疼的事：命名</a></li><li ><a href=\"http://blog.jobbole.com/13593/\" class=\"wp_rp_title\">15 个变量和方法命名的最佳实践</a></li><li ><a href=\"http://blog.jobbole.com/50378/\" class=\"wp_rp_title\">变量教学：类比与方法</a></li><li ><a href=\"http://blog.jobbole.com/85891/\" class=\"wp_rp_title\">实战：上亿数据如何秒查</a></li><li ><a href=\"http://blog.jobbole.com/23274/\" class=\"wp_rp_title\">神舟飞天的秘密：揭秘神舟九号的太空计算机</a></li><li ><a href=\"http://blog.jobbole.com/32268/\" class=\"wp_rp_title\">如何编写计算机模拟器</a></li><li ><a href=\"http://blog.jobbole.com/33224/\" class=\"wp_rp_title\">计算机是如何启动的？</a></li></ul></div></div><p><a href=\"http://blog.jobbole.com/100329/\">计算机程序的思维逻辑 (1)：数据和变量</a>，首发于<a href=\"http://blog.jobbole.com\">文章 - 伯乐在线</a>。</p>") (wfw:commentRss nil "http://blog.jobbole.com/100329/feed/") (slash:comments nil "0"))) ("如何在 Linux 下检测内存泄漏" "<div><h1>1．开发背景</h1></div><div><p style=\"text-align: justify\">在 windows 下使用 VC 编程时，我们通常需要 DEBUG 模式下运行程序，而后调试器将在退出程序时，打印出程序运行过程中在堆上分配而没有释放的内存信息，其中包括代码文件名、行号以及内存大小。该功能是 MFC Framework 提供的内置机制，封装在其类结构体系内部。</p><p style=\"text-align: justify\">在 linux 或者 unix 下，我们的 C++ 程序缺乏相应的手段来检测内存信息，而只能使用 top 指令观察进程的动态内存总额。而且程序退出时，我们无法获知任何内存泄漏信息。为了更好的辅助在 linux 下程序开发，我们在我们的类库项目中设计并实现了一个内存检测子系统。下文将简述 C++ 中的 new 和 delete 的基本原理，并讲述了内存检测子系统的实现原理、实现中的技巧，并对内存泄漏检测的高级话题进行了讨论。</p><h1 id=\"N10035\">2．New和delete的原理</h1><p style=\"text-align: justify\">当我们在程序中写下 new 和 delete 时，我们实际上调用的是 C++ 语言内置的 new operator 和 delete operator。所谓语言内置就是说我们不能更改其含义，它的功能总是一致的。以 new operator 为例，它总是先分配足够的内存，而后再调用相应的类型的构造函数初始化该内存。而 delete operator 总是先调用该类型的析构函数，而后释放内存（图1）。我们能够施加影响力的事实上就是 new operator 和 delete operator 执行过程中分配和释放内存的方法。</p><p style=\"text-align: justify\">new operator 为分配内存所调用的函数名字是 operator new，其通常的形式是 void * operator new(size_t size); 其返回值类型是 void*，因为这个函数返回一个未经处理（raw）的指针，未初始化的内存。参数 size 确定分配多少内存，你能增加额外的参数重载函数 operator new，但是第一个参数类型必须是 size_t。</p><p style=\"text-align: justify\">delete operator 为释放内存所调用的函数名字是 operator delete，其通常的形式是 void operator delete(void *memoryToBeDeallocated)；它释放传入的参数所指向的一片内存区。</p><p style=\"text-align: justify\">这里有一个问题，就是当我们调用 new operator 分配内存时，有一个 size 参数表明需要分配多大的内存。但是当调用 delete operator 时，却没有类似的参数，那么 delete operator 如何能够知道需要释放该指针指向的内存块的大小呢？答案是：对于系统自有的数据类型，语言本身就能区分内存块的大小，而对于自定义数据类型（如我们自定义的类），则 operator new 和 operator delete 之间需要互相传递信息。</p><p style=\"text-align: justify\">当我们使用 operator new 为一个自定义类型对象分配内存时，实际上我们得到的内存要比实际对象的内存大一些，这些内存除了要存储对象数据外，还需要记录这片内存的大小，此方法称为 cookie。这一点上的实现依据不同的编译器不同。（例如 MFC 选择在所分配内存的头部存储对象实际数据，而后面的部分存储边界标志和内存大小信息。g++ 则采用在所分配内存的头 4 个自己存储相关信息，而后面的内存存储对象实际数据。）当我们使用 delete operator 进行内存释放操作时，delete operator 就可以根据这些信息正确的释放指针所指向的内存块。</p><p style=\"text-align: justify\">以上论述的是对于单个对象的内存分配/释放，当我们为数组分配/释放内存时，虽然我们仍然使用 new operator 和 delete operator，但是其内部行为却有不同：new operator 调用了operator new 的数组版的兄弟－ operator new[]，而后针对每一个数组成员调用构造函数。而 delete operator 先对每一个数组成员调用析构函数，而后调用 operator delete[] 来释放内存。需要注意的是，当我们创建或释放由自定义数据类型所构成的数组时，编译器为了能够标识出在 operator delete[] 中所需释放的内存块的大小，也使用了编译器相关的 cookie 技术。</p><p style=\"text-align: justify\">综上所述，如果我们想检测内存泄漏，就必须对程序中的内存分配和释放情况进行记录和分析，也就是说我们需要重载 operator new/operator new[];operator delete/operator delete[] 四个全局函数，以截获我们所需检验的内存操作信息。</p><h1 id=\"N10048\">3．内存检测的基本实现原理</h1><p style=\"text-align: justify\">上文提到要想检测内存泄漏，就必须对程序中的内存分配和释放情况进行记录，所能够采取的办法就是重载所有形式的operator new 和 operator delete，截获 new operator 和 delete operator 执行过程中的内存操作信息。下面列出的就是重载形式</p><div><pre class=\"crayon-plain-tag\">void* operator new( size_t nSize, char* pszFileName, int nLineNum )
void* operator new[]( size_t nSize, char* pszFileName, int nLineNum )
void operator delete( void *ptr )
void operator delete[]( void *ptr )</pre></div><p style=\"text-align: justify\">我们为 operator new 定义了一个新的版本，除了必须的 size_t nSize 参数外，还增加了文件名和行号，这里的文件名和行号就是这次 new operator 操作符被调用时所在的文件名和行号，这个信息将在发现内存泄漏时输出，以帮助用户定位泄漏具体位置。对于 operator delete，因为无法为之定义新的版本，我们直接覆盖了全局的 operator delete 的两个版本。</p><p style=\"text-align: justify\">在重载的 operator new 函数版本中，我们将调用全局的 operator new 的相应的版本并将相应的 size_t 参数传入，而后，我们将全局 operator new 返回的指针值以及该次分配所在的文件名和行号信息记录下来，这里所采用的数据结构是一个 STL 的 map，以指针值为 key 值。当 operator delete 被调用时，如果调用方式正确的话（调用方式不正确的情况将在后面详细描述），我们就能以传入的指针值在 map 中找到相应的数据项并将之删除，而后调用 free 将指针所指向的内存块释放。当程序退出的时候，map 中的剩余的数据项就是我们企图检测的内存泄漏信息－－已经在堆上分配但是尚未释放的分配信息。</p><p style=\"text-align: justify\">以上就是内存检测实现的基本原理，现在还有两个基本问题没有解决：</p><p style=\"text-align: justify\">1) 如何取得内存分配代码所在的文件名和行号，并让 new operator 将之传递给我们重载的 operator new。</p><p style=\"text-align: justify\">2) 我们何时创建用于存储内存数据的 map 数据结构，如何管理，何时打印内存泄漏信息。</p><p style=\"text-align: justify\">先解决问题1。首先我们可以利用 C 的预编译宏 __FILE__ 和 __LINE__，这两个宏将在编译时在指定位置展开为该文件的文件名和该行的行号。而后我们需要将缺省的全局 new operator 替换为我们自定义的能够传入文件名和行号的版本，我们在子系统头文件 MemRecord.h 中定义：</p><div><pre class=\"crayon-plain-tag\">#define DEBUG_NEW new(__FILE__, __LINE__ )</pre></div><p style=\"text-align: justify\">而后在所有需要使用内存检测的客户程序的所有的 cpp 文件的开头加入</p><div><pre class=\"crayon-plain-tag\">#include \"MemRecord.h\"
#define new DEBUG_NEW</pre></div><p style=\"text-align: justify\">就可以将客户源文件中的对于全局缺省的 new operator 的调用替换为 new (__FILE__,__LINE__) 调用，而该形式的new operator将调用我们的operator new (size_t nSize, char* pszFileName, int nLineNum)，其中 nSize 是由 new operator 计算并传入的，而 new 调用点的文件名和行号是由我们自定义版本的 new operator 传入的。我们建议在所有用户自己的源代码文件中都加入上述宏，如果有的文件中使用内存检测子系统而有的没有，则子系统将可能因无法监控整个系统而输出一些泄漏警告。</p><p style=\"text-align: justify\">再说第二个问题。我们用于管理客户信息的这个 map 必须在客户程序第一次调用 new operator 或者 delete operator 之前被创建，而且在最后一个 new operator 和 delete operator 调用之后进行泄漏信息的打印，也就是说它需要先于客户程序而出生，而在客户程序退出之后进行分析。能够包容客户程序生命周期的确有一人–全局对象（appMemory）。我们可以设计一个类来封装这个 map 以及这对它的插入删除操作，然后构造这个类的一个全局对象（appMemory），在全局对象（appMemory）的构造函数中创建并初始化这个数据结构，而在其析构函数中对数据结构中剩余数据进行分析和输出。Operator new 中将调用这个全局对象（appMemory）的 insert 接口将指针、文件名、行号、内存块大小等信息以指针值为 key 记录到 map 中，在 operator delete 中调用 erase 接口将对应指针值的 map 中的数据项删除，注意不要忘了对 map 的访问需要进行互斥同步，因为同一时间可能会有多个线程进行堆上的内存操作。</p><p style=\"text-align: justify\">好啦，内存检测的基本功能已经具备了。但是不要忘了，我们为了检测内存泄漏，在全局的 operator new 增加了一层间接性，同时为了保证对数据结构的安全访问增加了互斥，这些都会降低程序运行的效率。因此我们需要让用户能够方便的 enable 和 disable 这个内存检测功能，毕竟内存泄漏的检测应该在程序的调试和测试阶段完成。我们可以使用条件编译的特性，在用户被检测文件中使用如下宏定义：</p><div><pre class=\"crayon-plain-tag\">#include \"MemRecord.h\"
#if defined( MEM_DEBUG )
#define new DEBUG_NEW
#endif</pre></div><p style=\"text-align: justify\">当用户需要使用内存检测时，可以使用如下命令对被检测文件进行编译</p><div><pre class=\"crayon-plain-tag\">g++ -c -DMEM_DEBUG xxxxxx.cpp</pre></div><p style=\"text-align: justify\">就可以 enable 内存检测功能，而用户程序正式发布时，可以去掉 -DMEM_DEBUG 编译开关来 disable 内存检测功能，消除内存检测带来的效率影响。</p><p>图2所示为使用内存检测功能后，内存泄漏代码的执行以及检测结果</p><p style=\"text-align: center\"><img class=\"aligncenter\" src=\"http://www.ibm.com/developerworks/cn/linux/l-mleak/images/image002.jpg\" /><br />
图2</p><h1 id=\"N10088\">4．错误方式删除带来的问题</h1><p style=\"text-align: justify\">以上我们已经构建了一个具备基本内存泄漏检测功能的子系统，下面让我们来看一下关于内存泄漏方面的一些稍微高级一点的话题。</p><p style=\"text-align: justify\">首先，在我们编制 c++ 应用时，有时需要在堆上创建单个对象，有时则需要创建对象的数组。关于 new 和 delete 原理的叙述我们可以知道，对于单个对象和对象数组来说，内存分配和删除的动作是大不相同的，我们应该总是正确的使用彼此搭配的 new 和 delete 形式。但是在某些情况下，我们很容易犯错误，比如如下代码：</p><div><pre class=\"crayon-plain-tag\">class Test {};
……
Test* pAry = new Test[10];//创建了一个拥有 10 个 Test 对象的数组
Test* pObj = new Test;//创建了一个单对象
……
delete []pObj;//本应使用单对象形式 delete pObj 进行内存释放，却错误的使用了数
//组形式
delete pAry;//本应使用数组形式 delete []pAry 进行内存释放，却错误的使用了单对
//象的形式</pre></div><p style=\"text-align: justify\">不匹配的 new 和 delete 会导致什么问题呢？C++ 标准对此的解答是”未定义”，就是说没有人向你保证会发生什么，但是有一点可以肯定：大多不是好事情–在某些编译器形成的代码中，程序可能会崩溃，而另外一些编译器形成的代码中，程序运行可能毫无问题，但是可能导致内存泄漏。</p><p style=\"text-align: justify\">既然知道形式不匹配的 new 和 delete 会带来的问题，我们就需要对这种现象进行毫不留情的揭露，毕竟我们重载了所有形式的内存操作 operator new，operator new[]，operator delete，operator delete[]。</p><p style=\"text-align: justify\">我们首先想到的是，当用户调用特定方式（单对象或者数组方式）的 operator new 来分配内存时，我们可以在指向该内存的指针相关的数据结构中，增加一项用于描述其分配方式。当用户调用不同形式的 operator delete 的时候，我们在 map 中找到与该指针相对应的数据结构，然后比较分配方式和释放方式是否匹配，匹配则在 map 中正常删除该数据结构，不匹配则将该数据结构转移到一个所谓 “ErrorDelete” 的 list 中，在程序最终退出的时候和内存泄漏信息一起打印。</p><p style=\"text-align: justify\">上面这种方法是最顺理成章的，但是在实际应用中效果却不好。原因有两个，第一个原因我们上面已经提到了：当 new 和 delete 形式不匹配时，其结果”未定义”。如果我们运气实在太差–程序在执行不匹配的 delete 时崩溃了，我们的全局对象（appMemory）中存储的数据也将不复存在，不会打印出任何信息。第二个原因与编译器相关，前面提到过，当编译器处理自定义数据类型或者自定义数据类型数组的 new 和 delete 操作符的时候，通常使用编译器相关的 cookie 技术。这种 cookie 技术在编译器中可能的实现方式是：new operator 先计算容纳所有对象所需的内存大小，而后再加上它为记录 cookie 所需要的内存量，再将总容量传给operator new 进行内存分配。当 operator new 返回所需的内存块后，new operator 将在调用相应次数的构造函数初始化有效数据的同时，记录 cookie 信息。而后将指向有效数据的指针返回给用户。也就是说我们重载的 operator new 所申请到并记录下来的指针与 new operator 返回给调用者的指针不一定一致（图3）。当调用者将 new operator 返回的指针传给 delete operator 进行内存释放时，如果其调用形式相匹配，则相应形式的 delete operator 会作出相反的处理，即调用相应次数的析构函数，再通过指向有效数据的指针位置找出包含 cookie 的整块内存地址，并将其传给 operator delete 释放内存。如果调用形式不匹配，delete operator 就不会做上述运算，而直接将指向有效数据的指针（而不是真正指向整块内存的指针）传入 operator delete。因为我们在 operator new 中记录的是我们所分配的整块内存的指针，而现在传入 operator delete 的却不是，所以就无法在全局对象（appMemory）所记录的数据中找到相应的内存分配信息。</p><p style=\"text-align: center\"><img class=\"aligncenter\" src=\"http://www.ibm.com/developerworks/cn/linux/l-mleak/images/image005.jpg\" /><br />
图3</p><p style=\"text-align: justify\">综上所述，当 new 和 delete 的调用形式不匹配时，由于程序有可能崩溃或者内存子系统找不到相应的内存分配信息，在程序最终打印出 “ErrorDelete” 的方式只能检测到某些”幸运”的不匹配现象。但我们总得做点儿什么，不能让这种危害极大的错误从我们眼前溜走，既然不能秋后算帐，我们就实时输出一个 warning 信息来提醒用户。什么时候抛出一个 warning 呢？很简单，当我们发现在 operator delete 或 operator delete[] 被调用的时候，我们无法在全局对象（appMemory）的 map 中找到与传入的指针值相对应的内存分配信息，我们就认为应该提醒用户。</p><p style=\"text-align: justify\">既然决定要输出warning信息，那么现在的问题就是：我们如何描述我们的warning信息才能更便于用户定位到不匹配删除错误呢？答案：在 warning 信息中打印本次 delete 调用的文件名和行号信息。这可有点困难了，因为对于 operator delete 我们不能向对象 operator new 一样做出一个带附加信息的重载版本，我们只能在保持其接口原貌的情况下，重新定义其实现，所以我们的 operator delete 中能够得到的输入只有指针值。在 new/delete 调用形式不匹配的情况下，我们很有可能无法在全局对象（appMemory）的 map 中找到原来的 new 调用的分配信息。怎么办呢？万不得已，只好使用全局变量了。我们在检测子系统的实现文件中定义了两个全局变量（DELETE_FILE,DELETE_LINE）记录 operator delete 被调用时的文件名和行号，同时为了保证并发的 delete 操作对这两个变量访问同步，还使用了一个 mutex（至于为什么是 CCommonMutex 而不是一个 pthread_mutex_t，在”实现上的问题”一节会详细论述，在这里它的作用就是一个 mutex）。</p><div><pre class=\"crayon-plain-tag\">char DELETE_FILE[ FILENAME_LENGTH ] = {0};
int DELETE_LINE = 0;
CCommonMutex globalLock;</pre></div><p style=\"text-align: justify\">而后，在我们的检测子系统的头文件中定义了如下形式的 DEBUG_DELETE</p><div><pre class=\"crayon-plain-tag\">extern char DELETE_FILE[ FILENAME_LENGTH ];
extern int DELETE_LINE;
extern CCommonMutex globalLock;//在后面解释
#define DEBUG_DELETE 	globalLock.Lock();
if (DELETE_LINE != 0) BuildStack(); （//见第六节解释）
strncpy( DELETE_FILE, __FILE__,FILENAME_LENGTH - 1 );
DELETE_FILE[ FILENAME_LENGTH - 1 ]= '';
DELETE_LINE = __LINE__;
delete</pre></div><p style=\"text-align: justify\">在用户被检测文件中原来的宏定义中添加一条：</p><div><pre class=\"crayon-plain-tag\">#include \"MemRecord.h\"
#if defined( MEM_DEBUG )
#define new DEBUG_NEW
#define delete DEBUG_DELETE
#endif</pre></div><p style=\"text-align: justify\">这样，在用户被检测文件调用 delete operator 之前，将先获得互斥锁，然后使用调用点文件名和行号对相应的全局变量（DELETE_FILE,DELETE_LINE）进行赋值，而后调用 delete operator。当 delete operator 最终调用我们定义的 operator delete 的时候，在获得此次调用的文件名和行号信息后，对文件名和行号全局变量（DELETE_FILE,DELETE_LINE）重新初始化并打开互斥锁，让下一个挂在互斥锁上的 delete operator 得以执行。</p><p style=\"text-align: justify\">在对 delete operator 作出如上修改以后，当我们发现无法经由 delete operator 传入的指针找到对应的内存分配信息的时候，就打印包括该次调用的文件名和行号的 warning。</p><p style=\"text-align: justify\">天下没有十全十美的事情，既然我们提供了一种针对错误方式删除的提醒方法，我们就需要考虑以下几种异常情况：</p><p style=\"text-align: justify\">1． 用户使用的第三方库函数中有内存分配和释放操作。或者用户的被检测进程中进行内存分配和释放的实现文件没有使用我们的宏定义。 由于我们替换了全局的 operator delete，这种情况下的用户调用的 delete 也会被我们截获。用户并没有使用我们定义的DEBUG_NEW 宏，所以我们无法在我们的全局对象（appMemory）数据结构中找到对应的内存分配信息，但是由于它也没有使用DEBUG_DELETE，我们为 delete 定义的两个全局 DELETE_FILE 和 DELETE_LINE 都不会有值，因此可以不打印 warning。</p><p style=\"text-align: justify\">2． 用户的一个实现文件调用了 new 进行内存分配工作，但是该文件并没有使用我们定义的 DEBUG_NEW 宏。同时用户的另一个实现文件中的代码负责调用 delete 来删除前者分配的内存，但不巧的是，这个文件使用了 DEBUG_DELETE 宏。这种情况下内存检测子系统会报告 warning，并打印出 delete 调用的文件名和行号。</p><p style=\"text-align: justify\">3． 与第二种情况相反，用户的一个实现文件调用了 new 进行内存分配工作，并使用我们定义的 DEBUG_NEW 宏。同时用户的另一个实现文件中的代码负责调用 delete 来删除前者分配的内存，但该文件没有使用 DEBUG_DELETE 宏。这种情况下，因为我们能够找到这个内存分配的原始信息，所以不会打印 warning。</p><p style=\"text-align: justify\">4． 当出现嵌套 delete（定义可见”实现上的问题”）的情况下，以上第一和第三种情况都有可能打印出不正确的 warning 信息，详细分析可见”实现上的问题”一节。</p><p style=\"text-align: justify\">你可能觉得这样的 warning 太随意了，有误导之嫌。怎么说呢？作为一个检测子系统，对待有可能的错误我们所采取的原则是：宁可误报，不可漏报。请大家”有则改之，无则加勉”。</p><h1 id=\"N100CB\">5．动态内存泄漏信息的检测</h1><p style=\"text-align: justify\">上面我们所讲述的内存泄漏的检测能够在程序整个生命周期结束时，打印出在程序运行过程中已经在堆上分配但是没有释放的内存分配信息，程序员可以由此找到程序中”显式”的内存泄漏点并加以改正。但是如果程序在结束之前能够将自己所分配的所有内存都释放掉，是不是就可以说这个程序不存在内存泄漏呢？答案：否！在编程实践中，我们发现了另外两种危害性更大的”隐式”内存泄漏，其表现就是在程序退出时，没有任何内存泄漏的现象，但是在程序运行过程中，内存占用量却不断增加，直到使整个系统崩溃。</p><p style=\"text-align: justify\">1． 程序的一个线程不断分配内存，并将指向内存的指针保存在一个数据存储中（如 list），但是在程序运行过程中，一直没有任何线程进行内存释放。当程序退出的时候，该数据存储中的指针值所指向的内存块被依次释放。</p><p style=\"text-align: justify\">2． 程序的N个线程进行内存分配，并将指针传递给一个数据存储，由M个线程从数据存储进行数据处理和内存释放。由于 N 远大于M，或者M个线程数据处理的时间过长，导致内存分配的速度远大于内存被释放的速度。但是在程序退出的时候，数据存储中的指针值所指向的内存块被依次释放。</p><p style=\"text-align: justify\">之所以说他危害性更大，是因为很不容易这种问题找出来，程序可能连续运行几个十几个小时没有问题，从而通过了不严密的系统测试。但是如果在实际环境中 7×24 小时运行，系统将不定时的崩溃，而且崩溃的原因从 log 和程序表象上都查不出原因。</p><p style=\"text-align: justify\">为了将这种问题也挑落马下，我们增加了一个动态检测模块 MemSnapShot，用于在程序运行过程中，每隔一定的时间间隔就对程序当前的内存总使用情况和内存分配情况进行统计，以使用户能够对程序的动态内存分配状况进行监视。</p><p style=\"text-align: justify\">当客户使用 MemSnapShot 进程监视一个运行中的进程时，被监视进程的内存子系统将把内存分配和释放的信息实时传送给MemSnapShot。MemSnapShot 则每隔一定的时间间隔就对所接收到的信息进行统计，计算该进程总的内存使用量，同时以调用new进行内存分配的文件名和行号为索引值，计算每个内存分配动作所分配而未释放的内存总量。这样一来，如果在连续多个时间间隔的统计结果中，如果某文件的某行所分配的内存总量不断增长而始终没有到达一个平衡点甚至回落，那它一定是我们上面所说到的两种问题之一。</p><p style=\"text-align: justify\">在实现上，内存检测子系统的全局对象（appMemory）的构造函数中以自己的当前 PID 为基础 key 值创建一个消息队列，并在operator new 和 operator delete 被调用的时候将相应的信息写入消息队列。MemSnapShot 进程启动时需要输入被检测进程的 PID，而后通过该 PID 组装 key 值并找到被检测进程创建的消息队列，并开始读入消息队列中的数据进行分析统计。当得到operator new 的信息时，记录内存分配信息，当收到 operator delete 消息时，删除相应的内存分配信息。同时启动一个分析线程，每隔一定的时间间隔就计算一下当前的以分配而尚未释放的内存信息，并以内存的分配位置为关键字进行统计，查看在同一位置（相同文件名和行号）所分配的内存总量和其占进程总内存量的百分比。</p><p style=\"text-align: justify\">图4 是一个正在运行的 MemSnapShot 程序，它所监视的进程的动态内存分配情况如图所示：</p><p style=\"text-align: center\"><img class=\"aligncenter\" src=\"http://www.ibm.com/developerworks/cn/linux/l-mleak/images/image006.jpg\" /><br />
图四</p><p style=\"text-align: justify\">在支持 MemSnapShot 过程中的实现上的唯一技巧是–对于被检测进程异常退出状况的处理。因为被检测进程中的内存检测子系统创建了用于进程间传输数据的消息队列，它是一个核心资源，其生命周期与内核相同，一旦创建，除非显式的进行删除或系统重启，否则将不被释放。</p><p style=\"text-align: justify\">不错，我们可以在内存检测子系统中的全局对象（appMemory）的析构函数中完成对消息队列的删除，但是如果被检测进程非正常退出（CTRL+C，段错误崩溃等），消息队列可就没人管了。那么我们可以不可以在全局对象（appMemory）的构造函数中使用 signal 系统调用注册 SIGINT，SIGSEGV 等系统信号处理函数，并在处理函数中删除消息队列呢？还是不行，因为被检测进程完全有可能注册自己的对应的信号处理函数，这样就会替换我们的信号处理函数。最终我们采取的方法是利用 fork 产生一个孤儿进程，并利用这个进程监视被检测进程的生存状况，如果被检测进程已经退出（无论正常退出还是异常退出），则试图删除被检测进程所创建的消息队列。下面简述其实现原理：</p><p style=\"text-align: justify\">在全局对象（appMemory）构造函数中，创建消息队列成功以后，我们调用 fork 创建一个子进程，而后该子进程再次调用 fork 创建孙子进程，并退出，从而使孙子进程变为一个”孤儿”进程（之所以使用孤儿进程是因为我们需要切断被检测进程与我们创建的进程之间的信号联系）。孙子进程利用父进程（被检测进程）的全局对象（appMemory）得到其 PID 和刚刚创建的消息队列的标识，并传递给调用 exec 函数产生的一个新的程序映象–MemCleaner。</p><p style=\"text-align: justify\">MemCleaner 程序仅仅调用 kill(pid, 0);函数来查看被检测进程的生存状态，如果被检测进程不存在了（正常或者异常退出），则 kill 函数返回非 0 值，此时我们就动手清除可能存在的消息队列。</p><h1 id=\"N100F2\">6．实现上的问题：嵌套delete</h1><p style=\"text-align: justify\">在”错误方式删除带来的问题”一节中，我们对 delete operator 动了个小手术–增加了两个全局变量（DELETE_FILE,DELETE_LINE）用于记录本次 delete 操作所在的文件名和行号，并且为了同步对全局变量（DELETE_FILE,DELETE_LINE）的访问，增加了一个全局的互斥锁。在一开始，我们使用的是 pthread_mutex_t，但是在测试中，我们发现 pthread_mutex_t 在本应用环境中的局限性。</p><p style=\"text-align: justify\">例如如下代码：</p><div><pre class=\"crayon-plain-tag\">class B {…};
class A {
public:
A() {m_pB = NULL};
A(B* pb) {m_pB = pb;};
~A()
{
if (m_pB != NULL)
delete m_pB;		//这句最要命
};
private:
class B* m_pB;
……
}
int main()
{
A* pA = new A(new B);
……
delete pA;
}</pre></div><p style=\"text-align: justify\">在上述代码中，main 函数中的一句 delete pA 我们称之为”嵌套删除”，即我们 delete A 对象的时候，在A对象的析构执行了另一个 delete B 的动作。当用户使用我们的内存检测子系统时，delete pA 的动作应转化为以下动作：</p><div><pre class=\"crayon-plain-tag\">上全局锁
全局变量（DELETE_FILE,DELETE_LINE）赋值为文件名和行号2
delete operator A
调用~A()
上全局锁
全局变量（DELETE_FILE,DELETE_LINE）赋值为文件名和行号1
delete operator B
调用~B()
返回~B()
调用operator delete B
记录全局变量（DELETE_FILE,DELETE_LINE）值1并清除全局变量（DELETE_FILE,DELETE_LINE）值
打开全局锁
返回operator delete B
返回delete operator B
返回~A()
调用 operator delete A
记录全局变量（DELETE_FILE,DELETE_LINE）值1并清除全局变量（DELETE_FILE,DELETE_LINE）值
打开全局锁
返回operator delete A
返回 delete operator A</pre></div><p style=\"text-align: justify\">在这一过程中，有两个技术问题，一个是 <strong>mutex 的可重入问题</strong>，一个是嵌套删除时 <strong>对全局变量（DELETE_FILE,DELETE_LINE）</strong>现场保护的问题。</p><p style=\"text-align: justify\">所谓 <strong>mutex 的可重入问题</strong>，是指在同一个线程上下文中，连续对同一个 mutex 调用了多次 lock，然后连续调用了多次 unlock。这就是说我们的应用方式要求互斥锁有如下特性：</p><p style=\"text-align: justify\">1． 要求在同一个线程上下文中，能够多次持有同一个互斥体。并且只有在同一线程上下文中调用相同次数的 unlock 才能放弃对互斥体的占有。</p><p style=\"text-align: justify\">2． 对于不同线程上下文持有互斥体的企图，同一时间只有一个线程能够持有互斥体，并且只有在其释放互斥体之后，其他线程才能持有该互斥体。</p><p style=\"text-align: justify\">Pthread_mutex_t 互斥体不具有以上特性，即使在同一上下文中，第二次调用 pthread_mutex_lock 将会挂起。因此，我们必须实现出自己的互斥体。在这里我们使用 semaphore 的特性实现了一个符合上述特性描述的互斥体 CCommonMutex（源代码见附件）。</p><p style=\"text-align: justify\">为了支持特性 2，在这个 CCommonMutex 类中，封装了一个 semaphore，并在构造函数中令其资源值为 1，初始值为1。当调用 CCommonMutex::lock 接口时，调用 sem_wait 得到 semaphore，使信号量的资源为 0 从而让其他调用 lock 接口的线程挂起。当调用接口 CCommonMutex::unlock 时，调用 sem_post 使信号量资源恢复为 1，让其他挂起的线程中的一个持有信号量。</p><p style=\"text-align: justify\">同时为了支持特性 1，在这个 CCommonMutex 增加了对于当前线程 pid 的判断和当前线程访问计数。当线程第一次调用 lock 接口时，我们调用 sem_wait 的同时，记录当前的 Pid 到成员变量 m_pid，并置访问计数为 1，同一线程（m_pid == getpid()）其后的多次调用将只进行计数而不挂起。当调用 unlock 接口时，如果计数不为 1，则只需递减访问计数，直到递减访问计数为 1 才进行清除 pid、调用 sem_post。（具体代码可见附件）</p><p style=\"text-align: justify\"><strong>嵌套删除时对全局变量（DELETE_FILE,DELETE_LINE）</strong>现场保护的问题是指，上述步骤中在 A 的析构函数中调用 delete m_pB 时，对全局变量（DELETE_FILE,DELETE_LINE）文件名和行号的赋值将覆盖主程序中调用 delete pA 时对全局变量（DELETE_FILE,DELETE_LINE）的赋值，造成了在执行 operator delete A 时，delete pA 的信息全部丢失。</p><p style=\"text-align: justify\">要想对这些全局信息进行现场保护，最好用的就是堆栈了，在这里我们使用了 STL 提供的 stack 容器。在 DEBUG_DELETE 宏定义中，对全局变量（DELETE_FILE,DELETE_LINE）赋值之前，我们先判断是否前面已经有人对他们赋过值了–观察行号变量是否等于 0，如果不为 0，则应该将已有的信息压栈（调用一个全局函数 BuildStack() 将当前的全局文件名和行号数据压入一个全局堆栈globalStack），而后再对全局变量（DELETE_FILE,DELETE_LINE）赋值，再调用 delete operator。而在内存子系统的全局对象（appMemory）提供的 erase 接口里面，如果判断传入的文件名和行号为 0，则说明我们所需要的数据有可能被嵌套删除覆盖了，所以需要从堆栈中弹出相应的数据进行处理。</p><p style=\"text-align: justify\">现在嵌套删除中的问题基本解决了，但是当嵌套删除与 “错误方式删除带来的问题”一节的最后所描述的第一和第三种异常情况同时出现的时候，由于用户的 delete 调用没有通过我们定义的 DEBUG_DELETE 宏，上述机制可能出现问题。其根本原因是我们利用stack 保留了经由我们的 DEBUG_DELETE 宏记录的 delete 信息的现场，以便在 operator delete 和全局对象（appMemory）的 erase 接口中使用，但是用户的没经过 DEBUG_DELETE 宏的 delete 操作却未曾进行压栈操作而直接调用了 operator delete，有可能将不属于这次操作的 delete 信息弹出，破坏了堆栈信息的顺序和有效性。那么，当我们因为无法找到这次及其后续的 delete 操作所对应的内存分配信息的时候，可能会打印出错误的 warning 信息。</p><h1 id=\"N10124\">展望</h1><p style=\"text-align: justify\">以上就是我们所实现的内存泄漏检测子系统的原理和技术方案，第一版的源代码在附件中，已经经过了较严格的系统测试。但是限于我们的 C++ 知识水平和编程功底，在实现过程中肯定还有没有注意到的地方甚至是缺陷，希望能够得到大家的指正，我的 email 是 <a href=\"mailto:hcode@21cn.com\">hcode@21cn.com</a>。</p><p style=\"text-align: justify\">在我们所实现的内存检测子系统基础上，可以继续搭建内存分配优化子系统，从而形成一个完整的内存子系统。一种内存分配优化子系统的实现方案是一次性分配大块的内存，并使用特定的数据结构管理之，当内存分配请求到来时，使用特定算法从这块大内存中划定所需的一块给用户使用，而用户使用完毕，在将其划为空闲内存。这种内存优化方式将内存分配释放转换为简单的数据处理，极大的减少了内存申请和释放所耗费的时间。</p><p></p></div><div class=\"wp_rp_wrap  wp_rp_plain\" ><div class=\"wp_rp_content\"><h3 class=\"related_post_title\">相关文章</h3><ul class=\"related_post wp_rp\" style=\"visibility: visible\"><li ><a href=\"http://blog.jobbole.com/94497/\" class=\"wp_rp_title\">Linux 动态库相关知识整理</a></li><li ><a href=\"http://blog.jobbole.com/95375/\" class=\"wp_rp_title\">C/C++内存泄漏及检测</a></li><li ><a href=\"http://blog.jobbole.com/103640/\" class=\"wp_rp_title\">Linux 平台相关代码的 C++ 解决方案</a></li><li ><a href=\"http://blog.jobbole.com/104080/\" class=\"wp_rp_title\">编写高质量代码</a></li><li ><a href=\"http://blog.jobbole.com/103596/\" class=\"wp_rp_title\">Linux 下 C++ 异常处理技巧</a></li><li ><a href=\"http://blog.jobbole.com/80617/\" class=\"wp_rp_title\">C 语言中的指针和内存泄漏</a></li><li ><a href=\"http://blog.jobbole.com/88279/\" class=\"wp_rp_title\">Linux 内核里的“智能指针”</a></li><li ><a href=\"http://blog.jobbole.com/104032/\" class=\"wp_rp_title\">面向 C++ 的测试驱动开发</a></li><li ><a href=\"http://blog.jobbole.com/103669/\" class=\"wp_rp_title\">C++11 中的 Defaulted 和 Deleted 函数</a></li><li ><a href=\"http://blog.jobbole.com/86958/\" class=\"wp_rp_title\">如何用C++在不按回车的情况下获取标准输入中的字符</a></li></ul></div></div><p><a href=\"http://blog.jobbole.com/104042/\">如何在 Linux 下检测内存泄漏</a>，首发于<a href=\"http://blog.jobbole.com\">文章 - 伯乐在线</a>。</p>" "http://blog.jobbole.com/104042/" (22430 48972) old 15 nil nil ((title nil "如何在 Linux 下检测内存泄漏") (link nil "http://blog.jobbole.com/104042/") (comments nil "http://blog.jobbole.com/104042/#respond") (pubDate nil "Mon, 01 Aug 2016 03:17:32 +0000") (dc:creator nil "中二饼") (category nil "C/C++") (category nil "开发") (category nil "C++") (category nil "Linux") (category nil "内存泄漏") (guid ((isPermaLink . "false")) "http://blog.jobbole.com/?p=104042") (description nil "<p>本文针对 linux 下的 C++ 程序的内存泄漏的检测方法及其实现进行探讨。其中包括 C++ 中的 new 和 delete 的基本原理，内存检测子系统的实现原理和具体方法，以及内存泄漏检测的高级话题。作为内存检测子系统实现的一部分，提供了一个具有更好的使用特性的互斥体（Mutex）类。</p><p><a href=\"http://blog.jobbole.com/104042/\">如何在 Linux 下检测内存泄漏</a>，首发于<a href=\"http://blog.jobbole.com\">文章 - 伯乐在线</a>。</p>") (content:encoded nil "<div><h1>1．开发背景</h1></div><div><p style=\"text-align: justify\">在 windows 下使用 VC 编程时，我们通常需要 DEBUG 模式下运行程序，而后调试器将在退出程序时，打印出程序运行过程中在堆上分配而没有释放的内存信息，其中包括代码文件名、行号以及内存大小。该功能是 MFC Framework 提供的内置机制，封装在其类结构体系内部。</p><p style=\"text-align: justify\">在 linux 或者 unix 下，我们的 C++ 程序缺乏相应的手段来检测内存信息，而只能使用 top 指令观察进程的动态内存总额。而且程序退出时，我们无法获知任何内存泄漏信息。为了更好的辅助在 linux 下程序开发，我们在我们的类库项目中设计并实现了一个内存检测子系统。下文将简述 C++ 中的 new 和 delete 的基本原理，并讲述了内存检测子系统的实现原理、实现中的技巧，并对内存泄漏检测的高级话题进行了讨论。</p><h1 id=\"N10035\">2．New和delete的原理</h1><p style=\"text-align: justify\">当我们在程序中写下 new 和 delete 时，我们实际上调用的是 C++ 语言内置的 new operator 和 delete operator。所谓语言内置就是说我们不能更改其含义，它的功能总是一致的。以 new operator 为例，它总是先分配足够的内存，而后再调用相应的类型的构造函数初始化该内存。而 delete operator 总是先调用该类型的析构函数，而后释放内存（图1）。我们能够施加影响力的事实上就是 new operator 和 delete operator 执行过程中分配和释放内存的方法。</p><p style=\"text-align: justify\">new operator 为分配内存所调用的函数名字是 operator new，其通常的形式是 void * operator new(size_t size); 其返回值类型是 void*，因为这个函数返回一个未经处理（raw）的指针，未初始化的内存。参数 size 确定分配多少内存，你能增加额外的参数重载函数 operator new，但是第一个参数类型必须是 size_t。</p><p style=\"text-align: justify\">delete operator 为释放内存所调用的函数名字是 operator delete，其通常的形式是 void operator delete(void *memoryToBeDeallocated)；它释放传入的参数所指向的一片内存区。</p><p style=\"text-align: justify\">这里有一个问题，就是当我们调用 new operator 分配内存时，有一个 size 参数表明需要分配多大的内存。但是当调用 delete operator 时，却没有类似的参数，那么 delete operator 如何能够知道需要释放该指针指向的内存块的大小呢？答案是：对于系统自有的数据类型，语言本身就能区分内存块的大小，而对于自定义数据类型（如我们自定义的类），则 operator new 和 operator delete 之间需要互相传递信息。</p><p style=\"text-align: justify\">当我们使用 operator new 为一个自定义类型对象分配内存时，实际上我们得到的内存要比实际对象的内存大一些，这些内存除了要存储对象数据外，还需要记录这片内存的大小，此方法称为 cookie。这一点上的实现依据不同的编译器不同。（例如 MFC 选择在所分配内存的头部存储对象实际数据，而后面的部分存储边界标志和内存大小信息。g++ 则采用在所分配内存的头 4 个自己存储相关信息，而后面的内存存储对象实际数据。）当我们使用 delete operator 进行内存释放操作时，delete operator 就可以根据这些信息正确的释放指针所指向的内存块。</p><p style=\"text-align: justify\">以上论述的是对于单个对象的内存分配/释放，当我们为数组分配/释放内存时，虽然我们仍然使用 new operator 和 delete operator，但是其内部行为却有不同：new operator 调用了operator new 的数组版的兄弟－ operator new[]，而后针对每一个数组成员调用构造函数。而 delete operator 先对每一个数组成员调用析构函数，而后调用 operator delete[] 来释放内存。需要注意的是，当我们创建或释放由自定义数据类型所构成的数组时，编译器为了能够标识出在 operator delete[] 中所需释放的内存块的大小，也使用了编译器相关的 cookie 技术。</p><p style=\"text-align: justify\">综上所述，如果我们想检测内存泄漏，就必须对程序中的内存分配和释放情况进行记录和分析，也就是说我们需要重载 operator new/operator new[];operator delete/operator delete[] 四个全局函数，以截获我们所需检验的内存操作信息。</p><h1 id=\"N10048\">3．内存检测的基本实现原理</h1><p style=\"text-align: justify\">上文提到要想检测内存泄漏，就必须对程序中的内存分配和释放情况进行记录，所能够采取的办法就是重载所有形式的operator new 和 operator delete，截获 new operator 和 delete operator 执行过程中的内存操作信息。下面列出的就是重载形式</p><div><pre class=\"crayon-plain-tag\">void* operator new( size_t nSize, char* pszFileName, int nLineNum )
void* operator new[]( size_t nSize, char* pszFileName, int nLineNum )
void operator delete( void *ptr )
void operator delete[]( void *ptr )</pre></div><p style=\"text-align: justify\">我们为 operator new 定义了一个新的版本，除了必须的 size_t nSize 参数外，还增加了文件名和行号，这里的文件名和行号就是这次 new operator 操作符被调用时所在的文件名和行号，这个信息将在发现内存泄漏时输出，以帮助用户定位泄漏具体位置。对于 operator delete，因为无法为之定义新的版本，我们直接覆盖了全局的 operator delete 的两个版本。</p><p style=\"text-align: justify\">在重载的 operator new 函数版本中，我们将调用全局的 operator new 的相应的版本并将相应的 size_t 参数传入，而后，我们将全局 operator new 返回的指针值以及该次分配所在的文件名和行号信息记录下来，这里所采用的数据结构是一个 STL 的 map，以指针值为 key 值。当 operator delete 被调用时，如果调用方式正确的话（调用方式不正确的情况将在后面详细描述），我们就能以传入的指针值在 map 中找到相应的数据项并将之删除，而后调用 free 将指针所指向的内存块释放。当程序退出的时候，map 中的剩余的数据项就是我们企图检测的内存泄漏信息－－已经在堆上分配但是尚未释放的分配信息。</p><p style=\"text-align: justify\">以上就是内存检测实现的基本原理，现在还有两个基本问题没有解决：</p><p style=\"text-align: justify\">1) 如何取得内存分配代码所在的文件名和行号，并让 new operator 将之传递给我们重载的 operator new。</p><p style=\"text-align: justify\">2) 我们何时创建用于存储内存数据的 map 数据结构，如何管理，何时打印内存泄漏信息。</p><p style=\"text-align: justify\">先解决问题1。首先我们可以利用 C 的预编译宏 __FILE__ 和 __LINE__，这两个宏将在编译时在指定位置展开为该文件的文件名和该行的行号。而后我们需要将缺省的全局 new operator 替换为我们自定义的能够传入文件名和行号的版本，我们在子系统头文件 MemRecord.h 中定义：</p><div><pre class=\"crayon-plain-tag\">#define DEBUG_NEW new(__FILE__, __LINE__ )</pre></div><p style=\"text-align: justify\">而后在所有需要使用内存检测的客户程序的所有的 cpp 文件的开头加入</p><div><pre class=\"crayon-plain-tag\">#include \"MemRecord.h\"
#define new DEBUG_NEW</pre></div><p style=\"text-align: justify\">就可以将客户源文件中的对于全局缺省的 new operator 的调用替换为 new (__FILE__,__LINE__) 调用，而该形式的new operator将调用我们的operator new (size_t nSize, char* pszFileName, int nLineNum)，其中 nSize 是由 new operator 计算并传入的，而 new 调用点的文件名和行号是由我们自定义版本的 new operator 传入的。我们建议在所有用户自己的源代码文件中都加入上述宏，如果有的文件中使用内存检测子系统而有的没有，则子系统将可能因无法监控整个系统而输出一些泄漏警告。</p><p style=\"text-align: justify\">再说第二个问题。我们用于管理客户信息的这个 map 必须在客户程序第一次调用 new operator 或者 delete operator 之前被创建，而且在最后一个 new operator 和 delete operator 调用之后进行泄漏信息的打印，也就是说它需要先于客户程序而出生，而在客户程序退出之后进行分析。能够包容客户程序生命周期的确有一人&#8211;全局对象（appMemory）。我们可以设计一个类来封装这个 map 以及这对它的插入删除操作，然后构造这个类的一个全局对象（appMemory），在全局对象（appMemory）的构造函数中创建并初始化这个数据结构，而在其析构函数中对数据结构中剩余数据进行分析和输出。Operator new 中将调用这个全局对象（appMemory）的 insert 接口将指针、文件名、行号、内存块大小等信息以指针值为 key 记录到 map 中，在 operator delete 中调用 erase 接口将对应指针值的 map 中的数据项删除，注意不要忘了对 map 的访问需要进行互斥同步，因为同一时间可能会有多个线程进行堆上的内存操作。</p><p style=\"text-align: justify\">好啦，内存检测的基本功能已经具备了。但是不要忘了，我们为了检测内存泄漏，在全局的 operator new 增加了一层间接性，同时为了保证对数据结构的安全访问增加了互斥，这些都会降低程序运行的效率。因此我们需要让用户能够方便的 enable 和 disable 这个内存检测功能，毕竟内存泄漏的检测应该在程序的调试和测试阶段完成。我们可以使用条件编译的特性，在用户被检测文件中使用如下宏定义：</p><div><pre class=\"crayon-plain-tag\">#include \"MemRecord.h\"
#if defined( MEM_DEBUG )
#define new DEBUG_NEW
#endif</pre></div><p style=\"text-align: justify\">当用户需要使用内存检测时，可以使用如下命令对被检测文件进行编译</p><div><pre class=\"crayon-plain-tag\">g++ -c -DMEM_DEBUG xxxxxx.cpp</pre></div><p style=\"text-align: justify\">就可以 enable 内存检测功能，而用户程序正式发布时，可以去掉 -DMEM_DEBUG 编译开关来 disable 内存检测功能，消除内存检测带来的效率影响。</p><p>图2所示为使用内存检测功能后，内存泄漏代码的执行以及检测结果</p><p style=\"text-align: center\"><img class=\"aligncenter\" src=\"http://www.ibm.com/developerworks/cn/linux/l-mleak/images/image002.jpg\" /><br />
图2</p><h1 id=\"N10088\">4．错误方式删除带来的问题</h1><p style=\"text-align: justify\">以上我们已经构建了一个具备基本内存泄漏检测功能的子系统，下面让我们来看一下关于内存泄漏方面的一些稍微高级一点的话题。</p><p style=\"text-align: justify\">首先，在我们编制 c++ 应用时，有时需要在堆上创建单个对象，有时则需要创建对象的数组。关于 new 和 delete 原理的叙述我们可以知道，对于单个对象和对象数组来说，内存分配和删除的动作是大不相同的，我们应该总是正确的使用彼此搭配的 new 和 delete 形式。但是在某些情况下，我们很容易犯错误，比如如下代码：</p><div><pre class=\"crayon-plain-tag\">class Test {};
		……
		Test* pAry = new Test[10];//创建了一个拥有 10 个 Test 对象的数组
		Test* pObj = new Test;//创建了一个单对象
		……
		delete []pObj;//本应使用单对象形式 delete pObj 进行内存释放，却错误的使用了数
//组形式
		delete pAry;//本应使用数组形式 delete []pAry 进行内存释放，却错误的使用了单对
//象的形式</pre></div><p style=\"text-align: justify\">不匹配的 new 和 delete 会导致什么问题呢？C++ 标准对此的解答是&#8221;未定义&#8221;，就是说没有人向你保证会发生什么，但是有一点可以肯定：大多不是好事情&#8211;在某些编译器形成的代码中，程序可能会崩溃，而另外一些编译器形成的代码中，程序运行可能毫无问题，但是可能导致内存泄漏。</p><p style=\"text-align: justify\">既然知道形式不匹配的 new 和 delete 会带来的问题，我们就需要对这种现象进行毫不留情的揭露，毕竟我们重载了所有形式的内存操作 operator new，operator new[]，operator delete，operator delete[]。</p><p style=\"text-align: justify\">我们首先想到的是，当用户调用特定方式（单对象或者数组方式）的 operator new 来分配内存时，我们可以在指向该内存的指针相关的数据结构中，增加一项用于描述其分配方式。当用户调用不同形式的 operator delete 的时候，我们在 map 中找到与该指针相对应的数据结构，然后比较分配方式和释放方式是否匹配，匹配则在 map 中正常删除该数据结构，不匹配则将该数据结构转移到一个所谓 &#8220;ErrorDelete&#8221; 的 list 中，在程序最终退出的时候和内存泄漏信息一起打印。</p><p style=\"text-align: justify\">上面这种方法是最顺理成章的，但是在实际应用中效果却不好。原因有两个，第一个原因我们上面已经提到了：当 new 和 delete 形式不匹配时，其结果&#8221;未定义&#8221;。如果我们运气实在太差&#8211;程序在执行不匹配的 delete 时崩溃了，我们的全局对象（appMemory）中存储的数据也将不复存在，不会打印出任何信息。第二个原因与编译器相关，前面提到过，当编译器处理自定义数据类型或者自定义数据类型数组的 new 和 delete 操作符的时候，通常使用编译器相关的 cookie 技术。这种 cookie 技术在编译器中可能的实现方式是：new operator 先计算容纳所有对象所需的内存大小，而后再加上它为记录 cookie 所需要的内存量，再将总容量传给operator new 进行内存分配。当 operator new 返回所需的内存块后，new operator 将在调用相应次数的构造函数初始化有效数据的同时，记录 cookie 信息。而后将指向有效数据的指针返回给用户。也就是说我们重载的 operator new 所申请到并记录下来的指针与 new operator 返回给调用者的指针不一定一致（图3）。当调用者将 new operator 返回的指针传给 delete operator 进行内存释放时，如果其调用形式相匹配，则相应形式的 delete operator 会作出相反的处理，即调用相应次数的析构函数，再通过指向有效数据的指针位置找出包含 cookie 的整块内存地址，并将其传给 operator delete 释放内存。如果调用形式不匹配，delete operator 就不会做上述运算，而直接将指向有效数据的指针（而不是真正指向整块内存的指针）传入 operator delete。因为我们在 operator new 中记录的是我们所分配的整块内存的指针，而现在传入 operator delete 的却不是，所以就无法在全局对象（appMemory）所记录的数据中找到相应的内存分配信息。</p><p style=\"text-align: center\"><img class=\"aligncenter\" src=\"http://www.ibm.com/developerworks/cn/linux/l-mleak/images/image005.jpg\" /><br />
图3</p><p style=\"text-align: justify\">综上所述，当 new 和 delete 的调用形式不匹配时，由于程序有可能崩溃或者内存子系统找不到相应的内存分配信息，在程序最终打印出 &#8220;ErrorDelete&#8221; 的方式只能检测到某些&#8221;幸运&#8221;的不匹配现象。但我们总得做点儿什么，不能让这种危害极大的错误从我们眼前溜走，既然不能秋后算帐，我们就实时输出一个 warning 信息来提醒用户。什么时候抛出一个 warning 呢？很简单，当我们发现在 operator delete 或 operator delete[] 被调用的时候，我们无法在全局对象（appMemory）的 map 中找到与传入的指针值相对应的内存分配信息，我们就认为应该提醒用户。</p><p style=\"text-align: justify\">既然决定要输出warning信息，那么现在的问题就是：我们如何描述我们的warning信息才能更便于用户定位到不匹配删除错误呢？答案：在 warning 信息中打印本次 delete 调用的文件名和行号信息。这可有点困难了，因为对于 operator delete 我们不能向对象 operator new 一样做出一个带附加信息的重载版本，我们只能在保持其接口原貌的情况下，重新定义其实现，所以我们的 operator delete 中能够得到的输入只有指针值。在 new/delete 调用形式不匹配的情况下，我们很有可能无法在全局对象（appMemory）的 map 中找到原来的 new 调用的分配信息。怎么办呢？万不得已，只好使用全局变量了。我们在检测子系统的实现文件中定义了两个全局变量（DELETE_FILE,DELETE_LINE）记录 operator delete 被调用时的文件名和行号，同时为了保证并发的 delete 操作对这两个变量访问同步，还使用了一个 mutex（至于为什么是 CCommonMutex 而不是一个 pthread_mutex_t，在&#8221;实现上的问题&#8221;一节会详细论述，在这里它的作用就是一个 mutex）。</p><div><pre class=\"crayon-plain-tag\">char DELETE_FILE[ FILENAME_LENGTH ] = {0};
int DELETE_LINE = 0;
CCommonMutex globalLock;</pre></div><p style=\"text-align: justify\">而后，在我们的检测子系统的头文件中定义了如下形式的 DEBUG_DELETE</p><div><pre class=\"crayon-plain-tag\">extern char DELETE_FILE[ FILENAME_LENGTH ];
extern int DELETE_LINE;
extern CCommonMutex globalLock;//在后面解释
#define DEBUG_DELETE 	globalLock.Lock(); 
			if (DELETE_LINE != 0) BuildStack(); （//见第六节解释）
			strncpy( DELETE_FILE, __FILE__,FILENAME_LENGTH - 1 );
			DELETE_FILE[ FILENAME_LENGTH - 1 ]= ''; 
			DELETE_LINE = __LINE__; 
			delete</pre></div><p style=\"text-align: justify\">在用户被检测文件中原来的宏定义中添加一条：</p><div><pre class=\"crayon-plain-tag\">#include \"MemRecord.h\"
#if defined( MEM_DEBUG )
#define new DEBUG_NEW
#define delete DEBUG_DELETE
#endif</pre></div><p style=\"text-align: justify\">这样，在用户被检测文件调用 delete operator 之前，将先获得互斥锁，然后使用调用点文件名和行号对相应的全局变量（DELETE_FILE,DELETE_LINE）进行赋值，而后调用 delete operator。当 delete operator 最终调用我们定义的 operator delete 的时候，在获得此次调用的文件名和行号信息后，对文件名和行号全局变量（DELETE_FILE,DELETE_LINE）重新初始化并打开互斥锁，让下一个挂在互斥锁上的 delete operator 得以执行。</p><p style=\"text-align: justify\">在对 delete operator 作出如上修改以后，当我们发现无法经由 delete operator 传入的指针找到对应的内存分配信息的时候，就打印包括该次调用的文件名和行号的 warning。</p><p style=\"text-align: justify\">天下没有十全十美的事情，既然我们提供了一种针对错误方式删除的提醒方法，我们就需要考虑以下几种异常情况：</p><p style=\"text-align: justify\">1． 用户使用的第三方库函数中有内存分配和释放操作。或者用户的被检测进程中进行内存分配和释放的实现文件没有使用我们的宏定义。 由于我们替换了全局的 operator delete，这种情况下的用户调用的 delete 也会被我们截获。用户并没有使用我们定义的DEBUG_NEW 宏，所以我们无法在我们的全局对象（appMemory）数据结构中找到对应的内存分配信息，但是由于它也没有使用DEBUG_DELETE，我们为 delete 定义的两个全局 DELETE_FILE 和 DELETE_LINE 都不会有值，因此可以不打印 warning。</p><p style=\"text-align: justify\">2． 用户的一个实现文件调用了 new 进行内存分配工作，但是该文件并没有使用我们定义的 DEBUG_NEW 宏。同时用户的另一个实现文件中的代码负责调用 delete 来删除前者分配的内存，但不巧的是，这个文件使用了 DEBUG_DELETE 宏。这种情况下内存检测子系统会报告 warning，并打印出 delete 调用的文件名和行号。</p><p style=\"text-align: justify\">3． 与第二种情况相反，用户的一个实现文件调用了 new 进行内存分配工作，并使用我们定义的 DEBUG_NEW 宏。同时用户的另一个实现文件中的代码负责调用 delete 来删除前者分配的内存，但该文件没有使用 DEBUG_DELETE 宏。这种情况下，因为我们能够找到这个内存分配的原始信息，所以不会打印 warning。</p><p style=\"text-align: justify\">4． 当出现嵌套 delete（定义可见&#8221;实现上的问题&#8221;）的情况下，以上第一和第三种情况都有可能打印出不正确的 warning 信息，详细分析可见&#8221;实现上的问题&#8221;一节。</p><p style=\"text-align: justify\">你可能觉得这样的 warning 太随意了，有误导之嫌。怎么说呢？作为一个检测子系统，对待有可能的错误我们所采取的原则是：宁可误报，不可漏报。请大家&#8221;有则改之，无则加勉&#8221;。</p><h1 id=\"N100CB\">5．动态内存泄漏信息的检测</h1><p style=\"text-align: justify\">上面我们所讲述的内存泄漏的检测能够在程序整个生命周期结束时，打印出在程序运行过程中已经在堆上分配但是没有释放的内存分配信息，程序员可以由此找到程序中&#8221;显式&#8221;的内存泄漏点并加以改正。但是如果程序在结束之前能够将自己所分配的所有内存都释放掉，是不是就可以说这个程序不存在内存泄漏呢？答案：否！在编程实践中，我们发现了另外两种危害性更大的&#8221;隐式&#8221;内存泄漏，其表现就是在程序退出时，没有任何内存泄漏的现象，但是在程序运行过程中，内存占用量却不断增加，直到使整个系统崩溃。</p><p style=\"text-align: justify\">1． 程序的一个线程不断分配内存，并将指向内存的指针保存在一个数据存储中（如 list），但是在程序运行过程中，一直没有任何线程进行内存释放。当程序退出的时候，该数据存储中的指针值所指向的内存块被依次释放。</p><p style=\"text-align: justify\">2． 程序的N个线程进行内存分配，并将指针传递给一个数据存储，由M个线程从数据存储进行数据处理和内存释放。由于 N 远大于M，或者M个线程数据处理的时间过长，导致内存分配的速度远大于内存被释放的速度。但是在程序退出的时候，数据存储中的指针值所指向的内存块被依次释放。</p><p style=\"text-align: justify\">之所以说他危害性更大，是因为很不容易这种问题找出来，程序可能连续运行几个十几个小时没有问题，从而通过了不严密的系统测试。但是如果在实际环境中 7×24 小时运行，系统将不定时的崩溃，而且崩溃的原因从 log 和程序表象上都查不出原因。</p><p style=\"text-align: justify\">为了将这种问题也挑落马下，我们增加了一个动态检测模块 MemSnapShot，用于在程序运行过程中，每隔一定的时间间隔就对程序当前的内存总使用情况和内存分配情况进行统计，以使用户能够对程序的动态内存分配状况进行监视。</p><p style=\"text-align: justify\">当客户使用 MemSnapShot 进程监视一个运行中的进程时，被监视进程的内存子系统将把内存分配和释放的信息实时传送给MemSnapShot。MemSnapShot 则每隔一定的时间间隔就对所接收到的信息进行统计，计算该进程总的内存使用量，同时以调用new进行内存分配的文件名和行号为索引值，计算每个内存分配动作所分配而未释放的内存总量。这样一来，如果在连续多个时间间隔的统计结果中，如果某文件的某行所分配的内存总量不断增长而始终没有到达一个平衡点甚至回落，那它一定是我们上面所说到的两种问题之一。</p><p style=\"text-align: justify\">在实现上，内存检测子系统的全局对象（appMemory）的构造函数中以自己的当前 PID 为基础 key 值创建一个消息队列，并在operator new 和 operator delete 被调用的时候将相应的信息写入消息队列。MemSnapShot 进程启动时需要输入被检测进程的 PID，而后通过该 PID 组装 key 值并找到被检测进程创建的消息队列，并开始读入消息队列中的数据进行分析统计。当得到operator new 的信息时，记录内存分配信息，当收到 operator delete 消息时，删除相应的内存分配信息。同时启动一个分析线程，每隔一定的时间间隔就计算一下当前的以分配而尚未释放的内存信息，并以内存的分配位置为关键字进行统计，查看在同一位置（相同文件名和行号）所分配的内存总量和其占进程总内存量的百分比。</p><p style=\"text-align: justify\">图4 是一个正在运行的 MemSnapShot 程序，它所监视的进程的动态内存分配情况如图所示：</p><p style=\"text-align: center\"><img class=\"aligncenter\" src=\"http://www.ibm.com/developerworks/cn/linux/l-mleak/images/image006.jpg\" /><br />
图四</p><p style=\"text-align: justify\">在支持 MemSnapShot 过程中的实现上的唯一技巧是&#8211;对于被检测进程异常退出状况的处理。因为被检测进程中的内存检测子系统创建了用于进程间传输数据的消息队列，它是一个核心资源，其生命周期与内核相同，一旦创建，除非显式的进行删除或系统重启，否则将不被释放。</p><p style=\"text-align: justify\">不错，我们可以在内存检测子系统中的全局对象（appMemory）的析构函数中完成对消息队列的删除，但是如果被检测进程非正常退出（CTRL+C，段错误崩溃等），消息队列可就没人管了。那么我们可以不可以在全局对象（appMemory）的构造函数中使用 signal 系统调用注册 SIGINT，SIGSEGV 等系统信号处理函数，并在处理函数中删除消息队列呢？还是不行，因为被检测进程完全有可能注册自己的对应的信号处理函数，这样就会替换我们的信号处理函数。最终我们采取的方法是利用 fork 产生一个孤儿进程，并利用这个进程监视被检测进程的生存状况，如果被检测进程已经退出（无论正常退出还是异常退出），则试图删除被检测进程所创建的消息队列。下面简述其实现原理：</p><p style=\"text-align: justify\">在全局对象（appMemory）构造函数中，创建消息队列成功以后，我们调用 fork 创建一个子进程，而后该子进程再次调用 fork 创建孙子进程，并退出，从而使孙子进程变为一个&#8221;孤儿&#8221;进程（之所以使用孤儿进程是因为我们需要切断被检测进程与我们创建的进程之间的信号联系）。孙子进程利用父进程（被检测进程）的全局对象（appMemory）得到其 PID 和刚刚创建的消息队列的标识，并传递给调用 exec 函数产生的一个新的程序映象&#8211;MemCleaner。</p><p style=\"text-align: justify\">MemCleaner 程序仅仅调用 kill(pid, 0);函数来查看被检测进程的生存状态，如果被检测进程不存在了（正常或者异常退出），则 kill 函数返回非 0 值，此时我们就动手清除可能存在的消息队列。</p><h1 id=\"N100F2\">6．实现上的问题：嵌套delete</h1><p style=\"text-align: justify\">在&#8221;错误方式删除带来的问题&#8221;一节中，我们对 delete operator 动了个小手术&#8211;增加了两个全局变量（DELETE_FILE,DELETE_LINE）用于记录本次 delete 操作所在的文件名和行号，并且为了同步对全局变量（DELETE_FILE,DELETE_LINE）的访问，增加了一个全局的互斥锁。在一开始，我们使用的是 pthread_mutex_t，但是在测试中，我们发现 pthread_mutex_t 在本应用环境中的局限性。</p><p style=\"text-align: justify\">例如如下代码：</p><div><pre class=\"crayon-plain-tag\">class B {…};
			class A {
			public:
				A() {m_pB = NULL};
				A(B* pb) {m_pB = pb;};
				~A() 
                                {
                                       if (m_pB != NULL)
       					delete m_pB;		//这句最要命
                                 };
			private:
				class B* m_pB;
				……
			}
		int main()
		{
			A* pA = new A(new B);
			……
   	                   delete pA;		
                }</pre></div><p style=\"text-align: justify\">在上述代码中，main 函数中的一句 delete pA 我们称之为&#8221;嵌套删除&#8221;，即我们 delete A 对象的时候，在A对象的析构执行了另一个 delete B 的动作。当用户使用我们的内存检测子系统时，delete pA 的动作应转化为以下动作：</p><div><pre class=\"crayon-plain-tag\">上全局锁
	        全局变量（DELETE_FILE,DELETE_LINE）赋值为文件名和行号2
                delete operator A
                  调用~A()
	            上全局锁
	            全局变量（DELETE_FILE,DELETE_LINE）赋值为文件名和行号1
	            delete operator B
		      调用~B()
                      返回~B()
		      调用operator delete B
			记录全局变量（DELETE_FILE,DELETE_LINE）值1并清除全局变量（DELETE_FILE,DELETE_LINE）值
			打开全局锁
		    返回operator delete B
	        返回delete operator B
             返回~A()
         调用 operator delete A
	   记录全局变量（DELETE_FILE,DELETE_LINE）值1并清除全局变量（DELETE_FILE,DELETE_LINE）值
	   打开全局锁
	 返回operator delete A
      返回 delete operator A</pre></div><p style=\"text-align: justify\">在这一过程中，有两个技术问题，一个是 <strong>mutex 的可重入问题</strong>，一个是嵌套删除时 <strong>对全局变量（DELETE_FILE,DELETE_LINE）</strong>现场保护的问题。</p><p style=\"text-align: justify\">所谓 <strong>mutex 的可重入问题</strong>，是指在同一个线程上下文中，连续对同一个 mutex 调用了多次 lock，然后连续调用了多次 unlock。这就是说我们的应用方式要求互斥锁有如下特性：</p><p style=\"text-align: justify\">1． 要求在同一个线程上下文中，能够多次持有同一个互斥体。并且只有在同一线程上下文中调用相同次数的 unlock 才能放弃对互斥体的占有。</p><p style=\"text-align: justify\">2． 对于不同线程上下文持有互斥体的企图，同一时间只有一个线程能够持有互斥体，并且只有在其释放互斥体之后，其他线程才能持有该互斥体。</p><p style=\"text-align: justify\">Pthread_mutex_t 互斥体不具有以上特性，即使在同一上下文中，第二次调用 pthread_mutex_lock 将会挂起。因此，我们必须实现出自己的互斥体。在这里我们使用 semaphore 的特性实现了一个符合上述特性描述的互斥体 CCommonMutex（源代码见附件）。</p><p style=\"text-align: justify\">为了支持特性 2，在这个 CCommonMutex 类中，封装了一个 semaphore，并在构造函数中令其资源值为 1，初始值为1。当调用 CCommonMutex::lock 接口时，调用 sem_wait 得到 semaphore，使信号量的资源为 0 从而让其他调用 lock 接口的线程挂起。当调用接口 CCommonMutex::unlock 时，调用 sem_post 使信号量资源恢复为 1，让其他挂起的线程中的一个持有信号量。</p><p style=\"text-align: justify\">同时为了支持特性 1，在这个 CCommonMutex 增加了对于当前线程 pid 的判断和当前线程访问计数。当线程第一次调用 lock 接口时，我们调用 sem_wait 的同时，记录当前的 Pid 到成员变量 m_pid，并置访问计数为 1，同一线程（m_pid == getpid()）其后的多次调用将只进行计数而不挂起。当调用 unlock 接口时，如果计数不为 1，则只需递减访问计数，直到递减访问计数为 1 才进行清除 pid、调用 sem_post。（具体代码可见附件）</p><p style=\"text-align: justify\"><strong>嵌套删除时对全局变量（DELETE_FILE,DELETE_LINE）</strong>现场保护的问题是指，上述步骤中在 A 的析构函数中调用 delete m_pB 时，对全局变量（DELETE_FILE,DELETE_LINE）文件名和行号的赋值将覆盖主程序中调用 delete pA 时对全局变量（DELETE_FILE,DELETE_LINE）的赋值，造成了在执行 operator delete A 时，delete pA 的信息全部丢失。</p><p style=\"text-align: justify\">要想对这些全局信息进行现场保护，最好用的就是堆栈了，在这里我们使用了 STL 提供的 stack 容器。在 DEBUG_DELETE 宏定义中，对全局变量（DELETE_FILE,DELETE_LINE）赋值之前，我们先判断是否前面已经有人对他们赋过值了&#8211;观察行号变量是否等于 0，如果不为 0，则应该将已有的信息压栈（调用一个全局函数 BuildStack() 将当前的全局文件名和行号数据压入一个全局堆栈globalStack），而后再对全局变量（DELETE_FILE,DELETE_LINE）赋值，再调用 delete operator。而在内存子系统的全局对象（appMemory）提供的 erase 接口里面，如果判断传入的文件名和行号为 0，则说明我们所需要的数据有可能被嵌套删除覆盖了，所以需要从堆栈中弹出相应的数据进行处理。</p><p style=\"text-align: justify\">现在嵌套删除中的问题基本解决了，但是当嵌套删除与 &#8220;错误方式删除带来的问题&#8221;一节的最后所描述的第一和第三种异常情况同时出现的时候，由于用户的 delete 调用没有通过我们定义的 DEBUG_DELETE 宏，上述机制可能出现问题。其根本原因是我们利用stack 保留了经由我们的 DEBUG_DELETE 宏记录的 delete 信息的现场，以便在 operator delete 和全局对象（appMemory）的 erase 接口中使用，但是用户的没经过 DEBUG_DELETE 宏的 delete 操作却未曾进行压栈操作而直接调用了 operator delete，有可能将不属于这次操作的 delete 信息弹出，破坏了堆栈信息的顺序和有效性。那么，当我们因为无法找到这次及其后续的 delete 操作所对应的内存分配信息的时候，可能会打印出错误的 warning 信息。</p><h1 id=\"N10124\">展望</h1><p style=\"text-align: justify\">以上就是我们所实现的内存泄漏检测子系统的原理和技术方案，第一版的源代码在附件中，已经经过了较严格的系统测试。但是限于我们的 C++ 知识水平和编程功底，在实现过程中肯定还有没有注意到的地方甚至是缺陷，希望能够得到大家的指正，我的 email 是 <a href=\"mailto:hcode@21cn.com\">hcode@21cn.com</a>。</p><p style=\"text-align: justify\">在我们所实现的内存检测子系统基础上，可以继续搭建内存分配优化子系统，从而形成一个完整的内存子系统。一种内存分配优化子系统的实现方案是一次性分配大块的内存，并使用特定的数据结构管理之，当内存分配请求到来时，使用特定算法从这块大内存中划定所需的一块给用户使用，而用户使用完毕，在将其划为空闲内存。这种内存优化方式将内存分配释放转换为简单的数据处理，极大的减少了内存申请和释放所耗费的时间。</p><p></p></div><div class=\"wp_rp_wrap  wp_rp_plain\" ><div class=\"wp_rp_content\"><h3 class=\"related_post_title\">相关文章</h3><ul class=\"related_post wp_rp\" style=\"visibility: visible\"><li ><a href=\"http://blog.jobbole.com/94497/\" class=\"wp_rp_title\">Linux 动态库相关知识整理</a></li><li ><a href=\"http://blog.jobbole.com/95375/\" class=\"wp_rp_title\">C/C++内存泄漏及检测</a></li><li ><a href=\"http://blog.jobbole.com/103640/\" class=\"wp_rp_title\">Linux 平台相关代码的 C++ 解决方案</a></li><li ><a href=\"http://blog.jobbole.com/104080/\" class=\"wp_rp_title\">编写高质量代码</a></li><li ><a href=\"http://blog.jobbole.com/103596/\" class=\"wp_rp_title\">Linux 下 C++ 异常处理技巧</a></li><li ><a href=\"http://blog.jobbole.com/80617/\" class=\"wp_rp_title\">C 语言中的指针和内存泄漏</a></li><li ><a href=\"http://blog.jobbole.com/88279/\" class=\"wp_rp_title\">Linux 内核里的“智能指针”</a></li><li ><a href=\"http://blog.jobbole.com/104032/\" class=\"wp_rp_title\">面向 C++ 的测试驱动开发</a></li><li ><a href=\"http://blog.jobbole.com/103669/\" class=\"wp_rp_title\">C++11 中的 Defaulted 和 Deleted 函数</a></li><li ><a href=\"http://blog.jobbole.com/86958/\" class=\"wp_rp_title\">如何用C++在不按回车的情况下获取标准输入中的字符</a></li></ul></div></div><p><a href=\"http://blog.jobbole.com/104042/\">如何在 Linux 下检测内存泄漏</a>，首发于<a href=\"http://blog.jobbole.com\">文章 - 伯乐在线</a>。</p>") (wfw:commentRss nil "http://blog.jobbole.com/104042/feed/") (slash:comments nil "0"))) ("面向 C++ 的测试驱动开发" "<div><h1>测试驱动开发（TDD）背景及综述</h1></div><div><p>测试驱动开发是 Kent 提出的一种新的软件开发流程，现在已广为人知，这种开发方法依赖于极短重复的开发周期，面对开发需求，开发人员要先开发代码测试用例，这些代码实现的测试用例定义了工程要实现的需求，然后去开发代码快速测试通过这这些用例，这个时候的代码是相对比较粗糙的，只是为了通过这个测试，测试通过以后，这些测试所覆盖的需求就会相对固定下来了，然后随着实现更多的需求，以前实现的那些粗糙的代码的问题会逐步的暴露出来，此时就要用重构来消除重复改进代码设计，因为自动化的测试用例已经框定了相应的需求，这样在代码改进和重构的过程中就不会破坏已实现的需求，实现了安全重构。</p><p>从测试驱动开发的流程可以看出来，测试驱动开发仅仅要求一个简单的设计开始实现需求，然后随着软件开发的推进实现有保护重构代码和设计。依赖于 TDD 开发所生成的单元测试用例代码，实现有保护重构是大型的软件开发项目不可以缺少的，代码级别的测试更能有效地提高软件产品的质量。测试驱动开发中的重构过程也是一个使设计逐步完善的过程。 本文的主要目的是使测试驱动开发落到实地，和具体的语言（C++）和单元测试框架结合起来，并用实例展示测试驱动开发的魅力。</p><h1 id=\"3.测试驱动开发的信条 |outline\">测试驱动开发的信条</h1><p>先开发和设计测试代码，再代码实现通过测试，以测试驱动设计实现，开发和设计的过程，得到了快速的反馈，用这些反馈驱动，改进和重构代码设计，是一个有机的开发过程。按照 Kent 的定义，测试驱动开发的原则是：</p><ol type=\"1\"><li>不要写一行代码，除非有一个失败的自动化测试案例要纠正。</li><li>消除重复的代码，改进设计。</li></ol><p>这两个简单的原则，却产生了一些复杂的个体和组的行为，这些隐含的技术行为包括：</p><ul><li>运行代码对设计决定快速反馈下，实现有机地设计</li><li>必须自己写自己的测试用例，而不是等待别人帮你写测试代码，那样会花费很长时间</li><li>必须要有对变更代码快发反应开发环境</li><li>组件必须要高内聚、低耦合，以使测试简单化。</li></ul><p>两个原则还隐含开发任务的顺序：</p><ol type=\"1\"><li>红色（Red）：写些不能够工作的小测试，这个测试甚至不能编译通过。</li><li>绿色（Green）：快速编写代码使测试通过，不用太在意代码质量只是通过测试。</li><li>重构（Refactor）：消除开始是只是要通过测试的重复代码，改进设计。</li></ol><p>红色（Red）-绿色（Green）-重构（Refactor），这个就是测试驱动开发的座右铭（Mantra）。这种开发方式可以有效的减少代码的缺陷密度，减少 bug 的数量，将大部分的缺陷在代码的开发过程中消除，减少了 QA 测试和质量保证的成本。</p><p>按照软件工程的说法，软件缺陷和 bug 发现的越早，所需的更正这些缺陷的成本就会越小。所以在软件的开发阶段，采用测试驱动的开发方法，把测试引入到开发阶段，使测试和质量意识融入到开发的过程中，这对提高软件工程质量非常有帮助。 而且在采用测试驱动开发必然要求所开发的组件、接口、类或方法是可测试的（testable），这就要求开发的组件，接口要遵循组件和类高内聚（Highly Cohesive），组件和组件、类和类之间低耦合（loosely Coupled）原则，这种开发方式生成的代码必然会帮助开发者，在不断的有保护重构的过程中，提高软件架构的设计，使日后的软件维护变得有章可循。</p><p>测试驱动开发符合敏捷软件开发的精神，在不断迭代过程中，增量地实现软件需求而这一切开始可以从简单设计开始。</p><h1 id=\"4.单元测试框架比较和筛选 |outline\">单元测试框架比较和筛选</h1><p>C++技术是一种高级语言，它出现的时间要比 Java 和 C#早得多，但支持像 xUnit 框架的 C++单元测试框架发展起来的比较晚。 C++ 的单元测试框架选择比较多，现在比较流行的 C++测试框架有 Boost Test、UnitTest++、CppTest、Google C++ Testing Framework。 Boost Test，拥有良好的断言功能，对异常控制，崩溃控制方面处理的比较好，也有良好的可以移植性，但结构复杂，不易于掌握。CPPUnit 是开发比较早的单元测试框架，是对 JUnit 的 C++的移植的一种尝试，拥有丰富的断言和期望功能。Google Test C++ 简称 Gtest，是近期发展起来的单元测试框架，对 xUnit 支持的比较好，支持 TDD 的红-绿-重构模式，支持死亡和退出测试，较好的异常测试控制能力，良好的测试报告输出，拥有自动注册测试用例和用例分组等功能，还有和 Gmock 框架的无缝结合，支持基于接口的（抽象类的）Mock 测试-模拟测试。</p><p>下表是一个对三种流行 C++单元测试框架的简单比较，Gtest 虽然发展起来的较晚，但丰富功能简单易用，易学，加之移植性较好，是跨平台项目单元测试框架比较好的选择。</p><h5 id=\"4.0.1.表 1.单元测试框架比较 |outline\">表 1.单元测试框架比较</h5><table cellspacing=\"0\" cellpadding=\"0\"><thead><tr><th>测试框架支持特性</th><th>Gtest</th><th>Boost Test</th><th>CPPUnit</th></tr></thead><tbody><tr><td>可移植性</td><td>较好</td><td>好（依赖于 Boost 库）</td><td>较好</td></tr><tr><td>丰富的断言</td><td>优</td><td>优</td><td>一般</td></tr><tr><td>丰富的断言信息</td><td>优</td><td>良好</td><td>较差</td></tr><tr><td>自动检测和注册测试用例</td><td>优</td><td>良</td><td>一般</td></tr><tr><td>易于扩展断言</td><td>易于扩展</td><td>一般</td><td>一般</td></tr><tr><td>支持死亡和退出测试（Death 和 Exit）</td><td>支持</td><td>支持</td><td>不支持</td></tr><tr><td>支持参数化测试（Parameterized test）</td><td>支持</td><td>支持</td><td>不支持</td></tr><tr><td>支持 Scoped_Trace</td><td>支持</td><td>不支持</td><td>不支持</td></tr><tr><td>支持选择性执行测试用例</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>丰富的测试报告形式（xml）</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>支持测试用例分组 Suites</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>开源</td><td>是</td><td>是</td><td>是</td></tr><tr><td>执行速度</td><td>快</td><td>快</td><td>快</td></tr><tr><td>基于接口的<code>Mock</code>测试</td><td>通过<code>Gmock</code>支持</td><td>不支持</td><td>不支持</td></tr><tr><td>易用性</td><td>优秀</td><td>较复杂</td><td>较好</td></tr><tr><td>支持类型化的参数化测试</td><td>支持</td><td>不直接支持</td><td>不直接支持</td></tr></tbody></table><h1 id=\"5.测试驱动开发-GTest 简介 |outline\">测试驱动开发-GTest 简介</h1><p>Gtest 是基于 xUnit 的 C++单元测试框架，支持自动化案例自动发掘，丰富的断言功能，支持用户自定义断言，支持死亡测试和退出测试，还有异常测试控制，支持值类型和类型化的参数化测试，接口简单易用，对每个测试案例有执行时间的输出，可以帮助分析代码的执行效率，单一接口文件 gtest.h。</p><p>图 1 是 Console 模式输出用红和绿表示失败和成功的测试用例，看起来比较符合 TDD 的策略和定义</p><h5 id=\"5.0.1.图 1.GTest 的案例测试结果输出 |outline\" style=\"text-align: center\">图 1.GTest 的案例测试结果输出</h5><p><img class=\"aligncenter\" src=\"http://www.ibm.com/developerworks/cn/linux/1401_xiajd_ctdd/image003.jpg\" alt=\"GTest 的案例测试结果输出\" /></p><p>Gtest 的断言有两种形式，致命性断言（Fatal Assertion）和非致命性断言（Nonfatal Assertion）。</p><p>除了基本的断言形式外，Gtest 还包括一些其他的高级断言形式，比如死亡断言，退出断言测试和异常断言等。</p><p>Gtest 还有其他的一些特性，比如类型参数化测试，值类型参数化的测试，测试用例分组，洗牌式测试等，可以参照附录中列出的 Gtest 的官网获取更多的信息。</p><p>在测试驱动软件开发的过程中，我们不可避免的要去依赖第三方系统，比如文件系统、第三方库、数据库访问，其他的在线数据的访问等，按照测试驱动开发的快速反馈的原则，如果在单元测试用例中去直接访问这些信息，势必在测试驱动开发过程中会依赖这些资源从而造成访问时间无法控制， 所以单元测试一般应该避免直接访问第三方系统，这就是 Mock 测试的主要目的，用模拟的接口去替换真实的接口，模拟出单元测试需要的第三方数据和接口进而隔离第三方的影响，专注于自己的逻辑实现。Gmock 就是这样一个 Mock 框架，它是类似于 jMock、EasyMock 和 Hamcres ，但是是 C++版本的 Mock 框架。 Gmock 是基于接口的 Mock 框架，在 C++中接口的定义是通过抽象函数和抽象类来实现的，这种要求势必会要求我们尽量遵循基于接口的编程原则，把交互界面上的操作抽象成接口，以便是接口可被模拟 Mock。可以在附录中列出的 Gmock 官网获取更多信息。</p><h1 id=\"6.测试驱动开发的实践 |outline\">测试驱动开发的实践</h1><p>测试驱动开发和敏捷开发是相辅相成的，敏捷开发的需求一般是以故事、产品功能列表，或需求用例的方式给出，拿到这些需求后，开发团队会根据相应的需求文档分析需求，做功能分解，根据功能优先级制定迭代开发计划和测试计划。测试驱动开发可以从两个角度来看，广义的和狭义的。广义的测试驱动开发是从流程上规定测试驱动开发，这种情况下一般要求 QA 走到前面，先根据需求先开发测试用例，这些测试用例会作为功能验收的标准，然后开发人员会根据测试用例做详细的功能设计和编码实现，最后提交给 QA 做功能验收测试。 狭义的测试驱动开发是开发人员拿到功能需求后，先自己开发代码级别的测试用例，然后开发具体的实现通过这些测试用例的一种开发方法。 本文涉及的是第二种，从代码级别开始的，狭义的测试驱动开发。</p><p>相信每个人都玩过棋牌游戏，简单起见，为了实践测试驱动开发方法我想开发一款简单的三子棋游戏，如图 2 所示。三子棋的游戏规则很简单，只要是同样的三个棋子连成一条线那么持对应棋子的人就胜出，图中持 O 子棋的人获胜。总结一下三子棋游戏的基本需求：</p><ol type=\"1\"><li>我需要一个 3X3 的棋盘，可以用下三子棋。</li><li>我需要在棋盘上下棋和获取到棋子。</li><li>我要能验证和判断是不是三个棋子在同一条线上，以判断是不是有人胜出。</li><li>我不能放棋子到已被占用的棋位置上。</li><li>我要能判断是不是棋盘已满并无赢家。</li><li>我需要能复位棋盘，以便于重新开始下棋。</li><li>我需要用对记住玩家，以便于我能特例化 Player</li><li>我需要能保存和加载棋局能力，以便于我能下次回来继续之前的游戏。</li></ol><h5 id=\"6.0.1.图 2.三子棋游戏 |outline\" style=\"text-align: center\">图 2.三子棋游戏</h5><p><img class=\"aligncenter\" src=\"http://www.ibm.com/developerworks/cn/linux/1401_xiajd_ctdd/image005.jpg\" alt=\"图 2.三子棋游戏\" /></p><p>以上是三子棋游戏的基本需求列表，拿到这些需求后，我会做一些简单解决方案的设计，解决方案包括 4 个子工程（C++ Project），其中一个测试工程 TicTacToeGamingTest，其余三个分别是 TicTacToeLib,TicToeGamingLib 和 TicTacToeConsoleGaming，这三个工程的依赖关系是 TicTacToeConsoleGaming 依赖于 TicToeGaminglib 和 TicTacToeLib，TicToeGamingLib 依赖于 TicTacToeLib。 建好这些工程,有了基本的设计思路后，在测试工程里首先开发的测试代码。</p><h5 id=\"6.0.2.图 3.解决方法设计 |outline\" style=\"text-align: center\">图 3.解决方法设计</h5><p style=\"text-align: center\"><img src=\"http://www.ibm.com/developerworks/cn/linux/1401_xiajd_ctdd/image007.jpg\" alt=\"图 3.解决方法设计\" /></p></div><div><p>先看第一个需求：</p><p><strong>1.我需要一个 3X3 的棋盘，可以来下三子棋。</strong></p><p style=\"text-align: center\">这个需求很简单，现在的棋盘不需要包括任何的逻辑，为了便于测试我需要一个接口去访问它，现在接口是空的，也没有实现，这样一个测试用例就可以满足这个需求：</p><div style=\"text-align: center\"><pre class=\"crayon-plain-tag\">TEST_F(TicTacToeTestFixture,IWantAGameBoard)
{
IGameBoard *gameBoard=NULL;
EXPECT_NO_THROW(gameBoard=new SimpleGameBoard(\"simpleGame\"));
EXPECT_TRUE(gameBoard!=NULL);
EXPECT_NO_THROW(delete gameBoard);
}</pre></div><p style=\"text-align: justify\">这是第一个测试用例，稍微解释一下。TicTacToeTestFixture 是用于测试的分组的，它是一个类，继承于 Gtest 的 test 类 testing::Test，这个类可以重载 setup 和 teardown 等虚拟函数用于测试准备和清理测试现场。<code>TEST_F</code> 是定义测试用例的宏，IWantAGameBoard 是测试的案例的名称，会显示在输出中，测试用例很简单，只是只是保证能创建和析构 SimpleGameBoard 实例，并无异常抛出。这个测试用例现在是不能编译通过的，因为 IGameBoard 接口和 SimplegameBoard 都还没有声明和定义,接下来为了使这个案例通过，我在 TicTacToeLib 工程里，声明和定义 IGameBoard 和 SimpleGameBoard 类，IGameBoard 是纯抽象类，抽象了所有对棋盘的操作。引入声明到测试工程中，编译通过并运行，现在完成了第一测试用例，尽管测试的 IGameBoard 和 SimpleGameBoard 还是空的。可以看一下输出：</p><h5 id=\"6.0.3.图 4 .测试用例输出 |outline\" style=\"text-align: center\">图 4 .测试用例输出</h5><p><img class=\"aligncenter\" src=\"http://www.ibm.com/developerworks/cn/linux/1401_xiajd_ctdd/image009.jpg\" alt=\"图 4 .测试用例输出\" /></p><p><strong>2.我需要在棋盘上下棋和获取到棋子</strong></p><p>这个需求能使棋手在棋盘上把棋子放到想要的位置上并能查看指定棋盘位置上的棋子，棋盘是 3×3。实现这个需求也很简单，我只要在 IGameBoard 接口上添加两个函数然后在 SimpleGameBoard 里实现这两个函数就可以满足这个需求：</p><div><pre class=\"crayon-plain-tag\">virtual void PutChess(int x,int y,char chess)=0;
virtual char GetChess(int x,int y)=0 ;
有了这个思路，我想这样设计这个测试用例：
TEST_F(TicTacToeTestFixture,PutandGetChess)
{
char xChess='X';
char yChess='Y';
IGameBoard *gameBoard=new SimpleGameBoard(\"simpleBoard\");
gameBoard-&gt;PutChess(0,0,xChess);
gameBoard-&gt;PutChess(2,2,yChess);
EXPECT_EQ(xChess,gameBoard-&gt;GetChess(0,0));
EXPECT_EQ(yChess,gameBoard-&gt;GetChess(2,2));
delete gameBoard;
}</pre></div><p>试着编译这个测试工程，失败，原因是没有实现这两个函数，接下来我回到 TicTacToeLib 工程去声明和定义这两个函数。为了实现这两个功能，在 SimpleGameBoard 定义 private 数据：<code>vector<code>char</code><code>&gt; data_;用于 保存棋子和位置信息，为了简单，棋子用 Char 类型来表示，位置信息和 data_向量的下标对应,如棋盘位置（2，2）对应的是 data_[2*3+2]这个位置，数据是安行存放的。两个函数的实现是：</code></code></p><div><pre class=\"crayon-plain-tag\">void SimpleGameBoard::PutChess( int x,int y,char chess )
{
assert(x&lt;xMaxDim&amp;&amp;y&lt;yMaxDim);
int xy=x*3+y;
if(data_.size()==0)initboard_();
data_[xy]=chess;
}
char SimpleGameBoard::GetChess( int x,int y )
{
assert(x&lt;xMaxDim&amp;&amp;y&lt;yMaxDim);
assert(data_.size()==yMaxDim*xMaxDim);
return data_[x*3+y];
}</pre></div><p>initboard_()是个 protected 函数，用于初始化 data_。 现在可以重现编译和运行测试工程，结果如下：</p><h5 id=\"6.0.4.图 5 .测试用例输出 |outline\" style=\"text-align: center\">图 5 .测试用例输出</h5><p><img class=\"aligncenter\" src=\"http://www.ibm.com/developerworks/cn/linux/1401_xiajd_ctdd/image011.jpg\" alt=\"图 5 .测试用例输出\" /></p><p>有了两个测试用例的实现，并且运行是绿色，继续下个需求。</p><p><strong>3.我要能验证和判断是不是三个棋子在同一条线上，以判断是不是有人胜出</strong></p><p>这个需求用于判断三个棋子是否已经在一条线上，如果是的话，那么持对应棋子的棋手就会胜出，这个测试用例可以这样设计：</p><div><pre class=\"crayon-plain-tag\">TEST_F(TicTacToeTestFixture,JugeThreeInLine)
{
IGameBoard *gameBoard=new SimpleGameBoard(\"simpleBoard\");
IGameBoard *gameBoard2=new SimpleGameBoard(\"simpleboard2\");
char xChess='x',yChess='o';
gameBoard-&gt;PutChess(0,0,xChess); gameBoard2-&gt;PutChess(0,1,yChess);
gameBoard-&gt;PutChess(1,1,xChess); gameBoard2-&gt;PutChess(1,1,yChess);
gameBoard-&gt;PutChess(2,2,xChess); gameBoard2-&gt;PutChess(2,1,yChess);
EXPECT_TRUE(gameBoard-&gt;CheckWinOut(xChess));
EXPECT_TRUE(gameBoard2-&gt;CheckWinOut(yChess));
EXPECT_FALSE(gameBoard-&gt;CheckWinOut(yChess));
EXPECT_FALSE(gameBoard2-)CheckWinOut(xChess));
delete gameBoard;
delete gameBoard2;
}</pre></div><p>设计是这样的，为简单，我把判断棋子胜出的函数 CheckWinOut 定义到接口 IGameBoard 中，并在 SimpleGameBoard 中实现它，实现如下：</p><div><pre class=\"crayon-plain-tag\">bool SimpleGameBoard::CheckWinOut(char chess)
{
return IsThreeInLine_(chess);
}</pre></div><p>IsThreeInLine_是受保护的成员函数，它会扫描棋盘的行，列和对角线看是否指定的棋子在一条线上，如果有三个棋子在一条线上，则说明有人胜出。编译运行测试，绿色通过。 继续下一个需求。</p><p><strong>4.我不能放棋子到已被占用的棋位置上。</strong></p><p>这个需求是个验证性需求，要保证棋子不能重叠和覆盖已在棋盘上的棋子，实现这个需求我只要重构现有的代码加上避免棋子重叠的逻辑。只要避免在 PutChess 时候，检查是否指定的位置是否已有棋子，如果是简单的抛出异常即可。有了这些基本的思路，我开始设计测试用例。</p><div><pre class=\"crayon-plain-tag\">TEST_F(TicTacToeTestFixture,BizException_Occupied){
IGameBoard *gameBoard=new SimpleGameBoard(\"simple board\");
char xChar='X',yChar='0';
EXPECT_NO_THROW(gameBoard-&gt;PutChess(0,0,xChar));
<strong>EXPECT_THROW(gameBoard-&gt;PutChess(0,0,xChar),ChessOverlapException); </strong>
EXPECT_NO_THROW(gameBoard-&gt;PutChess(2,2,yChar));
<strong>EXPECT_THROW(gameBoard-&gt;PutChess(2,2,yChar),ChessOverlapException); </strong>
delete gameBoard;
}</pre></div><p>ChessOverlapException 是我将要实现的一个异常类，这个是在棋手试图放棋子到已有棋子的棋盘位置上时要抛出的异常。测试用例中，我在（0，0）和（2，2）这两个位置上放同样的棋子以触发这个异常。为了编译通过，我开始实现 ChessOverlapException。 ChessOverlapException 继承自 std::exception 我重载了 what 函数返回相应的异常信息。 把这个异常类的定义引入的测试工程中，编译通过运行测试，但却得到了红色 Red，案例失败：</p><p style=\"text-align: center\">图 6.测试用例输出</p><p><img class=\"aligncenter\" src=\"http://www.ibm.com/developerworks/cn/linux/1401_xiajd_ctdd/image013.jpg\" alt=\"图 6.测试用例输出\" /></p><p>原因是我还没有重构 PutChess 函数以加入避免棋子被被覆盖的代码。现在来重构 PutChess 函数：</p><div><pre class=\"crayon-plain-tag\">void SimpleGameBoard::PutChess( int x,int y,char chess )
{
assert(x&lt;xMaxDim&amp;&amp;y&lt;yMaxDim);
int xy=x*3+y;
if(data_.size()==0){
initboard_();
data_[xy]=chess;
return ;
}
if(data_[xy]!='+') {
throw ChessOverlapException(\"chess overlap!\");
}
else data_[xy]=chess;
}</pre></div><p>重新编译测试工程并运行得到绿色 Green 通过。继续下一个需求。</p><p><strong>5.我要能判断是不是棋盘已满并无赢家。 </strong></p><p>这个需求用于判断是否是和棋的情况，棋盘满了但并无赢家，这是可能出现的一种情况，这个实现设计可以有两种方式. 一是重构 CheckWinOut 函数，使返回值携带更多的信息，比如和棋，有人胜出等。二是定义一个独立的函数去判断棋盘的当前状态。第一种方案较合理，开始设计这种方案的测试用例：</p><div><pre class=\"crayon-plain-tag\">EST_F(TicTacToeTestFixture,IsEndedInADraw)
{
char xChess='X',yChess='O';
IGameBoard *gameBoard=new SimpleGameBoard(\"simpleBoard\");
gameBoard-&gt;PutChess(0,0,yChess);gameBoard-&gt;PutChess(0,1,xChess);gameBoard-&gt;PutChess(0,2,yChess);
gameBoard-&gt;PutChess(1,0,xChess);gameBoard-&gt;PutChess(1,1,yChess);gameBoard-&gt;PutChess(1,2,yChess);
gameBoard-&gt;PutChess(2,0,xChess);gameBoard-&gt;PutChess(2,1,yChess);gameBoard-&gt;PutChess(2,2,xChess);
<strong>GameBoardStatus status=gameBoard-&gt;CheckWinOut(yChess);
EXPECT_TRUE(status==GAMEDRAW); </strong><strong>GameBoardStatus status2=gameBoard-&gt;CheckWinOut(xChess); EXPECT_TRUE(status2==GAMEDRAW);</strong>
delete gameBoard;
}</pre></div><p>以上的测试用例可以看出， 我设计了和棋的棋局，并想重构 CheckWinout 函数，使其返回枚举类型 GameBoardStatus 以表示棋局的状态，其中 GAMEDRAW 表示和棋状态。为了使工程能编译通过，开始定义这个枚举类型并重构 CheckWinOut 函数。实现所有设计，经过几次的 Red 失败，最终 形成代码：</p><div><pre class=\"crayon-plain-tag\">GameBoardStatus SimpleGameBoard::CheckWinOut(char chess)
{
if(IsThreeInLine_(chess)){
return GAMEMWINOUT;
}
else if(IsEndedInADraw_()){
return GAMEDRAW;
}
else{
return GAMERUNNING;
}
}</pre></div><p>其中那个 IsEndedInADraw_是个受保护的成员函数，用于检测是否和棋。 在调通这个测试用例的过程中，我也更新了测试<code>JugeThreeInLine。因为重构 ChecWinOut 改变了返回类型。</code></p><p><strong>6.我需要能复位棋盘，以便于重新开始下棋。</strong></p><p><strong>7.我需要用对记住玩家，以便于我能特例化 Player。</strong></p><p>6 和 7 需求的测试案例和实现比较比较简单，不在赘述，7 的要求是要建立玩家 Player，这个主要是说要能实例化玩家。可以看附带的工程。</p><p><strong>8.我需要能保存和加载棋局能力，以便于我能下次回来继续之前的游戏</strong>。</p><p>这个需求是一个合理的需求，玩家可以保存和继续回来玩游戏，他的测试用例可以这样设计：</p><div><pre class=\"crayon-plain-tag\">TEST_F(TicTacToeTestFixture,SaveTheBoard)
{
IGameBoard * gameBoard=new SimpleGameBoard(\"simpleBoard\");
char xChess='x',yChess='o';
gameBoard-&gt;PutChess(0,0,xChess);
gameBoard-&gt;PutChess(1,2,yChess);
IGameIO *gameIO=new SimpleGameIO();
EXPECT_NO_THROW(gameIO-&gt;save(gameBoard,\"somewhere\"));
delete gameBoard;
delete gameIO;
}
TEST_F(TicTacToeTestFixture,LoadTheBoard)
{
IGameBoard * gameBoard=new SimpleGameBoard(\"simpleBoard\");
char xChess='x',yChess='o';
gameBoard-&gt;PutChess(0,0,xChess);
gameBoard-&gt;PutChess(1,2,yChess);
IGameIO *gameIO=new SimpleGameIO();
EXPECT_NO_THROW(gameIO-&gt;save(gameBoard,\"somewhere\"));
IGameBoard *game=gameIO-&gt;load(\"somewhere\");
EXPECT_EQ(xChess,game-&gt;GetChess(0,0));
EXPECT_EQ(yChess,game-&gt;GetChess(1,2));
EXPECT_EQ('+',game-&gt;GetChess(2,2));
delete game;</pre></div><div><pre class=\"crayon-plain-tag\">delete gameBoard;
delete gameIO;
}</pre></div><p>这里用两个测试用例来覆盖这个需求，一个是保存棋盘，一个是加载棋盘。由这个测试用例可以看到，要通过这个测试，必须要定义 IGameIO 接口和 SimpeGameIO 类。 保存棋盘的媒介是文件。按照 TDD 的开发要求，测试单元本身最好是脱离对第三方系统的依赖，但测试中必然会用到第三方系统，解决这些问题的方法有几种。创建第三方系统的 Stub 类或是 FakedObject，第三种选择是 Mock 框架，如 Gmock。 Gmock 的设计理念是基于接口的，只要是第三方访问提供的是接口，这些访问就可以可以被用 Gmock 模拟。可以看参考文献获取更多的信息。 限于篇幅不再赘述。一下是完成所有测试用例的测试结果。</p><h5 id=\"6.0.6.图 7.测试用例输出 |outline\" style=\"text-align: center\">图 7.测试用例输出</h5><p><img class=\"aligncenter\" src=\"http://www.ibm.com/developerworks/cn/linux/1401_xiajd_ctdd/image015.jpg\" alt=\"图 7.测试用例输出\" /></p><p>或许你会注意到有些测试用例的设计，只是以点盖面，如果想要更多的验证点可以借助于 Gtest 提供的参数化测试设计测试数据，然后去测试实现的类和逻辑。 还有死亡测试的用例，可以在参考资源中的 Gtest 资源中查看。</p><h1 id=\"7.结论 |outline\">结论</h1><p>C++中实现测试驱动开发 TDD 之前是很困难的事。 但有了类似于 xUnit 的 Gtest 和 Gmock 测试框架，在 C++工程中实现 TDD 也变得很享受。测试驱动开发是一个很好的工具，它可以帮助开发者实现有机开发，在需求的实现过程中快速得到反馈，另一个好处是测试驱动开发可以使开发人员更加重视需求和测试，以测试用例为中心，这样势必会产生更好代码。从软件工程的角度来说，测试驱动开发的实践应用会大幅度的提高软件开发的质量，用代码级别的测试用例来覆盖和保障程序的健壮性更能保障整个软件产品的开发质量。</p><p>测试驱动开发的座右铭模式：红色-绿色-重构，然后重复这个直到开发完成为止，是一个自我确认和有保护代码重构的过程。采用测试驱动开发的模式的软件产品，产生的单元测试代码，从代码级别测试覆盖了软件的需求，使以后的代码重构更安全可靠。</p></div><div class=\"wp_rp_wrap  wp_rp_plain\" ><div class=\"wp_rp_content\"><h3 class=\"related_post_title\">相关文章</h3><ul class=\"related_post wp_rp\" style=\"visibility: visible\"><li ><a href=\"http://blog.jobbole.com/104042/\" class=\"wp_rp_title\">如何在 Linux 下检测内存泄漏</a></li><li ><a href=\"http://blog.jobbole.com/103640/\" class=\"wp_rp_title\">Linux 平台相关代码的 C++ 解决方案</a></li><li ><a href=\"http://blog.jobbole.com/94497/\" class=\"wp_rp_title\">Linux 动态库相关知识整理</a></li><li ><a href=\"http://blog.jobbole.com/103596/\" class=\"wp_rp_title\">Linux 下 C++ 异常处理技巧</a></li><li ><a href=\"http://blog.jobbole.com/88279/\" class=\"wp_rp_title\">Linux 内核里的“智能指针”</a></li><li ><a href=\"http://blog.jobbole.com/86392/\" class=\"wp_rp_title\">C++和双重检查锁定模式(DCLP)的风险</a></li><li ><a href=\"http://blog.jobbole.com/104080/\" class=\"wp_rp_title\">编写高质量代码</a></li><li ><a href=\"http://blog.jobbole.com/92792/\" class=\"wp_rp_title\">Linux Shell 创建序列数组</a></li><li ><a href=\"http://blog.jobbole.com/103662/\" class=\"wp_rp_title\">C++11 中的右值引用与转移语义</a></li><li ><a href=\"http://blog.jobbole.com/85186/\" class=\"wp_rp_title\">Linux 上的最佳 C/C++ IDE</a></li></ul></div></div><p><a href=\"http://blog.jobbole.com/104032/\">面向 C++ 的测试驱动开发</a>，首发于<a href=\"http://blog.jobbole.com\">文章 - 伯乐在线</a>。</p>" "http://blog.jobbole.com/104032/" (22430 48204) old 16 nil nil ((title nil "面向 C++ 的测试驱动开发") (link nil "http://blog.jobbole.com/104032/") (comments nil "http://blog.jobbole.com/104032/#respond") (pubDate nil "Mon, 01 Aug 2016 03:04:44 +0000") (dc:creator nil "中二饼") (category nil "C/C++") (category nil "开发") (category nil "C++") (category nil "Linux") (guid ((isPermaLink . "false")) "http://blog.jobbole.com/?p=104032") (description nil "<p>用测试的方法驱动开发，这个概念的提出已经很长时间了，但测试驱动开发在 C 和 C++的应用和实践却比较晚，本文用一个简单项目的实例说明如何在 C 和 C++的开发过程中，应用测试驱动开发的理念，从需求定义，代码测试案例设计到开发实现这些案例定义的需求，展现了测试驱动开发的魅力。</p><p><a href=\"http://blog.jobbole.com/104032/\">面向 C++ 的测试驱动开发</a>，首发于<a href=\"http://blog.jobbole.com\">文章 - 伯乐在线</a>。</p>") (content:encoded nil "<div><h1>测试驱动开发（TDD）背景及综述</h1></div><div><p>测试驱动开发是 Kent 提出的一种新的软件开发流程，现在已广为人知，这种开发方法依赖于极短重复的开发周期，面对开发需求，开发人员要先开发代码测试用例，这些代码实现的测试用例定义了工程要实现的需求，然后去开发代码快速测试通过这这些用例，这个时候的代码是相对比较粗糙的，只是为了通过这个测试，测试通过以后，这些测试所覆盖的需求就会相对固定下来了，然后随着实现更多的需求，以前实现的那些粗糙的代码的问题会逐步的暴露出来，此时就要用重构来消除重复改进代码设计，因为自动化的测试用例已经框定了相应的需求，这样在代码改进和重构的过程中就不会破坏已实现的需求，实现了安全重构。</p><p>从测试驱动开发的流程可以看出来，测试驱动开发仅仅要求一个简单的设计开始实现需求，然后随着软件开发的推进实现有保护重构代码和设计。依赖于 TDD 开发所生成的单元测试用例代码，实现有保护重构是大型的软件开发项目不可以缺少的，代码级别的测试更能有效地提高软件产品的质量。测试驱动开发中的重构过程也是一个使设计逐步完善的过程。 本文的主要目的是使测试驱动开发落到实地，和具体的语言（C++）和单元测试框架结合起来，并用实例展示测试驱动开发的魅力。</p><h1 id=\"3.测试驱动开发的信条 |outline\">测试驱动开发的信条</h1><p>先开发和设计测试代码，再代码实现通过测试，以测试驱动设计实现，开发和设计的过程，得到了快速的反馈，用这些反馈驱动，改进和重构代码设计，是一个有机的开发过程。按照 Kent 的定义，测试驱动开发的原则是：</p><ol type=\"1\"><li>不要写一行代码，除非有一个失败的自动化测试案例要纠正。</li><li>消除重复的代码，改进设计。</li></ol><p>这两个简单的原则，却产生了一些复杂的个体和组的行为，这些隐含的技术行为包括：</p><ul><li>运行代码对设计决定快速反馈下，实现有机地设计</li><li>必须自己写自己的测试用例，而不是等待别人帮你写测试代码，那样会花费很长时间</li><li>必须要有对变更代码快发反应开发环境</li><li>组件必须要高内聚、低耦合，以使测试简单化。</li></ul><p>两个原则还隐含开发任务的顺序：</p><ol type=\"1\"><li>红色（Red）：写些不能够工作的小测试，这个测试甚至不能编译通过。</li><li>绿色（Green）：快速编写代码使测试通过，不用太在意代码质量只是通过测试。</li><li>重构（Refactor）：消除开始是只是要通过测试的重复代码，改进设计。</li></ol><p>红色（Red）-绿色（Green）-重构（Refactor），这个就是测试驱动开发的座右铭（Mantra）。这种开发方式可以有效的减少代码的缺陷密度，减少 bug 的数量，将大部分的缺陷在代码的开发过程中消除，减少了 QA 测试和质量保证的成本。</p><p>按照软件工程的说法，软件缺陷和 bug 发现的越早，所需的更正这些缺陷的成本就会越小。所以在软件的开发阶段，采用测试驱动的开发方法，把测试引入到开发阶段，使测试和质量意识融入到开发的过程中，这对提高软件工程质量非常有帮助。 而且在采用测试驱动开发必然要求所开发的组件、接口、类或方法是可测试的（testable），这就要求开发的组件，接口要遵循组件和类高内聚（Highly Cohesive），组件和组件、类和类之间低耦合（loosely Coupled）原则，这种开发方式生成的代码必然会帮助开发者，在不断的有保护重构的过程中，提高软件架构的设计，使日后的软件维护变得有章可循。</p><p>测试驱动开发符合敏捷软件开发的精神，在不断迭代过程中，增量地实现软件需求而这一切开始可以从简单设计开始。</p><h1 id=\"4.单元测试框架比较和筛选 |outline\">单元测试框架比较和筛选</h1><p>C++技术是一种高级语言，它出现的时间要比 Java 和 C#早得多，但支持像 xUnit 框架的 C++单元测试框架发展起来的比较晚。 C++ 的单元测试框架选择比较多，现在比较流行的 C++测试框架有 Boost Test、UnitTest++、CppTest、Google C++ Testing Framework。 Boost Test，拥有良好的断言功能，对异常控制，崩溃控制方面处理的比较好，也有良好的可以移植性，但结构复杂，不易于掌握。CPPUnit 是开发比较早的单元测试框架，是对 JUnit 的 C++的移植的一种尝试，拥有丰富的断言和期望功能。Google Test C++ 简称 Gtest，是近期发展起来的单元测试框架，对 xUnit 支持的比较好，支持 TDD 的红-绿-重构模式，支持死亡和退出测试，较好的异常测试控制能力，良好的测试报告输出，拥有自动注册测试用例和用例分组等功能，还有和 Gmock 框架的无缝结合，支持基于接口的（抽象类的）Mock 测试-模拟测试。</p><p>下表是一个对三种流行 C++单元测试框架的简单比较，Gtest 虽然发展起来的较晚，但丰富功能简单易用，易学，加之移植性较好，是跨平台项目单元测试框架比较好的选择。</p><h5 id=\"4.0.1.表 1.单元测试框架比较 |outline\">表 1.单元测试框架比较</h5><table cellspacing=\"0\" cellpadding=\"0\"><thead><tr><th>测试框架支持特性</th><th>Gtest</th><th>Boost Test</th><th>CPPUnit</th></tr></thead><tbody><tr><td>可移植性</td><td>较好</td><td>好（依赖于 Boost 库）</td><td>较好</td></tr><tr><td>丰富的断言</td><td>优</td><td>优</td><td>一般</td></tr><tr><td>丰富的断言信息</td><td>优</td><td>良好</td><td>较差</td></tr><tr><td>自动检测和注册测试用例</td><td>优</td><td>良</td><td>一般</td></tr><tr><td>易于扩展断言</td><td>易于扩展</td><td>一般</td><td>一般</td></tr><tr><td>支持死亡和退出测试（Death 和 Exit）</td><td>支持</td><td>支持</td><td>不支持</td></tr><tr><td>支持参数化测试（Parameterized test）</td><td>支持</td><td>支持</td><td>不支持</td></tr><tr><td>支持 Scoped_Trace</td><td>支持</td><td>不支持</td><td>不支持</td></tr><tr><td>支持选择性执行测试用例</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>丰富的测试报告形式（xml）</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>支持测试用例分组 Suites</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>开源</td><td>是</td><td>是</td><td>是</td></tr><tr><td>执行速度</td><td>快</td><td>快</td><td>快</td></tr><tr><td>基于接口的<code>Mock</code>测试</td><td>通过<code>Gmock</code>支持</td><td>不支持</td><td>不支持</td></tr><tr><td>易用性</td><td>优秀</td><td>较复杂</td><td>较好</td></tr><tr><td>支持类型化的参数化测试</td><td>支持</td><td>不直接支持</td><td>不直接支持</td></tr></tbody></table><h1 id=\"5.测试驱动开发-GTest 简介 |outline\">测试驱动开发-GTest 简介</h1><p>Gtest 是基于 xUnit 的 C++单元测试框架，支持自动化案例自动发掘，丰富的断言功能，支持用户自定义断言，支持死亡测试和退出测试，还有异常测试控制，支持值类型和类型化的参数化测试，接口简单易用，对每个测试案例有执行时间的输出，可以帮助分析代码的执行效率，单一接口文件 gtest.h。</p><p>图 1 是 Console 模式输出用红和绿表示失败和成功的测试用例，看起来比较符合 TDD 的策略和定义</p><h5 id=\"5.0.1.图 1.GTest 的案例测试结果输出 |outline\" style=\"text-align: center\">图 1.GTest 的案例测试结果输出</h5><p><img class=\"aligncenter\" src=\"http://www.ibm.com/developerworks/cn/linux/1401_xiajd_ctdd/image003.jpg\" alt=\"GTest 的案例测试结果输出\" /></p><p>Gtest 的断言有两种形式，致命性断言（Fatal Assertion）和非致命性断言（Nonfatal Assertion）。</p><p>除了基本的断言形式外，Gtest 还包括一些其他的高级断言形式，比如死亡断言，退出断言测试和异常断言等。</p><p>Gtest 还有其他的一些特性，比如类型参数化测试，值类型参数化的测试，测试用例分组，洗牌式测试等，可以参照附录中列出的 Gtest 的官网获取更多的信息。</p><p>在测试驱动软件开发的过程中，我们不可避免的要去依赖第三方系统，比如文件系统、第三方库、数据库访问，其他的在线数据的访问等，按照测试驱动开发的快速反馈的原则，如果在单元测试用例中去直接访问这些信息，势必在测试驱动开发过程中会依赖这些资源从而造成访问时间无法控制， 所以单元测试一般应该避免直接访问第三方系统，这就是 Mock 测试的主要目的，用模拟的接口去替换真实的接口，模拟出单元测试需要的第三方数据和接口进而隔离第三方的影响，专注于自己的逻辑实现。Gmock 就是这样一个 Mock 框架，它是类似于 jMock、EasyMock 和 Hamcres ，但是是 C++版本的 Mock 框架。 Gmock 是基于接口的 Mock 框架，在 C++中接口的定义是通过抽象函数和抽象类来实现的，这种要求势必会要求我们尽量遵循基于接口的编程原则，把交互界面上的操作抽象成接口，以便是接口可被模拟 Mock。可以在附录中列出的 Gmock 官网获取更多信息。</p><h1 id=\"6.测试驱动开发的实践 |outline\">测试驱动开发的实践</h1><p>测试驱动开发和敏捷开发是相辅相成的，敏捷开发的需求一般是以故事、产品功能列表，或需求用例的方式给出，拿到这些需求后，开发团队会根据相应的需求文档分析需求，做功能分解，根据功能优先级制定迭代开发计划和测试计划。测试驱动开发可以从两个角度来看，广义的和狭义的。广义的测试驱动开发是从流程上规定测试驱动开发，这种情况下一般要求 QA 走到前面，先根据需求先开发测试用例，这些测试用例会作为功能验收的标准，然后开发人员会根据测试用例做详细的功能设计和编码实现，最后提交给 QA 做功能验收测试。 狭义的测试驱动开发是开发人员拿到功能需求后，先自己开发代码级别的测试用例，然后开发具体的实现通过这些测试用例的一种开发方法。 本文涉及的是第二种，从代码级别开始的，狭义的测试驱动开发。</p><p>相信每个人都玩过棋牌游戏，简单起见，为了实践测试驱动开发方法我想开发一款简单的三子棋游戏，如图 2 所示。三子棋的游戏规则很简单，只要是同样的三个棋子连成一条线那么持对应棋子的人就胜出，图中持 O 子棋的人获胜。总结一下三子棋游戏的基本需求：</p><ol type=\"1\"><li>我需要一个 3X3 的棋盘，可以用下三子棋。</li><li>我需要在棋盘上下棋和获取到棋子。</li><li>我要能验证和判断是不是三个棋子在同一条线上，以判断是不是有人胜出。</li><li>我不能放棋子到已被占用的棋位置上。</li><li>我要能判断是不是棋盘已满并无赢家。</li><li>我需要能复位棋盘，以便于重新开始下棋。</li><li>我需要用对记住玩家，以便于我能特例化 Player</li><li>我需要能保存和加载棋局能力，以便于我能下次回来继续之前的游戏。</li></ol><h5 id=\"6.0.1.图 2.三子棋游戏 |outline\" style=\"text-align: center\">图 2.三子棋游戏</h5><p><img class=\"aligncenter\" src=\"http://www.ibm.com/developerworks/cn/linux/1401_xiajd_ctdd/image005.jpg\" alt=\"图 2.三子棋游戏\" /></p><p>以上是三子棋游戏的基本需求列表，拿到这些需求后，我会做一些简单解决方案的设计，解决方案包括 4 个子工程（C++ Project），其中一个测试工程 TicTacToeGamingTest，其余三个分别是 TicTacToeLib,TicToeGamingLib 和 TicTacToeConsoleGaming，这三个工程的依赖关系是 TicTacToeConsoleGaming 依赖于 TicToeGaminglib 和 TicTacToeLib，TicToeGamingLib 依赖于 TicTacToeLib。 建好这些工程,有了基本的设计思路后，在测试工程里首先开发的测试代码。</p><h5 id=\"6.0.2.图 3.解决方法设计 |outline\" style=\"text-align: center\">图 3.解决方法设计</h5><p style=\"text-align: center\"><img src=\"http://www.ibm.com/developerworks/cn/linux/1401_xiajd_ctdd/image007.jpg\" alt=\"图 3.解决方法设计\" /></p></div><div><p>先看第一个需求：</p><p><strong>1.我需要一个 3X3 的棋盘，可以来下三子棋。</strong></p><p style=\"text-align: center\">这个需求很简单，现在的棋盘不需要包括任何的逻辑，为了便于测试我需要一个接口去访问它，现在接口是空的，也没有实现，这样一个测试用例就可以满足这个需求：</p><div style=\"text-align: center\"><pre class=\"crayon-plain-tag\">TEST_F(TicTacToeTestFixture,IWantAGameBoard)
{

	IGameBoard *gameBoard=NULL; 
    EXPECT_NO_THROW(gameBoard=new SimpleGameBoard(\"simpleGame\")); 
	EXPECT_TRUE(gameBoard!=NULL); 	
    EXPECT_NO_THROW(delete gameBoard);
}</pre></div><p style=\"text-align: justify\">这是第一个测试用例，稍微解释一下。TicTacToeTestFixture 是用于测试的分组的，它是一个类，继承于 Gtest 的 test 类 testing::Test，这个类可以重载 setup 和 teardown 等虚拟函数用于测试准备和清理测试现场。<code>TEST_F</code> 是定义测试用例的宏，IWantAGameBoard 是测试的案例的名称，会显示在输出中，测试用例很简单，只是只是保证能创建和析构 SimpleGameBoard 实例，并无异常抛出。这个测试用例现在是不能编译通过的，因为 IGameBoard 接口和 SimplegameBoard 都还没有声明和定义,接下来为了使这个案例通过，我在 TicTacToeLib 工程里，声明和定义 IGameBoard 和 SimpleGameBoard 类，IGameBoard 是纯抽象类，抽象了所有对棋盘的操作。引入声明到测试工程中，编译通过并运行，现在完成了第一测试用例，尽管测试的 IGameBoard 和 SimpleGameBoard 还是空的。可以看一下输出：</p><h5 id=\"6.0.3.图 4 .测试用例输出 |outline\" style=\"text-align: center\">图 4 .测试用例输出</h5><p><img class=\"aligncenter\" src=\"http://www.ibm.com/developerworks/cn/linux/1401_xiajd_ctdd/image009.jpg\" alt=\"图 4 .测试用例输出\" /></p><p><strong>2.我需要在棋盘上下棋和获取到棋子</strong></p><p>这个需求能使棋手在棋盘上把棋子放到想要的位置上并能查看指定棋盘位置上的棋子，棋盘是 3&#215;3。实现这个需求也很简单，我只要在 IGameBoard 接口上添加两个函数然后在 SimpleGameBoard 里实现这两个函数就可以满足这个需求：</p><div><pre class=\"crayon-plain-tag\">virtual void PutChess(int x,int y,char chess)=0; 
virtual char GetChess(int x,int y)=0 ;
       有了这个思路，我想这样设计这个测试用例：
TEST_F(TicTacToeTestFixture,PutandGetChess)
{
char xChess='X'; 
char yChess='Y';
IGameBoard *gameBoard=new SimpleGameBoard(\"simpleBoard\"); 
gameBoard-&gt;PutChess(0,0,xChess); 
gameBoard-&gt;PutChess(2,2,yChess); 
EXPECT_EQ(xChess,gameBoard-&gt;GetChess(0,0));
EXPECT_EQ(yChess,gameBoard-&gt;GetChess(2,2)); 
delete gameBoard; 
}</pre></div><p>试着编译这个测试工程，失败，原因是没有实现这两个函数，接下来我回到 TicTacToeLib 工程去声明和定义这两个函数。为了实现这两个功能，在 SimpleGameBoard 定义 private 数据：<code>vector<code>char</code><code>&gt; data_;用于 保存棋子和位置信息，为了简单，棋子用 Char 类型来表示，位置信息和 data_向量的下标对应,如棋盘位置（2，2）对应的是 data_[2*3+2]这个位置，数据是安行存放的。两个函数的实现是：</code></code></p><div><pre class=\"crayon-plain-tag\">void SimpleGameBoard::PutChess( int x,int y,char chess )
{
	assert(x&lt;xMaxDim&amp;&amp;y&lt;yMaxDim); 
int xy=x*3+y; 
if(data_.size()==0)initboard_(); 
	data_[xy]=chess; 
}

char SimpleGameBoard::GetChess( int x,int y )
{
	assert(x&lt;xMaxDim&amp;&amp;y&lt;yMaxDim); 
	assert(data_.size()==yMaxDim*xMaxDim); 
return data_[x*3+y];
}</pre></div><p>initboard_()是个 protected 函数，用于初始化 data_。 现在可以重现编译和运行测试工程，结果如下：</p><h5 id=\"6.0.4.图 5 .测试用例输出 |outline\" style=\"text-align: center\">图 5 .测试用例输出</h5><p><img class=\"aligncenter\" src=\"http://www.ibm.com/developerworks/cn/linux/1401_xiajd_ctdd/image011.jpg\" alt=\"图 5 .测试用例输出\" /></p><p>有了两个测试用例的实现，并且运行是绿色，继续下个需求。</p><p><strong>3.我要能验证和判断是不是三个棋子在同一条线上，以判断是不是有人胜出</strong></p><p>这个需求用于判断三个棋子是否已经在一条线上，如果是的话，那么持对应棋子的棋手就会胜出，这个测试用例可以这样设计：</p><div><pre class=\"crayon-plain-tag\">TEST_F(TicTacToeTestFixture,JugeThreeInLine)
{
IGameBoard *gameBoard=new SimpleGameBoard(\"simpleBoard\"); 
IGameBoard *gameBoard2=new SimpleGameBoard(\"simpleboard2\"); 
char xChess='x',yChess='o'; 
gameBoard-&gt;PutChess(0,0,xChess); gameBoard2-&gt;PutChess(0,1,yChess); 
gameBoard-&gt;PutChess(1,1,xChess); gameBoard2-&gt;PutChess(1,1,yChess); 
gameBoard-&gt;PutChess(2,2,xChess); gameBoard2-&gt;PutChess(2,1,yChess); 
EXPECT_TRUE(gameBoard-&gt;CheckWinOut(xChess));
EXPECT_TRUE(gameBoard2-&gt;CheckWinOut(yChess)); 
EXPECT_FALSE(gameBoard-&gt;CheckWinOut(yChess));
EXPECT_FALSE(gameBoard2-)CheckWinOut(xChess)); 
delete gameBoard; 
delete gameBoard2; 
}</pre></div><p>设计是这样的，为简单，我把判断棋子胜出的函数 CheckWinOut 定义到接口 IGameBoard 中，并在 SimpleGameBoard 中实现它，实现如下：</p><div><pre class=\"crayon-plain-tag\">bool SimpleGameBoard::CheckWinOut(char chess)
{
return IsThreeInLine_(chess); 
}</pre></div><p>IsThreeInLine_是受保护的成员函数，它会扫描棋盘的行，列和对角线看是否指定的棋子在一条线上，如果有三个棋子在一条线上，则说明有人胜出。编译运行测试，绿色通过。 继续下一个需求。</p><p><strong>4.我不能放棋子到已被占用的棋位置上。</strong></p><p>这个需求是个验证性需求，要保证棋子不能重叠和覆盖已在棋盘上的棋子，实现这个需求我只要重构现有的代码加上避免棋子重叠的逻辑。只要避免在 PutChess 时候，检查是否指定的位置是否已有棋子，如果是简单的抛出异常即可。有了这些基本的思路，我开始设计测试用例。</p><div><pre class=\"crayon-plain-tag\">TEST_F(TicTacToeTestFixture,BizException_Occupied){

    IGameBoard *gameBoard=new SimpleGameBoard(\"simple board\"); 
char xChar='X',yChar='0'; 
EXPECT_NO_THROW(gameBoard-&gt;PutChess(0,0,xChar)); 
<strong>EXPECT_THROW(gameBoard-&gt;PutChess(0,0,xChar),ChessOverlapException); </strong>
EXPECT_NO_THROW(gameBoard-&gt;PutChess(2,2,yChar)); 
<strong>EXPECT_THROW(gameBoard-&gt;PutChess(2,2,yChar),ChessOverlapException); </strong>
delete gameBoard; 
}</pre></div><p>ChessOverlapException 是我将要实现的一个异常类，这个是在棋手试图放棋子到已有棋子的棋盘位置上时要抛出的异常。测试用例中，我在（0，0）和（2，2）这两个位置上放同样的棋子以触发这个异常。为了编译通过，我开始实现 ChessOverlapException。 ChessOverlapException 继承自 std::exception 我重载了 what 函数返回相应的异常信息。 把这个异常类的定义引入的测试工程中，编译通过运行测试，但却得到了红色 Red，案例失败：</p><p style=\"text-align: center\">图 6.测试用例输出</p><p><img class=\"aligncenter\" src=\"http://www.ibm.com/developerworks/cn/linux/1401_xiajd_ctdd/image013.jpg\" alt=\"图 6.测试用例输出\" /></p><p>原因是我还没有重构 PutChess 函数以加入避免棋子被被覆盖的代码。现在来重构 PutChess 函数：</p><div><pre class=\"crayon-plain-tag\">void SimpleGameBoard::PutChess( int x,int y,char chess )
{
assert(x&lt;xMaxDim&amp;&amp;y&lt;yMaxDim); 
int xy=x*3+y; 
if(data_.size()==0){
		initboard_(); 
		data_[xy]=chess;
return ; 
	}
if(data_[xy]!='+') {
throw ChessOverlapException(\"chess overlap!\");
	}
else data_[xy]=chess;
}</pre></div><p>重新编译测试工程并运行得到绿色 Green 通过。继续下一个需求。</p><p><strong>5.我要能判断是不是棋盘已满并无赢家。 </strong></p><p>这个需求用于判断是否是和棋的情况，棋盘满了但并无赢家，这是可能出现的一种情况，这个实现设计可以有两种方式. 一是重构 CheckWinOut 函数，使返回值携带更多的信息，比如和棋，有人胜出等。二是定义一个独立的函数去判断棋盘的当前状态。第一种方案较合理，开始设计这种方案的测试用例：</p><div><pre class=\"crayon-plain-tag\">EST_F(TicTacToeTestFixture,IsEndedInADraw)
{
char xChess='X',yChess='O'; 
IGameBoard *gameBoard=new SimpleGameBoard(\"simpleBoard\");
gameBoard-&gt;PutChess(0,0,yChess);gameBoard-&gt;PutChess(0,1,xChess);gameBoard-&gt;PutChess(0,2,yChess);
gameBoard-&gt;PutChess(1,0,xChess);gameBoard-&gt;PutChess(1,1,yChess);gameBoard-&gt;PutChess(1,2,yChess);
gameBoard-&gt;PutChess(2,0,xChess);gameBoard-&gt;PutChess(2,1,yChess);gameBoard-&gt;PutChess(2,2,xChess);

<strong>GameBoardStatus status=gameBoard-&gt;CheckWinOut(yChess);
EXPECT_TRUE(status==GAMEDRAW); </strong><strong>GameBoardStatus status2=gameBoard-&gt;CheckWinOut(xChess); EXPECT_TRUE(status2==GAMEDRAW);</strong> 
delete gameBoard; 
}</pre></div><p>以上的测试用例可以看出， 我设计了和棋的棋局，并想重构 CheckWinout 函数，使其返回枚举类型 GameBoardStatus 以表示棋局的状态，其中 GAMEDRAW 表示和棋状态。为了使工程能编译通过，开始定义这个枚举类型并重构 CheckWinOut 函数。实现所有设计，经过几次的 Red 失败，最终 形成代码：</p><div><pre class=\"crayon-plain-tag\">GameBoardStatus SimpleGameBoard::CheckWinOut(char chess)
{

if(IsThreeInLine_(chess)){
return GAMEMWINOUT;
	}
else if(IsEndedInADraw_()){
return GAMEDRAW; 
	}
else{
return GAMERUNNING; 
	}
}</pre></div><p>其中那个 IsEndedInADraw_是个受保护的成员函数，用于检测是否和棋。 在调通这个测试用例的过程中，我也更新了测试<code>JugeThreeInLine。因为重构 ChecWinOut 改变了返回类型。</code></p><p><strong>6.我需要能复位棋盘，以便于重新开始下棋。</strong></p><p><strong>7.我需要用对记住玩家，以便于我能特例化 Player。</strong></p><p>6 和 7 需求的测试案例和实现比较比较简单，不在赘述，7 的要求是要建立玩家 Player，这个主要是说要能实例化玩家。可以看附带的工程。</p><p><strong>8.我需要能保存和加载棋局能力，以便于我能下次回来继续之前的游戏</strong>。</p><p>这个需求是一个合理的需求，玩家可以保存和继续回来玩游戏，他的测试用例可以这样设计：</p><div><pre class=\"crayon-plain-tag\">TEST_F(TicTacToeTestFixture,SaveTheBoard)
{
IGameBoard * gameBoard=new SimpleGameBoard(\"simpleBoard\"); 
char xChess='x',yChess='o'; 
gameBoard-&gt;PutChess(0,0,xChess); 
gameBoard-&gt;PutChess(1,2,yChess); 
IGameIO *gameIO=new SimpleGameIO(); 
EXPECT_NO_THROW(gameIO-&gt;save(gameBoard,\"somewhere\")); 
delete gameBoard; 
delete gameIO;
}
TEST_F(TicTacToeTestFixture,LoadTheBoard)
{
IGameBoard * gameBoard=new SimpleGameBoard(\"simpleBoard\"); 
char xChess='x',yChess='o'; 
gameBoard-&gt;PutChess(0,0,xChess); 
gameBoard-&gt;PutChess(1,2,yChess); 
IGameIO *gameIO=new SimpleGameIO(); 
EXPECT_NO_THROW(gameIO-&gt;save(gameBoard,\"somewhere\")); 
IGameBoard *game=gameIO-&gt;load(\"somewhere\"); 
EXPECT_EQ(xChess,game-&gt;GetChess(0,0)); 
EXPECT_EQ(yChess,game-&gt;GetChess(1,2)); 
EXPECT_EQ('+',game-&gt;GetChess(2,2));
delete game;</pre></div><div><pre class=\"crayon-plain-tag\">delete gameBoard; 
delete gameIO; 
}</pre></div><p>这里用两个测试用例来覆盖这个需求，一个是保存棋盘，一个是加载棋盘。由这个测试用例可以看到，要通过这个测试，必须要定义 IGameIO 接口和 SimpeGameIO 类。 保存棋盘的媒介是文件。按照 TDD 的开发要求，测试单元本身最好是脱离对第三方系统的依赖，但测试中必然会用到第三方系统，解决这些问题的方法有几种。创建第三方系统的 Stub 类或是 FakedObject，第三种选择是 Mock 框架，如 Gmock。 Gmock 的设计理念是基于接口的，只要是第三方访问提供的是接口，这些访问就可以可以被用 Gmock 模拟。可以看参考文献获取更多的信息。 限于篇幅不再赘述。一下是完成所有测试用例的测试结果。</p><h5 id=\"6.0.6.图 7.测试用例输出 |outline\" style=\"text-align: center\">图 7.测试用例输出</h5><p><img class=\"aligncenter\" src=\"http://www.ibm.com/developerworks/cn/linux/1401_xiajd_ctdd/image015.jpg\" alt=\"图 7.测试用例输出\" /></p><p>或许你会注意到有些测试用例的设计，只是以点盖面，如果想要更多的验证点可以借助于 Gtest 提供的参数化测试设计测试数据，然后去测试实现的类和逻辑。 还有死亡测试的用例，可以在参考资源中的 Gtest 资源中查看。</p><h1 id=\"7.结论 |outline\">结论</h1><p>C++中实现测试驱动开发 TDD 之前是很困难的事。 但有了类似于 xUnit 的 Gtest 和 Gmock 测试框架，在 C++工程中实现 TDD 也变得很享受。测试驱动开发是一个很好的工具，它可以帮助开发者实现有机开发，在需求的实现过程中快速得到反馈，另一个好处是测试驱动开发可以使开发人员更加重视需求和测试，以测试用例为中心，这样势必会产生更好代码。从软件工程的角度来说，测试驱动开发的实践应用会大幅度的提高软件开发的质量，用代码级别的测试用例来覆盖和保障程序的健壮性更能保障整个软件产品的开发质量。</p><p>测试驱动开发的座右铭模式：红色-绿色-重构，然后重复这个直到开发完成为止，是一个自我确认和有保护代码重构的过程。采用测试驱动开发的模式的软件产品，产生的单元测试代码，从代码级别测试覆盖了软件的需求，使以后的代码重构更安全可靠。</p></div><div class=\"wp_rp_wrap  wp_rp_plain\" ><div class=\"wp_rp_content\"><h3 class=\"related_post_title\">相关文章</h3><ul class=\"related_post wp_rp\" style=\"visibility: visible\"><li ><a href=\"http://blog.jobbole.com/104042/\" class=\"wp_rp_title\">如何在 Linux 下检测内存泄漏</a></li><li ><a href=\"http://blog.jobbole.com/103640/\" class=\"wp_rp_title\">Linux 平台相关代码的 C++ 解决方案</a></li><li ><a href=\"http://blog.jobbole.com/94497/\" class=\"wp_rp_title\">Linux 动态库相关知识整理</a></li><li ><a href=\"http://blog.jobbole.com/103596/\" class=\"wp_rp_title\">Linux 下 C++ 异常处理技巧</a></li><li ><a href=\"http://blog.jobbole.com/88279/\" class=\"wp_rp_title\">Linux 内核里的“智能指针”</a></li><li ><a href=\"http://blog.jobbole.com/86392/\" class=\"wp_rp_title\">C++和双重检查锁定模式(DCLP)的风险</a></li><li ><a href=\"http://blog.jobbole.com/104080/\" class=\"wp_rp_title\">编写高质量代码</a></li><li ><a href=\"http://blog.jobbole.com/92792/\" class=\"wp_rp_title\">Linux Shell 创建序列数组</a></li><li ><a href=\"http://blog.jobbole.com/103662/\" class=\"wp_rp_title\">C++11 中的右值引用与转移语义</a></li><li ><a href=\"http://blog.jobbole.com/85186/\" class=\"wp_rp_title\">Linux 上的最佳 C/C++ IDE</a></li></ul></div></div><p><a href=\"http://blog.jobbole.com/104032/\">面向 C++ 的测试驱动开发</a>，首发于<a href=\"http://blog.jobbole.com\">文章 - 伯乐在线</a>。</p>") (wfw:commentRss nil "http://blog.jobbole.com/104032/feed/") (slash:comments nil "0"))) ("Github上的有趣事实：\"BigQuery驱动下的数据世界\"" "<p>近日看到了Google的BigQuery技术，用类似SQL的语言来做一些数据的分析。而Github也加入了进来。闲来无事，就去体验了一把。https://cloud.google.com/bigquery/public-data/github 这是相关文章的地址。</p><h3 id=\"bigquery\">BigQuery语法</h3><p></p><pre class=\"crayon-plain-tag\">SELECT
package,
COUNT(*) count
FROM (
SELECT
REGEXP_EXTRACT(line, r' ([a-z0-9\\._]*)\\.') package,
id
FROM (
SELECT
SPLIT(content, '\\n') line,
id
FROM
[bigquery-public-data:github_repos.sample_contents]
WHERE
content CONTAINS 'import'
AND sample_path LIKE '%.py'
HAVING
LEFT(line, 6)='import' )
GROUP BY
package,
id )
GROUP BY
1
ORDER BY
count DESC
LIMIT
40;</pre><p>整体的语法都和SQL非常接近，鉴于点进来的人很多都是冲着“有趣”这两个字来的，就不过多介绍代码了。这段代码的作用是找到github仓库中，使用Python语言的仓库中，前10个被引用的库。</p><p>BigQuery的界面也非常有Google风…… <img src=\"https://ooo.0o0.ooo/2016/07/01/577695245abdb.png\" alt=\"github_20160702000047.png\" /></p><h3 id=\"most-popular-python-packages\">Most Popular Python Packages</h3><p>这是通过刚刚的分析做出来的前几名的Python库的列表。 <img src=\"https://ooo.0o0.ooo/2016/07/01/5776947692ff9.png\" alt=\"a5037d6edd3b9ca5 (2).png\" /></p><h3 id=\"most-popular-java-packages\">Most Popular Java Packages</h3><p><img src=\"https://ooo.0o0.ooo/2016/07/01/577698eb17973.png\" alt=\"a5037d6edd3b9ca5 (3).png\" /></p><h3 id=\"section\">一些其它有趣的事情</h3><p>例如大家都在用什么协议来发布作品，有接近150万个仓库使用MIT协议来发布。 <img src=\"https://ooo.0o0.ooo/2016/07/01/57769f3c9b10c.png\" alt=\"a5037d6edd3b9ca5 (4).png\" /></p><p>关注tensorflow的人都在关注什么？ <img src=\"https://ooo.0o0.ooo/2016/07/01/5776a076be634.png\" alt=\"a5037d6edd3b9ca5 (5).png\" /></p><p>最受欢迎的语言 <img src=\"https://ooo.0o0.ooo/2016/07/01/5776a104a17d5.png\" alt=\"1-_uxwTTOd1oRXjmloZ5Qi0g.png\" /></p><p>提交次数和时间的关系 <img src=\"https://ooo.0o0.ooo/2016/07/01/5776a1049aeb3.png\" alt=\"1-Ud8ZAz1xoVWK9DfiX6_hBg.png\" /></p><div class=\"wp_rp_wrap  wp_rp_plain\" ><div class=\"wp_rp_content\"><h3 class=\"related_post_title\">相关文章</h3><ul class=\"related_post wp_rp\" style=\"visibility: visible\"><li ><a href=\"http://blog.jobbole.com/86585/\" class=\"wp_rp_title\">微软推出 Visual Studio 的 GitHub 扩展</a></li><li ><a href=\"http://blog.jobbole.com/97681/\" class=\"wp_rp_title\">2015年 GitHub 十大开源项目</a></li><li ><a href=\"http://blog.jobbole.com/34195/\" class=\"wp_rp_title\">ThoughtBot的代码审查指导原则</a></li><li ><a href=\"http://blog.jobbole.com/38213/\" class=\"wp_rp_title\">Cookies 的跨域脚本攻击 – Github 迁移域名的安全详解</a></li><li ><a href=\"http://blog.jobbole.com/17010/\" class=\"wp_rp_title\">版本控制入门简介</a></li><li ><a href=\"http://blog.jobbole.com/14489/\" class=\"wp_rp_title\">版本控制工具历史的10个里程碑</a></li><li ><a href=\"http://blog.jobbole.com/61115/\" class=\"wp_rp_title\">Egor Homakov：我是如何再次黑掉GitHub的</a></li><li ><a href=\"http://blog.jobbole.com/60505/\" class=\"wp_rp_title\">如何创建你自己的Git服务器</a></li><li ><a href=\"http://blog.jobbole.com/87700/\" class=\"wp_rp_title\">如何在 Git 里撤销(几乎)任何操作</a></li><li ><a href=\"http://blog.jobbole.com/89418/\" class=\"wp_rp_title\">GitHub vs. Bitbucket 不只是功能不同</a></li></ul></div></div><p><a href=\"http://blog.jobbole.com/100327/\">Github上的有趣事实：\"BigQuery驱动下的数据世界\"</a>，首发于<a href=\"http://blog.jobbole.com\">文章 - 伯乐在线</a>。</p>" "http://blog.jobbole.com/100327/" (22430 43179) old 17 nil nil ((title nil "Github上的有趣事实：\"BigQuery驱动下的数据世界\"") (link nil "http://blog.jobbole.com/100327/") (comments nil "http://blog.jobbole.com/100327/#respond") (pubDate nil "Mon, 01 Aug 2016 01:40:59 +0000") (dc:creator nil "伯小乐") (category nil "IT技术") (category nil "BigQuery") (category nil "Github") (guid ((isPermaLink . "false")) "http://blog.jobbole.com/?p=100327") (description nil "<p>近日看到了Google的BigQuery技术，用类似SQL的语言来做一些数据的分析。而Github也加入了进来。闲来无事，就去体验了一把。</p><p><a href=\"http://blog.jobbole.com/100327/\">Github上的有趣事实：\"BigQuery驱动下的数据世界\"</a>，首发于<a href=\"http://blog.jobbole.com\">文章 - 伯乐在线</a>。</p>") (content:encoded nil "<p>近日看到了Google的BigQuery技术，用类似SQL的语言来做一些数据的分析。而Github也加入了进来。闲来无事，就去体验了一把。https://cloud.google.com/bigquery/public-data/github 这是相关文章的地址。</p><h3 id=\"bigquery\">BigQuery语法</h3><p></p><pre class=\"crayon-plain-tag\">SELECT
  package,
  COUNT(*) count
FROM (
  SELECT
    REGEXP_EXTRACT(line, r' ([a-z0-9\\._]*)\\.') package,
    id
  FROM (
    SELECT
      SPLIT(content, '\\n') line,
      id
    FROM
      [bigquery-public-data:github_repos.sample_contents]
    WHERE
      content CONTAINS 'import'
      AND sample_path LIKE '%.py'
    HAVING
      LEFT(line, 6)='import' )
  GROUP BY
    package,
    id )
GROUP BY
  1
ORDER BY
  count DESC
LIMIT
  40;</pre><p>整体的语法都和SQL非常接近，鉴于点进来的人很多都是冲着“有趣”这两个字来的，就不过多介绍代码了。这段代码的作用是找到github仓库中，使用Python语言的仓库中，前10个被引用的库。</p><p>BigQuery的界面也非常有Google风…… <img src=\"https://ooo.0o0.ooo/2016/07/01/577695245abdb.png\" alt=\"github_20160702000047.png\" /></p><h3 id=\"most-popular-python-packages\">Most Popular Python Packages</h3><p>这是通过刚刚的分析做出来的前几名的Python库的列表。 <img src=\"https://ooo.0o0.ooo/2016/07/01/5776947692ff9.png\" alt=\"a5037d6edd3b9ca5 (2).png\" /></p><h3 id=\"most-popular-java-packages\">Most Popular Java Packages</h3><p><img src=\"https://ooo.0o0.ooo/2016/07/01/577698eb17973.png\" alt=\"a5037d6edd3b9ca5 (3).png\" /></p><h3 id=\"section\">一些其它有趣的事情</h3><p>例如大家都在用什么协议来发布作品，有接近150万个仓库使用MIT协议来发布。 <img src=\"https://ooo.0o0.ooo/2016/07/01/57769f3c9b10c.png\" alt=\"a5037d6edd3b9ca5 (4).png\" /></p><p>关注tensorflow的人都在关注什么？ <img src=\"https://ooo.0o0.ooo/2016/07/01/5776a076be634.png\" alt=\"a5037d6edd3b9ca5 (5).png\" /></p><p>最受欢迎的语言 <img src=\"https://ooo.0o0.ooo/2016/07/01/5776a104a17d5.png\" alt=\"1-_uxwTTOd1oRXjmloZ5Qi0g.png\" /></p><p>提交次数和时间的关系 <img src=\"https://ooo.0o0.ooo/2016/07/01/5776a1049aeb3.png\" alt=\"1-Ud8ZAz1xoVWK9DfiX6_hBg.png\" /></p><div class=\"wp_rp_wrap  wp_rp_plain\" ><div class=\"wp_rp_content\"><h3 class=\"related_post_title\">相关文章</h3><ul class=\"related_post wp_rp\" style=\"visibility: visible\"><li ><a href=\"http://blog.jobbole.com/86585/\" class=\"wp_rp_title\">微软推出 Visual Studio 的 GitHub 扩展</a></li><li ><a href=\"http://blog.jobbole.com/97681/\" class=\"wp_rp_title\">2015年 GitHub 十大开源项目</a></li><li ><a href=\"http://blog.jobbole.com/34195/\" class=\"wp_rp_title\">ThoughtBot的代码审查指导原则</a></li><li ><a href=\"http://blog.jobbole.com/38213/\" class=\"wp_rp_title\">Cookies 的跨域脚本攻击 &#8211; Github 迁移域名的安全详解</a></li><li ><a href=\"http://blog.jobbole.com/17010/\" class=\"wp_rp_title\">版本控制入门简介</a></li><li ><a href=\"http://blog.jobbole.com/14489/\" class=\"wp_rp_title\">版本控制工具历史的10个里程碑</a></li><li ><a href=\"http://blog.jobbole.com/61115/\" class=\"wp_rp_title\">Egor Homakov：我是如何再次黑掉GitHub的</a></li><li ><a href=\"http://blog.jobbole.com/60505/\" class=\"wp_rp_title\">如何创建你自己的Git服务器</a></li><li ><a href=\"http://blog.jobbole.com/87700/\" class=\"wp_rp_title\">如何在 Git 里撤销(几乎)任何操作</a></li><li ><a href=\"http://blog.jobbole.com/89418/\" class=\"wp_rp_title\">GitHub vs. Bitbucket 不只是功能不同</a></li></ul></div></div><p><a href=\"http://blog.jobbole.com/100327/\">Github上的有趣事实：\"BigQuery驱动下的数据世界\"</a>，首发于<a href=\"http://blog.jobbole.com\">文章 - 伯乐在线</a>。</p>") (wfw:commentRss nil "http://blog.jobbole.com/100327/feed/") (slash:comments nil "0"))) ("Expert 诊断优化（1）：你的 CPU 高么？" "<p>现在很多用户被数据库的慢的问题所困扰，又苦于花钱请一个专业的DBA成本太高。软件维护人员对数据库的了解又不是那么深入，所以导致问题迟迟不能解决，或只能暂时解决不能得到根治。开发人员解决数据问题基本又是搜遍百度各种方法尝试个遍，可能错过诊断问题的最佳时机，又可能尝试一堆方法最后无奈放弃。</p><p>怎么样让琐事缠身的程序维护人员，用最快的方式解决数据库出现的问题？怎么让我们程序员的痛苦降低到最小…每天喝喝茶水，看看新闻平安度过一天呢？本系列重要通过 <a href=\"http://www.grqsh.com/product_Expert.html\" target=\"_blank\">Expert for sqlserver </a>工具讲解下数据库遇到的各种问题的表象及导致这样问题的根本原因，让定位问题更准确，解决问题思路更清晰！！</p><p>数据库的性能好坏，对于最终用户来说表现为点击的操作是否能够快速响应，那么反应到数据库上就是语句执行时间是否够短！</p><p>对用运维人员数据库性能的表现，简单可能看成CPU 、内存、磁盘三巨头指标是否正常，那么今天我们就从CPU 下手，看看CPU能够看出哪些问题！</p><p><strong>废话不多说，直接开整—</strong></p><p>主要用到的性能计数器（不知道什么是性能计数器的，请自行百度）</p><p>就用两个~</p><ol><li>%Process Time　全实例　 （主要用于查看当前服务器的CPU 情况）</li><li>%Process Time　sqlservr （主要用于查看数据库使用的CPU情况 ）</li></ol><p><strong><strong>排除其他应用影响CPU</strong>　　　　　　　　　　　　　　　　　　　　　　　</strong></p><p><img src=\"http://jbcdn2.b0.upaiyun.com/2016/08/da810078db6fa6472766a284528c48d3.jpg\" alt=\" \" /></p><p>综合这两个计数器 在同一时间点可以诊断出CPU 是否是被服务器其他的应用所消耗的，如图中17:10 左右的  “%Process Time　全实例（红线）” 突然升高，而SQL 服务的（绿线）并无明显升高，这也就说明，在这个时间段的CPU 压力不是有数据库导致的！</p><p>这个红线的明显升高时，因为我在数据库所在的服务器上做了一次文件压缩！类似文件压缩这种操作会使用大量CPU，对数据库性能造成冲击！</p><p><strong>　CPU 问题分析　　　　　　　　　　　　　　　　　　　　　　　　</strong></p><p>CPU很高或者达到100%一定是你业务压力很大？CPU 不能满足你的需求么？在下结论前请仔细分析，一个草率的定论可能换来，老板一个安慰“世界那么大你该出去走走了！”</p><p>下面我们用几个典型的场景，分析下问题，并给出最佳实践~</p><p>高峰时段CPU 持续很高</p><p><img src=\"http://jbcdn2.b0.upaiyun.com/2016/08/9e65af5f98debf06ae62d746e93e5a21.png\" alt=\" \" /></p><p>图中是服务器几天的CPU情况</p><p>很多人看到这张图，是不是看到了自己的服务器？是否有一种亲切感呢~下面我们来分析下这种表象可能存在的问题！</p><p>首先明确一点90%的问题可能集中在10%的场景，这种CPU 持续持续很高的情况请注意下面两点：</p><ol><li>你的数据库并行度是否调整？</li><li>你的数据库是否缺少索引，导致频繁的查询消耗很高的CPU资源？</li></ol><p>最大并行度是什么？简单的可以理解为执行一条语句最多可以使用多少个CPU。看起来当然是使用的越多越好啦，使用的越多语句肯定越快呀！ 这个答案是大写的 “<strong>NO</strong>”，使用过多的CPU会导致线程协同工作产生的时间较长，直接导致语句很慢，而且消耗的CPU时间很多，导致CPU使用高，进而成为瓶颈！</p><p>看一个数据语句持续时间也就是执行时间，但是看看CPU的时间，这就是没有设置并行度，一个并行计划会产生大量的CPU消耗，另外会让语句执行的更慢！</p><p><img src=\"http://jbcdn2.b0.upaiyun.com/2016/08/4c9bea5e728bbb427a0bb8fc2dc97691.png\" alt=\" \" /></p><p>那么是不是使用的越少越好呢？任何事情没有绝对的，视情况而定，如果系统有比较大数据量的操作需求，并行使用多个CPU会有很大的提升。</p><p>一般建议系统如果超过32个CPU 那么设置成8或者4，如果系统中都是特别短小且频繁的语句建议设置成1（取消语句并行，要慎重真的符合你的场景才好）</p><p>并行开销的阀值，主要控制SQL优化器何时选用并行计划，建议默认值，此值设置的越小优化器越容易选择并行计划。</p><p>并行度的设置是针对实例级别的设置（2016中可以对单独数据库设置）</p><p>怎么设置并行度和阀值，请看下图: 系统默认的并行度 为0，阀值默认为5</p><p><img src=\"http://jbcdn2.b0.upaiyun.com/2016/08/9525a32d8e70d5a9d8131f02f9345531.png\" alt=\" \" /></p><p>并行度的调整可谓谁用谁知道啊，下面我们说说系统老大难的问题–语句导致CPU高</p><p>语句导致CPU高也是很常见的问题之一，那么语句怎么调优降低CPU 消耗呢？ 这里只做一些简单的说明，具体的语句调优、参数化减少语句编译，请看后面的系列文章。</p><p>语句调优的方式很多种，这里介绍和CPU相关最为常用：</p><ol><li>添加索引降低语句开销，执行需要的资源消耗少了消耗的CPU 自然相对就少了。</li><li>降低语句复杂度，让SQL Server执行高效（同样也是降低资源消耗的方法）。</li><li>分析语句是否可以采用串行计划。</li><li>前端程序尽量参数化减少语句的编译消耗。</li></ol><p>CPU 规律波动</p><p>拿到CPU的监控数据不要盲目下结论，数据往往是最能反映问题，给你提供思路的！</p><p><img src=\"http://jbcdn2.b0.upaiyun.com/2016/08/7009f4196ece05242ce2e9aa0f64b2ec.png\" alt=\" \" /></p><p>如果你是系统维护人员，看到类似这样的CPU数据指标，如果你还不能有一些思路，请你好好熟悉下你亲爱的系统。</p><p>这张图很清晰地反映出系统每半小时一次的CPU升高，那么别忙着去找对应时间点的语句，我们最少要好好想一下，系统中有什么操作半小时执行一直？SQL JOB？计划任务？前台定时处理？等等等</p><p>这个规律的定时处理是否有异常？是否最近有什么改动？执行的结果是不是和你想的一样？</p><p>也许问题就这么清晰的定位了……</p><p>CPU 突然飙高</p><p><img src=\"http://jbcdn2.b0.upaiyun.com/2016/08/732f1e453228c9ce2ddb4ad3bcc238c6.png\" alt=\" \" /></p><p>图中 9点CPU由平均20几飙升到100%</p><p>CPU突然飙高可能是偶然的现象，也许你可以认为没有关系，但当你判断为偶然之前，你是否做过下面的分析：</p><ol><li>是否分析过系统日志，CPU飙高时间点是否有异常？</li><li>是否检查服务器上有什么特殊应用？</li><li>是否检查了数据库状态？</li><li>是否询问过相关业务人员？</li><li>是否马上开启监控为下一次突发情况的到来做好准备？</li></ol><p>如果没有你的判断真是毫无根据…也错过了一次发现问题，学习知识的机会！</p><p>排除上述异常，最有可能的原因就是数据库中，在那一刻有一个或多个语句运行异常，或非常不优化。如果这情况真的因为语句问题，而且只出现一次，那么这可能不是问题，我们尽量找到当时的语句，查看问题。找到当时的语句可以通过系统视图sys.dm_exec_query_stats 查看CPU消耗以及运行时间，或者由自己的监控工具得到。</p><p>找到对应的时间点看看到底是什么语句在运行~</p><p><img src=\"http://jbcdn2.b0.upaiyun.com/2016/08/62593bc80bf63bb476b975146dae912c.png\" alt=\" \" /></p><p>对这条语句进行分析到底是为什么！</p><p>CPU 真高！</p><p>经过各种分析优化，如果依然CPU压力明显，真心是硬件不能支撑业务了，那么我们就要选择更高大上的方式了，比如修改程序设计垂直/水平拆分，添加硬件，读写分离分担压力，组建集群负载均衡等等手段……</p><p>—————————————————————————————————–</p><p>总结：对于CPU压力的解决，大部分的用户可以通过调整并行度和系统语句的优化来解决。</p><p>另外对系统的监控和分析在诊断问题及解决问题中起到至关重要的作用。</p><p>在下结论前一定要经过仔细的分析研究，一个想当然的决定可能造成严重的影响。</p><p>你的系统真的需要加硬件，或高大上的方案么？</p><p>———————–给出一些CPU相关的文章连接—————————————————–</p><ul><li>桦仔的  <a href=\"http://www.cnblogs.com/lyhabc/archive/2013/06/12/3133273.html\" target=\"_blank\">SQLSERVER排查CPU占用高的情况</a></li><li>高大侠的  <a id=\"cb_post_title_url\" href=\"http://www.cnblogs.com/shanksgao/p/5530107.html\">深入解析SQL Server并行执行原理及实践(下)</a></li><li>careyson的 <a id=\"cb_post_title_url\" href=\"http://www.cnblogs.com/CareySon/archive/2013/05/04/PlanCacheInSQLServer.html\">谈一谈SQL Server中的执行计划缓存（上）</a></li><li><a href=\"http://blog.csdn.net/zhaowenzhong/article/details/7211829\">常用 监控SQLSERVER性能计数器</a></li></ul><div class=\"wp_rp_wrap  wp_rp_plain\" ><div class=\"wp_rp_content\"><h3 class=\"related_post_title\">相关文章</h3><ul class=\"related_post wp_rp\" style=\"visibility: visible\"><li ><a href=\"http://blog.jobbole.com/91002/\" class=\"wp_rp_title\">SQL SERVER中什么情况会导致索引查找变成索引扫描</a></li><li ><a href=\"http://blog.jobbole.com/95913/\" class=\"wp_rp_title\">RAID的概念和RAID对于SQL性能的影响</a></li><li ><a href=\"http://blog.jobbole.com/95875/\" class=\"wp_rp_title\">如何查看某个查询用了多少TempDB空间</a></li><li ><a href=\"http://blog.jobbole.com/98633/\" class=\"wp_rp_title\">StackOverflow 这么大，它的架构是怎么样的？</a></li><li ><a href=\"http://blog.jobbole.com/100081/\" class=\"wp_rp_title\">MySQL 读写分离介绍及搭建</a></li><li ><a href=\"http://blog.jobbole.com/94173/\" class=\"wp_rp_title\">如何找出你性能最差的SQL Server查询</a></li><li ><a href=\"http://blog.jobbole.com/103474/\" class=\"wp_rp_title\">SQL SERVER全面优化：写出好语句是习惯</a></li><li ><a href=\"http://blog.jobbole.com/86774/\" class=\"wp_rp_title\">SQL Server基础：游标</a></li><li ><a href=\"http://blog.jobbole.com/95897/\" class=\"wp_rp_title\">谈一谈SQL Server中的执行计划缓存（上）</a></li><li ><a href=\"http://blog.jobbole.com/95907/\" class=\"wp_rp_title\">浅谈SQL Server中统计对于查询的影响</a></li></ul></div></div><p><a href=\"http://blog.jobbole.com/104023/\">Expert 诊断优化（1）：你的 CPU 高么？</a>，首发于<a href=\"http://blog.jobbole.com\">文章 - 伯乐在线</a>。</p>" "http://blog.jobbole.com/104023/" (22430 42365) old 18 nil nil ((title nil "Expert 诊断优化（1）：你的 CPU 高么？") (link nil "http://blog.jobbole.com/104023/") (comments nil "http://blog.jobbole.com/104023/#respond") (pubDate nil "Mon, 01 Aug 2016 01:27:25 +0000") (dc:creator nil "伯小乐") (category nil "IT技术") (category nil "SQL Server") (category nil "数据库") (guid ((isPermaLink . "false")) "http://blog.jobbole.com/?p=104023") (description nil "<p>现在很多用户被数据库的慢的问题所困扰，又苦于花钱请一个专业的DBA成本太高。软件维护人员对数据库的了解又不是那么深入，所以导致问题迟迟不能解决，或只能暂时解决不能得到根治。开发人员解决数据问题基本又是搜遍百度各种方法尝试个遍，可能错过诊断问题的最佳时机，又可能尝试一堆方法最后无奈放弃。</p><p><a href=\"http://blog.jobbole.com/104023/\">Expert 诊断优化（1）：你的 CPU 高么？</a>，首发于<a href=\"http://blog.jobbole.com\">文章 - 伯乐在线</a>。</p>") (content:encoded nil "<p>现在很多用户被数据库的慢的问题所困扰，又苦于花钱请一个专业的DBA成本太高。软件维护人员对数据库的了解又不是那么深入，所以导致问题迟迟不能解决，或只能暂时解决不能得到根治。开发人员解决数据问题基本又是搜遍百度各种方法尝试个遍，可能错过诊断问题的最佳时机，又可能尝试一堆方法最后无奈放弃。</p><p>怎么样让琐事缠身的程序维护人员，用最快的方式解决数据库出现的问题？怎么让我们程序员的痛苦降低到最小&#8230;每天喝喝茶水，看看新闻平安度过一天呢？本系列重要通过 <a href=\"http://www.grqsh.com/product_Expert.html\" target=\"_blank\">Expert for sqlserver </a>工具讲解下数据库遇到的各种问题的表象及导致这样问题的根本原因，让定位问题更准确，解决问题思路更清晰！！</p><p>数据库的性能好坏，对于最终用户来说表现为点击的操作是否能够快速响应，那么反应到数据库上就是语句执行时间是否够短！</p><p>对用运维人员数据库性能的表现，简单可能看成CPU 、内存、磁盘三巨头指标是否正常，那么今天我们就从CPU 下手，看看CPU能够看出哪些问题！</p><p><strong>废话不多说，直接开整&#8212;</strong></p><p>主要用到的性能计数器（不知道什么是性能计数器的，请自行百度）</p><p>就用两个~</p><ol><li>%Process Time　全实例　 （主要用于查看当前服务器的CPU 情况）</li><li>%Process Time　sqlservr （主要用于查看数据库使用的CPU情况 ）</li></ol><p><strong><strong>排除其他应用影响CPU</strong>　　　　　　　　　　　　　　　　　　　　　　　</strong></p><p><img src=\"http://jbcdn2.b0.upaiyun.com/2016/08/da810078db6fa6472766a284528c48d3.jpg\" alt=\" \" /></p><p>综合这两个计数器 在同一时间点可以诊断出CPU 是否是被服务器其他的应用所消耗的，如图中17:10 左右的  “%Process Time　全实例（红线）” 突然升高，而SQL 服务的（绿线）并无明显升高，这也就说明，在这个时间段的CPU 压力不是有数据库导致的！</p><p>这个红线的明显升高时，因为我在数据库所在的服务器上做了一次文件压缩！类似文件压缩这种操作会使用大量CPU，对数据库性能造成冲击！</p><p><strong>　CPU 问题分析　　　　　　　　　　　　　　　　　　　　　　　　</strong></p><p>CPU很高或者达到100%一定是你业务压力很大？CPU 不能满足你的需求么？在下结论前请仔细分析，一个草率的定论可能换来，老板一个安慰“世界那么大你该出去走走了！”</p><p>下面我们用几个典型的场景，分析下问题，并给出最佳实践~</p><p>高峰时段CPU 持续很高</p><p><img src=\"http://jbcdn2.b0.upaiyun.com/2016/08/9e65af5f98debf06ae62d746e93e5a21.png\" alt=\" \" /></p><p>图中是服务器几天的CPU情况</p><p>很多人看到这张图，是不是看到了自己的服务器？是否有一种亲切感呢~下面我们来分析下这种表象可能存在的问题！</p><p>首先明确一点90%的问题可能集中在10%的场景，这种CPU 持续持续很高的情况请注意下面两点：</p><ol><li>你的数据库并行度是否调整？</li><li>你的数据库是否缺少索引，导致频繁的查询消耗很高的CPU资源？</li></ol><p>最大并行度是什么？简单的可以理解为执行一条语句最多可以使用多少个CPU。看起来当然是使用的越多越好啦，使用的越多语句肯定越快呀！ 这个答案是大写的 “<strong>NO</strong>”，使用过多的CPU会导致线程协同工作产生的时间较长，直接导致语句很慢，而且消耗的CPU时间很多，导致CPU使用高，进而成为瓶颈！</p><p>看一个数据语句持续时间也就是执行时间，但是看看CPU的时间，这就是没有设置并行度，一个并行计划会产生大量的CPU消耗，另外会让语句执行的更慢！</p><p><img src=\"http://jbcdn2.b0.upaiyun.com/2016/08/4c9bea5e728bbb427a0bb8fc2dc97691.png\" alt=\" \" /></p><p>那么是不是使用的越少越好呢？任何事情没有绝对的，视情况而定，如果系统有比较大数据量的操作需求，并行使用多个CPU会有很大的提升。</p><p>一般建议系统如果超过32个CPU 那么设置成8或者4，如果系统中都是特别短小且频繁的语句建议设置成1（取消语句并行，要慎重真的符合你的场景才好）</p><p>并行开销的阀值，主要控制SQL优化器何时选用并行计划，建议默认值，此值设置的越小优化器越容易选择并行计划。</p><p>并行度的设置是针对实例级别的设置（2016中可以对单独数据库设置）</p><p>怎么设置并行度和阀值，请看下图: 系统默认的并行度 为0，阀值默认为5</p><p><img src=\"http://jbcdn2.b0.upaiyun.com/2016/08/9525a32d8e70d5a9d8131f02f9345531.png\" alt=\" \" /></p><p>并行度的调整可谓谁用谁知道啊，下面我们说说系统老大难的问题&#8211;语句导致CPU高</p><p>语句导致CPU高也是很常见的问题之一，那么语句怎么调优降低CPU 消耗呢？ 这里只做一些简单的说明，具体的语句调优、参数化减少语句编译，请看后面的系列文章。</p><p>语句调优的方式很多种，这里介绍和CPU相关最为常用：</p><ol><li>添加索引降低语句开销，执行需要的资源消耗少了消耗的CPU 自然相对就少了。</li><li>降低语句复杂度，让SQL Server执行高效（同样也是降低资源消耗的方法）。</li><li>分析语句是否可以采用串行计划。</li><li>前端程序尽量参数化减少语句的编译消耗。</li></ol><p>CPU 规律波动</p><p>拿到CPU的监控数据不要盲目下结论，数据往往是最能反映问题，给你提供思路的！</p><p><img src=\"http://jbcdn2.b0.upaiyun.com/2016/08/7009f4196ece05242ce2e9aa0f64b2ec.png\" alt=\" \" /></p><p>如果你是系统维护人员，看到类似这样的CPU数据指标，如果你还不能有一些思路，请你好好熟悉下你亲爱的系统。</p><p>这张图很清晰地反映出系统每半小时一次的CPU升高，那么别忙着去找对应时间点的语句，我们最少要好好想一下，系统中有什么操作半小时执行一直？SQL JOB？计划任务？前台定时处理？等等等</p><p>这个规律的定时处理是否有异常？是否最近有什么改动？执行的结果是不是和你想的一样？</p><p>也许问题就这么清晰的定位了&#8230;&#8230;</p><p>CPU 突然飙高</p><p><img src=\"http://jbcdn2.b0.upaiyun.com/2016/08/732f1e453228c9ce2ddb4ad3bcc238c6.png\" alt=\" \" /></p><p>图中 9点CPU由平均20几飙升到100%</p><p>CPU突然飙高可能是偶然的现象，也许你可以认为没有关系，但当你判断为偶然之前，你是否做过下面的分析：</p><ol><li>是否分析过系统日志，CPU飙高时间点是否有异常？</li><li>是否检查服务器上有什么特殊应用？</li><li>是否检查了数据库状态？</li><li>是否询问过相关业务人员？</li><li>是否马上开启监控为下一次突发情况的到来做好准备？</li></ol><p>如果没有你的判断真是毫无根据&#8230;也错过了一次发现问题，学习知识的机会！</p><p>排除上述异常，最有可能的原因就是数据库中，在那一刻有一个或多个语句运行异常，或非常不优化。如果这情况真的因为语句问题，而且只出现一次，那么这可能不是问题，我们尽量找到当时的语句，查看问题。找到当时的语句可以通过系统视图sys.dm_exec_query_stats 查看CPU消耗以及运行时间，或者由自己的监控工具得到。</p><p>找到对应的时间点看看到底是什么语句在运行~</p><p><img src=\"http://jbcdn2.b0.upaiyun.com/2016/08/62593bc80bf63bb476b975146dae912c.png\" alt=\" \" /></p><p>对这条语句进行分析到底是为什么！</p><p>CPU 真高！</p><p>经过各种分析优化，如果依然CPU压力明显，真心是硬件不能支撑业务了，那么我们就要选择更高大上的方式了，比如修改程序设计垂直/水平拆分，添加硬件，读写分离分担压力，组建集群负载均衡等等手段&#8230;&#8230;</p><p>&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8211;</p><p>总结：对于CPU压力的解决，大部分的用户可以通过调整并行度和系统语句的优化来解决。</p><p>另外对系统的监控和分析在诊断问题及解决问题中起到至关重要的作用。</p><p>在下结论前一定要经过仔细的分析研究，一个想当然的决定可能造成严重的影响。</p><p>你的系统真的需要加硬件，或高大上的方案么？</p><p>&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8211;给出一些CPU相关的文章连接&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8211;</p><ul><li>桦仔的  <a href=\"http://www.cnblogs.com/lyhabc/archive/2013/06/12/3133273.html\" target=\"_blank\">SQLSERVER排查CPU占用高的情况</a></li><li>高大侠的  <a id=\"cb_post_title_url\" href=\"http://www.cnblogs.com/shanksgao/p/5530107.html\">深入解析SQL Server并行执行原理及实践(下)</a></li><li>careyson的 <a id=\"cb_post_title_url\" href=\"http://www.cnblogs.com/CareySon/archive/2013/05/04/PlanCacheInSQLServer.html\">谈一谈SQL Server中的执行计划缓存（上）</a></li><li><a href=\"http://blog.csdn.net/zhaowenzhong/article/details/7211829\">常用 监控SQLSERVER性能计数器</a></li></ul><div class=\"wp_rp_wrap  wp_rp_plain\" ><div class=\"wp_rp_content\"><h3 class=\"related_post_title\">相关文章</h3><ul class=\"related_post wp_rp\" style=\"visibility: visible\"><li ><a href=\"http://blog.jobbole.com/91002/\" class=\"wp_rp_title\">SQL SERVER中什么情况会导致索引查找变成索引扫描</a></li><li ><a href=\"http://blog.jobbole.com/95913/\" class=\"wp_rp_title\">RAID的概念和RAID对于SQL性能的影响</a></li><li ><a href=\"http://blog.jobbole.com/95875/\" class=\"wp_rp_title\">如何查看某个查询用了多少TempDB空间</a></li><li ><a href=\"http://blog.jobbole.com/98633/\" class=\"wp_rp_title\">StackOverflow 这么大，它的架构是怎么样的？</a></li><li ><a href=\"http://blog.jobbole.com/100081/\" class=\"wp_rp_title\">MySQL 读写分离介绍及搭建</a></li><li ><a href=\"http://blog.jobbole.com/94173/\" class=\"wp_rp_title\">如何找出你性能最差的SQL Server查询</a></li><li ><a href=\"http://blog.jobbole.com/103474/\" class=\"wp_rp_title\">SQL SERVER全面优化：写出好语句是习惯</a></li><li ><a href=\"http://blog.jobbole.com/86774/\" class=\"wp_rp_title\">SQL Server基础：游标</a></li><li ><a href=\"http://blog.jobbole.com/95897/\" class=\"wp_rp_title\">谈一谈SQL Server中的执行计划缓存（上）</a></li><li ><a href=\"http://blog.jobbole.com/95907/\" class=\"wp_rp_title\">浅谈SQL Server中统计对于查询的影响</a></li></ul></div></div><p><a href=\"http://blog.jobbole.com/104023/\">Expert 诊断优化（1）：你的 CPU 高么？</a>，首发于<a href=\"http://blog.jobbole.com\">文章 - 伯乐在线</a>。</p>") (wfw:commentRss nil "http://blog.jobbole.com/104023/feed/") (slash:comments nil "0"))) ("为什么很多硅谷工程师偏爱 OS X，而不是 Linux 或 Windows？" "<p>【伯乐在线导读】：这个问题源自 Quora。题主说「看过许多诸如 Google、Dropbox、Quora 等公司的视频，发现有超过 90% 的工程师都在使用 Mac。Mac 为什么这么流行？难道大家没发现下面这些问题嘛？」</p><ul><li>昂贵但 GPU 性能一般！</li><li>没 Linux 开放（Linux 允许你编辑任何文件）</li><li>服务器是运行在 Linux 上的，在 Linux 上开发岂不更好。</li></ul><p>伯乐在线摘编了 3 位程序员的回复，全文如下。</p><p><img id=\"pic\" class=\" \" src=\"http://ww2.sinaimg.cn/large/7cc829d3gw1f6dxd5foaej20ci07oglx.jpg\" /></p><h3>Mike Mikowski 的回答，2700+ 顶</h3><p>我觉得以上大部分原因跟问题并不相关。</p><p>图中的这位，显然认为把 Linux 作为自己的首选操作系统，这是个非常好的主意。<br /><img title=\"Jeff Dean\" src=\"https://qph.ec.quoracdn.net/main-qimg-941c7c2232bf5465c5948a36f7a9c210?convert_to_webp=true\" alt=\"Jeff Dean\" /></p><p>他就是 Jeff Dean，在过去十年中为 Google 创造了数十亿美元的收入。</p><p>我们俩的桌面看起来很像：<br /><img title=\"Our's desktop\" src=\"https://qph.ec.quoracdn.net/main-qimg-6dd404a0b476c918ddd410ae906c2170?convert_to_webp=true\" alt=\"Our's desktop\" /></p><p>作为硅谷的一名高级架构师，Linux 和 OS X 我都在使用，但 Linux 更适合我。我坚信 Linux 应该被普及。说实话，OS X 在某些方面的确比 Linux 好，但这优势已经越来越小，因为 OS X 的缺陷越来越多了。</p><p>我相信，当工程师花 2500 美元买了一台 Macbook Retina Pro（16 GB 内存，Intel Iris Pro Graphics 图形处理器 和 AMD Radeon R9 M370X 图形处理器），就会发现 Mac 并没有比 Linux 优秀。随着 Mac 硬件（GPU）进一步落后和软件质量下降，我能预料 Linux 的普及。</p><p>让 Linux 普及的要点是可定制以及厂家的支持。这将解决硬件兼容性问题，启动时再也不会出现“just some old hardware”的提示。我现在用 System76 的笔记本和台式电脑，他们的电脑和售后非常好。我其中的一台笔记本 Oryx Pro 配置如下：搭载 GSync 技术的 GTX970m 显卡，固态硬盘， i7 处理器，32 GB 内存和 IPS 显示器，一点也不比 Macbook Pro 差。同时，我维护着一份 Kubuntu 下装机必备软件列表，欢迎评论和补充。</p><p>以下是我为什么用 Linux 开发和个人电脑的原因：</p><p><strong>1.强劲的 GPU 和 CPU。</strong>我的家用电脑和笔记本都培了顶级的显示器和 GPU。我和孩子 Steam 上玩了有 2000 个游戏，并且我对 CUDA 和 深度学习很感兴趣。而 Mac 对此就无能为力了。对我来说，强大的 GPU 是非常重要的，所以我配了一台搭载 GTX980Ti 显卡、32 GB 内存、3440×1440分辨率的曲面屏、i7 WildDogPro 处理器的电脑。而价格跟 MBP Retina 的价格相差无几。</p><p><strong>2. 与服务器真正的兼容。</strong>我曾工作过的一家公司，半数脚本是用 Linux 脚本和 GNU 工具写的，另一半是 Bash 和 BSD 工具写的，因为这部分开发者坚持用 Mac 开发，并认为 Mac 和 Linux 相差无几。我只想说，这真的太乱了。后来，我花了几周时间重写了代码（为了兼容）。这些人一边说：“Mac OS X 是不同的”，但另一边又说：“Mac OS X 跟 Linux 相差无几”。但事实并不是，Mac OS X 与 Linux 差很多。</p><p><strong>3. Linux 使我更高效。</strong>几乎不需要切换环境，我可以使用相同的工具，专注编写脚本，与服务器无缝衔接。至今，我还没发现哪个 Mac 用户能展现出令我印象深刻的 脚本编写能力。我曾经管理过一个需要超过 100 台以上 Linux 服务器集群的软件，除了 Linux ，其它系统根本胜任不了这个任务。</p><p><strong>4. Linux 上一切允许正常（Everything just works）。</strong>相对那些用 Mac 的同事，我在 Linux 上碰到的问题更少。不需要安装 <a href=\"http://brew.sh/\">homebrew</a>、<a href=\"http://www.finkproject.org/\">fink</a>、<a href=\"https://www.macports.org/\">MacPorts</a>，只要运行 <code>suao apt-get update</code> 和 <code>sudo apt-get upgrade</code> 这两个命令就可以了。团队里有少数人还在坚持使用 Mac，他们认为这是一种荣耀。编写脚本和程序设置电脑， Mac 大概要 2-3 天，而 Linux 只要一个小时，而且几乎是全自动化的。</p><p><strong>5. Linux 能做 Mac 不能做的事。</strong>有一天，我们需要超高清分辨率的屏幕截图，在 Linux 上只要输入: <code>$ xrandr --output DP-2.8 -s 3440x2880 --panning 3440x2880</code> ，之后用 Chrome 把图片放大一倍，并用 Ksnapshot 获得所需图片，前后只需要几分钟。谁能在 Mac 或者 Windows 上实现？</p><p><strong>6. “Linux 上不能运行商业软件”这个争论是毫无意义的</strong>，尤其是在硅谷，这里早就不使用微软的 Office 软件了。我使用 Balsamiq 3、Slack、DropBox、Chrome、Hangout、Google 办公套件、GoToMeeting、WebStorm、Skype、Gimp、Insync等软件…对了，在休息时间我会在 Steam 上玩会游戏。所有程序都运行良好，几乎没有应用程序或者系统崩溃。Webstorm（JetBrains IDE）在 Linux 上更友好，同样，NodeJS、MongoDB、MySQL和其它一系列开发工具在 Linux 都比 Mac 友好。</p><p>KED/Plasma 的界面比 Mac 和 Windows 都友好多了。你问我为什么这么说，因为我 KDE/Plasma 我都在使用。</p><p>这么多开发人员缺乏系统管理和使用脚本的技能，真是一件令人沮丧的事。相对命令行来说，Mac OS X 的图形界面限制了程序员的思考。如果有一天我在硅谷创业，我会把 Linux 当做首选的操作系统。</p><p><strong>注：</strong></p><ul><li>CUDA：一种由 NVIDIA 推出的通用并行计算架构，该架构使GPU能够解决复杂的计算问题。</li><li>deep learning：深度学习。源于人工神经网络的研究。含多隐层的多层感知器就是一种深度学习结构。深度学习通过组合低层特征形成更加抽象的高层表示属性类别或特征，以发现数据的分布式特征表示。需要 N 卡支持，而 Macbook 基本上配的都是 Intel 显卡。</li></ul><h3>Garry Taloy 的回答，103 顶</h3><p>GPU:</p><p><strong>程序员 != 游戏玩家。</strong></p><p>毫无疑问，配有更快的 GPU 显示效果更好，但除非你是开发游戏或者需要进行 3D 渲染，否则太奢侈了。我自己的两台开发用电脑，都只配备了普通的 Intel 集成显卡。</p><p><strong>Linux 允许你修改任何文件：</strong></p><p>我只是一位程序员，我只关心自己的代码，除此之外，别的文件能否修改和编译我并不关心。或许你该问问自己：什么是我真正需要编辑的？我是否有能力去修改文件？我为什么要这么做？</p><p><strong>在同一个系统下开发更好（代指服务器环境和开发环境相同）</strong></p><p>首先，这个理由相当不错，但对于 Apache 或者其它什么，在 Mac OS X 上和 Linux 上运行的效果是极其相似的。如果使用诸如 OpenVMS 、 IBM i 或者 z/OS 这些操作系统，那就另当别论了。但是，我敢打赌，在 Mac 上运行网页的效果肯定跟 Linux 是一样的。</p><p><strong>Expensive:</strong><br /><strong>贵</strong></p><p>实则不然，在相似情况下，一台搭载高清屏、 SSD 固态硬盘 、工业设计都不错的、你听过的牌子的笔记本， Mac 的价格其实并没有贵多少。姑且就说 Mac 贵几百美元吧，但能给程序员支付高薪的公司，并不会吝啬这部分钱。假设 Google 程序员的年薪是 100,000 美元，加上税收和医疗保险、办公空间等额外支出，Google 每年在程序员身上的花费可能会达到 150000 美元。你认为 Google 会在乎多花 300 美元购买 Mac 嘛？</p><p>这就好像花 10 美元买喜欢的披萨，和话 10.01 美元买你很喜欢的披萨，没多少差别~</p><p>回答你的问题，就要忽略你说的，因为你说的 99% 与问题无关。</p><h3>Ivan Apple 的回答</h3><p><strong>服务器是运行在 Linux 上的，在 Linux 上开发岂不更好</strong></p><p>兄弟，你这让我想起这个论点还有价值的年代。想当年，想用 Linux 却没钱买新电脑，唯一的选择就是将 Linux 作为你的主操作系统（学会忍受糟糕的 GUI、应用少等这些不足之处）。</p><p>如今，通过 VirtualBox，可以很轻松地在 Windows 或 Mac 上安装 Linux 服务器发行版，“在同一个操作系统下开发”就迎刃而解了。</p><p>最终，学习如何调整 KDE Plasma 和 分析 Wi-Fi 驱动并不会让你成为一个更好的程序员和系统管理员。这只是一个习惯问题，而且是相当无聊的习惯。</p><p><strong>Linux 允许你修改任何文件</strong></p><p>这个观点经常出现在争论中。</p><p>我就说一句话：Ubuntu 和 Red Hat 是现实世界中最流行的 Linux 发行版，而它们可以在 VirtualBox 很好的工作。</p><p><strong>昂贵但 GPU 性能一般！</strong></p><p>其实 Mac 并不贵。MB Pro 大概只要 1300 欧元（折合人民币约 9500 元）。而差不多配置 HP 或者 Lenove 笔记本大概要 900 欧元（折合人民币约 6600元）。根据笔记本平均生命周期，购买外形轻薄、耐用（强劲的电池寿命）的 Mac 每个月只要多支付 7 欧元即可。这是一个很划算的投资。</p><h3>你的主力操作系统是哪一个？为什么选用？欢迎大家评论。</h3><div class=\"wp_rp_wrap  wp_rp_plain\" ><div class=\"wp_rp_content\"><h3 class=\"related_post_title\">相关文章</h3><ul class=\"related_post wp_rp\" style=\"visibility: visible\"><li ><a href=\"http://blog.jobbole.com/34764/\" class=\"wp_rp_title\">王垠：漫谈Linux、Windows和Mac</a></li><li ><a href=\"http://blog.jobbole.com/40278/\" class=\"wp_rp_title\">如何在安装双启动后卸载 Windows 或者 Linux</a></li><li ><a href=\"http://blog.jobbole.com/97676/\" class=\"wp_rp_title\">基于 JavaScript 的操作系统你听说过吗？</a></li><li ><a href=\"http://blog.jobbole.com/29546/\" class=\"wp_rp_title\">Ubuntu桌面生存指南(1)：选择 Linux</a></li><li ><a href=\"http://blog.jobbole.com/97892/\" class=\"wp_rp_title\">一个八年的 Linux 老用户使用 Windows 10 的体验</a></li><li ><a href=\"http://blog.jobbole.com/26741/\" class=\"wp_rp_title\">王垠：从工具的奴隶到工具的主人</a></li><li ><a href=\"http://blog.jobbole.com/1574/\" class=\"wp_rp_title\">受够了Linux服务器 重返Windows</a></li><li ><a href=\"http://blog.jobbole.com/85341/\" class=\"wp_rp_title\">Windows 10 VS. Linux</a></li><li ><a href=\"http://blog.jobbole.com/104042/\" class=\"wp_rp_title\">如何在 Linux 下检测内存泄漏</a></li><li ><a href=\"http://blog.jobbole.com/22838/\" class=\"wp_rp_title\">流行Linux和Windows脚本语言列表</a></li></ul></div></div><p><a href=\"http://blog.jobbole.com/104019/\">为什么很多硅谷工程师偏爱 OS X，而不是 Linux 或 Windows？</a>，首发于<a href=\"http://blog.jobbole.com\">文章 - 伯乐在线</a>。</p>" "http://blog.jobbole.com/104019/" (22430 37732) old 19 nil nil ((title nil "为什么很多硅谷工程师偏爱 OS X，而不是 Linux 或 Windows？") (link nil "http://blog.jobbole.com/104019/") (comments nil "http://blog.jobbole.com/104019/#comments") (pubDate nil "Mon, 01 Aug 2016 00:10:12 +0000") (dc:creator nil "踏歌行") (category nil "开发") (category nil "Linux") (category nil "Mac") (category nil "Windows") (guid ((isPermaLink . "false")) "http://blog.jobbole.com/?p=104019") (description nil "<p>我看过许多诸如 Google、Dropbox、Quora 等公司的视频，发现有超过 90% 的工程师都在使用 Mac。Mac 为什么这么流行？难道大家没发现下面这些问题嘛？</p><p><a href=\"http://blog.jobbole.com/104019/\">为什么很多硅谷工程师偏爱 OS X，而不是 Linux 或 Windows？</a>，首发于<a href=\"http://blog.jobbole.com\">文章 - 伯乐在线</a>。</p>") (content:encoded nil "<p>【伯乐在线导读】：这个问题源自 Quora。题主说「看过许多诸如 Google、Dropbox、Quora 等公司的视频，发现有超过 90% 的工程师都在使用 Mac。Mac 为什么这么流行？难道大家没发现下面这些问题嘛？」</p><ul><li>昂贵但 GPU 性能一般！</li><li>没 Linux 开放（Linux 允许你编辑任何文件）</li><li>服务器是运行在 Linux 上的，在 Linux 上开发岂不更好。</li></ul><p>伯乐在线摘编了 3 位程序员的回复，全文如下。</p><p><img id=\"pic\" class=\" \" src=\"http://ww2.sinaimg.cn/large/7cc829d3gw1f6dxd5foaej20ci07oglx.jpg\" /></p><h3>Mike Mikowski 的回答，2700+ 顶</h3><p>我觉得以上大部分原因跟问题并不相关。</p><p>图中的这位，显然认为把 Linux 作为自己的首选操作系统，这是个非常好的主意。<br /><img title=\"Jeff Dean\" src=\"https://qph.ec.quoracdn.net/main-qimg-941c7c2232bf5465c5948a36f7a9c210?convert_to_webp=true\" alt=\"Jeff Dean\" /></p><p>他就是 Jeff Dean，在过去十年中为 Google 创造了数十亿美元的收入。</p><p>我们俩的桌面看起来很像：<br /><img title=\"Our's desktop\" src=\"https://qph.ec.quoracdn.net/main-qimg-6dd404a0b476c918ddd410ae906c2170?convert_to_webp=true\" alt=\"Our's desktop\" /></p><p>作为硅谷的一名高级架构师，Linux 和 OS X 我都在使用，但 Linux 更适合我。我坚信 Linux 应该被普及。说实话，OS X 在某些方面的确比 Linux 好，但这优势已经越来越小，因为 OS X 的缺陷越来越多了。</p><p>我相信，当工程师花 2500 美元买了一台 Macbook Retina Pro（16 GB 内存，Intel Iris Pro Graphics 图形处理器 和 AMD Radeon R9 M370X 图形处理器），就会发现 Mac 并没有比 Linux 优秀。随着 Mac 硬件（GPU）进一步落后和软件质量下降，我能预料 Linux 的普及。</p><p>让 Linux 普及的要点是可定制以及厂家的支持。这将解决硬件兼容性问题，启动时再也不会出现“just some old hardware”的提示。我现在用 System76 的笔记本和台式电脑，他们的电脑和售后非常好。我其中的一台笔记本 Oryx Pro 配置如下：搭载 GSync 技术的 GTX970m 显卡，固态硬盘， i7 处理器，32 GB 内存和 IPS 显示器，一点也不比 Macbook Pro 差。同时，我维护着一份 Kubuntu 下装机必备软件列表，欢迎评论和补充。</p><p>以下是我为什么用 Linux 开发和个人电脑的原因：</p><p><strong>1.强劲的 GPU 和 CPU。</strong>我的家用电脑和笔记本都培了顶级的显示器和 GPU。我和孩子 Steam 上玩了有 2000 个游戏，并且我对 CUDA 和 深度学习很感兴趣。而 Mac 对此就无能为力了。对我来说，强大的 GPU 是非常重要的，所以我配了一台搭载 GTX980Ti 显卡、32 GB 内存、3440&#215;1440分辨率的曲面屏、i7 WildDogPro 处理器的电脑。而价格跟 MBP Retina 的价格相差无几。</p><p><strong>2. 与服务器真正的兼容。</strong>我曾工作过的一家公司，半数脚本是用 Linux 脚本和 GNU 工具写的，另一半是 Bash 和 BSD 工具写的，因为这部分开发者坚持用 Mac 开发，并认为 Mac 和 Linux 相差无几。我只想说，这真的太乱了。后来，我花了几周时间重写了代码（为了兼容）。这些人一边说：“Mac OS X 是不同的”，但另一边又说：“Mac OS X 跟 Linux 相差无几”。但事实并不是，Mac OS X 与 Linux 差很多。</p><p><strong>3. Linux 使我更高效。</strong>几乎不需要切换环境，我可以使用相同的工具，专注编写脚本，与服务器无缝衔接。至今，我还没发现哪个 Mac 用户能展现出令我印象深刻的 脚本编写能力。我曾经管理过一个需要超过 100 台以上 Linux 服务器集群的软件，除了 Linux ，其它系统根本胜任不了这个任务。</p><p><strong>4. Linux 上一切允许正常（Everything just works）。</strong>相对那些用 Mac 的同事，我在 Linux 上碰到的问题更少。不需要安装 <a href=\"http://brew.sh/\">homebrew</a>、<a href=\"http://www.finkproject.org/\">fink</a>、<a href=\"https://www.macports.org/\">MacPorts</a>，只要运行 <code>suao apt-get update</code> 和 <code>sudo apt-get upgrade</code> 这两个命令就可以了。团队里有少数人还在坚持使用 Mac，他们认为这是一种荣耀。编写脚本和程序设置电脑， Mac 大概要 2-3 天，而 Linux 只要一个小时，而且几乎是全自动化的。</p><p><strong>5. Linux 能做 Mac 不能做的事。</strong>有一天，我们需要超高清分辨率的屏幕截图，在 Linux 上只要输入: <code>$ xrandr --output DP-2.8 -s 3440x2880 --panning 3440x2880</code> ，之后用 Chrome 把图片放大一倍，并用 Ksnapshot 获得所需图片，前后只需要几分钟。谁能在 Mac 或者 Windows 上实现？</p><p><strong>6. “Linux 上不能运行商业软件”这个争论是毫无意义的</strong>，尤其是在硅谷，这里早就不使用微软的 Office 软件了。我使用 Balsamiq 3、Slack、DropBox、Chrome、Hangout、Google 办公套件、GoToMeeting、WebStorm、Skype、Gimp、Insync等软件&#8230;对了，在休息时间我会在 Steam 上玩会游戏。所有程序都运行良好，几乎没有应用程序或者系统崩溃。Webstorm（JetBrains IDE）在 Linux 上更友好，同样，NodeJS、MongoDB、MySQL和其它一系列开发工具在 Linux 都比 Mac 友好。</p><p>KED/Plasma 的界面比 Mac 和 Windows 都友好多了。你问我为什么这么说，因为我 KDE/Plasma 我都在使用。</p><p>这么多开发人员缺乏系统管理和使用脚本的技能，真是一件令人沮丧的事。相对命令行来说，Mac OS X 的图形界面限制了程序员的思考。如果有一天我在硅谷创业，我会把 Linux 当做首选的操作系统。</p><p><strong>注：</strong></p><ul><li>CUDA：一种由 NVIDIA 推出的通用并行计算架构，该架构使GPU能够解决复杂的计算问题。</li><li>deep learning：深度学习。源于人工神经网络的研究。含多隐层的多层感知器就是一种深度学习结构。深度学习通过组合低层特征形成更加抽象的高层表示属性类别或特征，以发现数据的分布式特征表示。需要 N 卡支持，而 Macbook 基本上配的都是 Intel 显卡。</li></ul><h3>Garry Taloy 的回答，103 顶</h3><p>GPU:</p><p><strong>程序员 != 游戏玩家。</strong></p><p>毫无疑问，配有更快的 GPU 显示效果更好，但除非你是开发游戏或者需要进行 3D 渲染，否则太奢侈了。我自己的两台开发用电脑，都只配备了普通的 Intel 集成显卡。</p><p><strong>Linux 允许你修改任何文件：</strong></p><p>我只是一位程序员，我只关心自己的代码，除此之外，别的文件能否修改和编译我并不关心。或许你该问问自己：什么是我真正需要编辑的？我是否有能力去修改文件？我为什么要这么做？</p><p><strong>在同一个系统下开发更好（代指服务器环境和开发环境相同）</strong></p><p>首先，这个理由相当不错，但对于 Apache 或者其它什么，在 Mac OS X 上和 Linux 上运行的效果是极其相似的。如果使用诸如 OpenVMS 、 IBM i 或者 z/OS 这些操作系统，那就另当别论了。但是，我敢打赌，在 Mac 上运行网页的效果肯定跟 Linux 是一样的。</p><p><strong>Expensive:</strong><br /><strong>贵</strong></p><p>实则不然，在相似情况下，一台搭载高清屏、 SSD 固态硬盘 、工业设计都不错的、你听过的牌子的笔记本， Mac 的价格其实并没有贵多少。姑且就说 Mac 贵几百美元吧，但能给程序员支付高薪的公司，并不会吝啬这部分钱。假设 Google 程序员的年薪是 100,000 美元，加上税收和医疗保险、办公空间等额外支出，Google 每年在程序员身上的花费可能会达到 150000 美元。你认为 Google 会在乎多花 300 美元购买 Mac 嘛？</p><p>这就好像花 10 美元买喜欢的披萨，和话 10.01 美元买你很喜欢的披萨，没多少差别~</p><p>回答你的问题，就要忽略你说的，因为你说的 99% 与问题无关。</p><h3>Ivan Apple 的回答</h3><p><strong>服务器是运行在 Linux 上的，在 Linux 上开发岂不更好</strong></p><p>兄弟，你这让我想起这个论点还有价值的年代。想当年，想用 Linux 却没钱买新电脑，唯一的选择就是将 Linux 作为你的主操作系统（学会忍受糟糕的 GUI、应用少等这些不足之处）。</p><p>如今，通过 VirtualBox，可以很轻松地在 Windows 或 Mac 上安装 Linux 服务器发行版，“在同一个操作系统下开发”就迎刃而解了。</p><p>最终，学习如何调整 KDE Plasma 和 分析 Wi-Fi 驱动并不会让你成为一个更好的程序员和系统管理员。这只是一个习惯问题，而且是相当无聊的习惯。</p><p><strong>Linux 允许你修改任何文件</strong></p><p>这个观点经常出现在争论中。</p><p>我就说一句话：Ubuntu 和 Red Hat 是现实世界中最流行的 Linux 发行版，而它们可以在 VirtualBox 很好的工作。</p><p><strong>昂贵但 GPU 性能一般！</strong></p><p>其实 Mac 并不贵。MB Pro 大概只要 1300 欧元（折合人民币约 9500 元）。而差不多配置 HP 或者 Lenove 笔记本大概要 900 欧元（折合人民币约 6600元）。根据笔记本平均生命周期，购买外形轻薄、耐用（强劲的电池寿命）的 Mac 每个月只要多支付 7 欧元即可。这是一个很划算的投资。</p><h3>你的主力操作系统是哪一个？为什么选用？欢迎大家评论。</h3><div class=\"wp_rp_wrap  wp_rp_plain\" ><div class=\"wp_rp_content\"><h3 class=\"related_post_title\">相关文章</h3><ul class=\"related_post wp_rp\" style=\"visibility: visible\"><li ><a href=\"http://blog.jobbole.com/34764/\" class=\"wp_rp_title\">王垠：漫谈Linux、Windows和Mac</a></li><li ><a href=\"http://blog.jobbole.com/40278/\" class=\"wp_rp_title\">如何在安装双启动后卸载 Windows 或者 Linux</a></li><li ><a href=\"http://blog.jobbole.com/97676/\" class=\"wp_rp_title\">基于 JavaScript 的操作系统你听说过吗？</a></li><li ><a href=\"http://blog.jobbole.com/29546/\" class=\"wp_rp_title\">Ubuntu桌面生存指南(1)：选择 Linux</a></li><li ><a href=\"http://blog.jobbole.com/97892/\" class=\"wp_rp_title\">一个八年的 Linux 老用户使用 Windows 10 的体验</a></li><li ><a href=\"http://blog.jobbole.com/26741/\" class=\"wp_rp_title\">王垠：从工具的奴隶到工具的主人</a></li><li ><a href=\"http://blog.jobbole.com/1574/\" class=\"wp_rp_title\">受够了Linux服务器 重返Windows</a></li><li ><a href=\"http://blog.jobbole.com/85341/\" class=\"wp_rp_title\">Windows 10 VS. Linux</a></li><li ><a href=\"http://blog.jobbole.com/104042/\" class=\"wp_rp_title\">如何在 Linux 下检测内存泄漏</a></li><li ><a href=\"http://blog.jobbole.com/22838/\" class=\"wp_rp_title\">流行Linux和Windows脚本语言列表</a></li></ul></div></div><p><a href=\"http://blog.jobbole.com/104019/\">为什么很多硅谷工程师偏爱 OS X，而不是 Linux 或 Windows？</a>，首发于<a href=\"http://blog.jobbole.com\">文章 - 伯乐在线</a>。</p>") (wfw:commentRss nil "http://blog.jobbole.com/104019/feed/") (slash:comments nil "9"))) ("玩转 Windows 10 中的 Linux 子系统" "<p style=\"text-align: justify\">在今年的 Build 2016 上，微软向全世界<a href=\"https://linux.cn/article-7177-1.html\">介绍了</a>他们还处于 Beta 阶段的 Windows 下的 Linux 子系统（Windows Subsystem for Linux）（WSL），它可以让开发者们在 Windows 10 下通过 Bash shell 运行原生的 Ubuntu 用户态二进制程序。如果你参与了 Windows Insider 计划，你就可以在最新的 Windows 10 年度升级版的 Insider 构建版中体验这个功能了。</p><p style=\"text-align: justify\">Web 开发人员们不用再苦恼所用的 Windows 开发平台上没有合适的 Linux 工具和库了。WSL 是由 Windows 内核团队与 Canonical 合作设计和开发的，可以让 Windows 10 下的开发者们在拥有 Windows 中那些强力支持之外，还能使用 Linux 下丰富的开发环境与工具，而不用启动到另外的操作系统或者使用虚拟机。这绝对是一个“来自开发者，服务开发者”的 Windows 10 特色，它的目的是让开发者们每天的开发工作都变得顺畅而便捷。</p><p style=\"text-align: justify\">在本文中，我会展示给你一些我认为非常有趣的功能，以及告诉你一些可以让你找到更多信息的资源。首先，我会展示 WSL 所集成的那些主要命令（比如 ssh）是如何操作服务器和设备的。其次，我会演示使用 Bash 脚本是如何以简明的方式来自动化执行任务的。其三，我会利用极棒的命令行编译器、一些其它工具以及对 *nix 兼容的能力来玩一个轻量级的古典黑客级游戏： NetHack。最后，我会展示如何使用已有的 Python 脚本和其它来自网上的脚本。</p><blockquote><p>从我的第一台 286 上运行的 Windows 3.0 开始，Windows 就一直是我的主要操作系统和开发环境。不过，我身边也有很多 Linux 服务器和设备。从树莓派和路由器/网关设备这样的物联网设备，到 Minecraft 服务器，它们堆满了我的办公室的每个角落。而我经常要从我的主工作站中去管理和配置这些 Linux 计算机。</p></blockquote><h3 style=\"text-align: justify\">管理服务器和设备</h3><p style=\"text-align: justify\">我在我的家中运行着一台无显示器的 Ubuntu Minecraft 服务器，这是我去年给我十岁大的儿子的圣诞礼物，但是它已经变成了我的玩具而不是他的（好吧，主要是我的玩具）。我以前在我的 Windows 10 电脑上使用几个客户端来管理它，不过我现在想使用 Windows 中的 Bash 里面的 ssh 命令行来管理它。使用类似 PuTTY 或来自 Cygwin 的 Tera Term 这样的应用当然也可以，但是我想试试真正原生而自然的体验也是一种不错的选择。Cygwin 就像是在披萨店订购的披萨一样，好吃，但是没有那种氛围。</p><p style=\"text-align: justify\">我已经使用 WSL 中的 <code>ssh-keygen</code> 和 <code>ssh-copy-id</code> 设置好了公私密钥对，所以使用 ssh 只需要如下简单输入即可：</p><p></p><pre class=\"crayon-plain-tag\">$ ssh &lt;username&gt;@&lt;server&gt;</pre><p></p><p style=\"text-align: justify\">我还为此创建了一个别名，以便更快一些。这是一个标准的 Linux/Bash 功能：</p><p></p><pre class=\"crayon-plain-tag\">$ alias mc='ssh &lt;user&gt;@&lt;server&gt;'</pre><p></p><p style=\"text-align: justify\">现在，我要访问我的 Minecraft 服务器只需要在 Windows 10 下的 Bash 中输入“mc”即可。</p><p style=\"text-align: justify\"><img src=\"http://jbcdn2.b0.upaiyun.com/2016/07/e2775253ec67d3de168cbeafda33e5ba.png\" alt=\" \" width=\"785\" height=\"603\" /></p><p style=\"text-align: justify\">当然，同样的方法你也可以用于任何 Linux 上的 Web 或数据库服务器上，甚至树莓派或其它的物联网设备也可以。</p><blockquote><p>在终端里面进行 ssh 只是为了方便而已，不过当你在 shell 中工作时，如果还有类似 apt、node、Ruby、Python 等等工具时，你就有了自动化各种工作的可能。</p></blockquote><h3 style=\"text-align: justify\">远程脚本</h3><p style=\"text-align: justify\">假如说你有一大堆 Linux 服务器和设备，而你要在它们上面执行一个远程命令的话，如果已经配置好公私密钥对，你就可以在 Bash 中直接远程执行命令。</p><p style=\"text-align: justify\">举个例子说，想知道远程服务器自从上次重启后已经运行了多长时间了，你只需要输入：</p><p></p><pre class=\"crayon-plain-tag\">$ ssh &lt;user&gt;@&lt;server&gt; 'last -x|grep reboot'</pre><p></p><p style=\"text-align: justify\">ssh 会连接到该服务器并执行 <code>last -x</code> 命令，然后搜索包含“reboot”的一行。我在我的 Ubuntu Minecraft 服务器上运行的结果如下：</p><p></p><pre class=\"crayon-plain-tag\">reboot   system boot  4.4.0-28-generic Thu Jul  7 08:14   still running</pre><p></p><p style=\"text-align: justify\">这只是一台服务器，如果你有许多服务器的话，你可以自动化这个过程。我在 WSL 里我的主目录下创建了一个名为 servers.txt 的文件，它包含了一系列 Linux 服务器/设备的名称，每个一行。然后我就可以创建一个脚本来读取这个文件。</p><p style=\"text-align: justify\">在使用了很多年像树莓派这样的设备之后，我已经变成了一个 nano 人（在 VMS 上我是一个 LSEdit 人），下面是我用我喜爱的 nano 编辑器打开的脚本。</p><p style=\"text-align: justify\"><img src=\"http://jbcdn2.b0.upaiyun.com/2016/07/4b3f3d4144ed32d597a063b9915dc18d.png\" alt=\" \" width=\"836\" height=\"268\" /></p><p style=\"text-align: justify\">当然，你也可以使用 vim 、 emacs 或者其它可以用在 Ubuntu 终端上的编辑器。</p><p style=\"text-align: justify\">该脚本是 Bash 脚本，要执行该脚本，输入：</p><p></p><pre class=\"crayon-plain-tag\">$ ./foreachserver.sh 'last -x|grep reboot'</pre><p></p><p style=\"text-align: justify\">它将迭代输出文件中的每个服务器/设备，然后通过 ssh 远程执行该命令。当然，这个例子非常简单，但是你可以像这样把你的本地脚本或其它命令变成远程的。Bash 脚本语言足够丰富，所以你可以使用它来完成你的大多数远程管理任务。你可以用你下载到 WSL 或远程系统中的其它应用来扩展它的使用。</p><blockquote><p>你是否需要在工作中把本地的 Windows 文件或资源用于其它的 Linux 计算机吗？或者，你根本不使用 Linux ？Bash 可以操作本地的 Windows 文件或资源，还是说它就是一个完全独立的环境？</p></blockquote><h3 style=\"text-align: justify\">使用 Windows 文件</h3><p style=\"text-align: justify\">WSL 系统可以通过 <code>/mnt//</code> 目录（挂载点）来访问你计算机上的文件系统。举个例子，你的 Windows 上的 C: 和 D: 根目录可以在 WSL 中相应地通过 /mnt/c 和 /mnt/d 访问。当你要把你的 Windows 下的项目文件、下载的内容和其它文件用到 Linux/Bash 之中时这很有用。</p><p style=\"text-align: justify\"><img src=\"http://jbcdn2.b0.upaiyun.com/2016/07/1701666cc539d37cc44e132663c3835b.png\" alt=\" \" width=\"604\" height=\"193\" /></p><p style=\"text-align: justify\">上图显示的两个目录分别对应于我的计算机上的 SSD 和硬盘：</p><p style=\"text-align: justify\"><img src=\"http://jbcdn2.b0.upaiyun.com/2016/07/bab4932042fba9e803e88a829b6a200a.png\" alt=\" \" width=\"556\" height=\"104\" /></p><p style=\"text-align: justify\">这是逻辑挂载，所以当你在 shell 中使用类似 <code>mount</code> 这样的命令时它们不会显示。但是它们可以如你预期的那样工作。举个例子，在 Windows 中，我在我的 C 盘根目录下放了一个名为 test.txt 的文件，我可以在 WSL 中如下访问它：</p><p style=\"text-align: justify\"><img src=\"http://jbcdn2.b0.upaiyun.com/2016/07/06344269f0e21908b291acf215d98ba0.png\" alt=\" \" width=\"774\" height=\"151\" /></p><p style=\"text-align: justify\">在 Build  Tour 大会期间，我们要确保所有的演示都可以在没有互联网时也能正常工作（你绝不会知道会场的网络是什么样子的） ，所以为了让 Bash/WSL 可以演示 Git 操作，该演示访问的是本地计算机上的 Windows 文件，我在 Windows 上的 C:gitNetHack 下设置一个本地仓库。 要在 WSL 中进行 clone 操作，我执行了如下命令：</p><p></p><pre class=\"crayon-plain-tag\">$ git –clone file:///mnt/c/git/NetHack</pre><p></p><p style=\"text-align: justify\">该命令告诉 git 使用 <code>file://</code> 协议，并 clone 了位于 /mnt/c/git/NetHack 下的仓库。你可以以类似的方式来访问你的 Windows 下的所有文件。</p><p style=\"text-align: justify\">警示：就像在其它终端中一样，如果你不小心的话，你可以在 Bash 中修改/删除 Windows 文件系统中的文件。举个例子，你可以像下面这样来干掉你的 Windows ，假如你有合适的权限的话。</p><p></p><pre class=\"crayon-plain-tag\">$ rm -rf /mnt/c/  [千万别试！][千万别试！][千万别试！]</pre><p></p><p style=\"text-align: justify\">我之所以郑重提醒是因为我们很多人都是刚刚接触 Linux 命令，它们不是 Windows 命令。</p><p style=\"text-align: justify\">这种可以让文件系统集成到一起的魔法来自 DrvFs。如果你希望了解该文件系统的更多细节，以及它是如何工作在 WSL 中的，WSL 团队为此写了一篇<a href=\"https://blogs.msdn.microsoft.com/wsl/2016/06/15/wsl-file-system-support/\">详细的文章</a>。</p><blockquote><p>当然， 文件系统访问只是 WSL 其中的一部分功能而已，许多开发任务还需要通过 HTTP 或其它网络协议访问远程资源。</p></blockquote><h3 style=\"text-align: justify\">发起 HTTP 请求</h3><p style=\"text-align: justify\">从脚本或命令行而不是从一个编译好的程序或 Web 页面上发起 REST 或其它 HTTP（或 FTP）请求是很有用的。就像在大多数 Linux 发行版一样，WSL 也包括了类似 curl 或 wget 获取资源这样的标准功能，它们可以用来发起 HTTP 或者其它网络请求。举个例子，下面是使用 curl 对 Github 发起 REST 请求来获取我个人的属性信息：</p><p></p><pre class=\"crayon-plain-tag\">$ curl -i https://api.github.com/users/Psychlist1972
HTTP/1.1 200 OK
Server: GitHub.com
Date: Wed, 13 Jul 2016 02:38:08 GMT
Content-Type: application/json; charset=utf-8
Content-Length: 1319
Status: 200 OK
...
{
\"login\": \"Psychlist1972\",
\"avatar_url\": \"https://avatars.githubusercontent.com/u/1421146?v=3\",
\"url\": \"https://api.github.com/users/Psychlist1972\",
\"name\": \"Pete Brown\",
\"company\": \"Microsoft\",
...
}
$</pre><p></p><p style=\"text-align: justify\">你可以用它和 Bash 脚本来创建一个 REST API 的快速测试客户端，也可以用来探测一个 Web 页面或服务器并报告其返回的状态。它用来从网上下载文件也很棒，你可以简单地重定向输出到一个文件而不是在屏幕上显示它：</p><p></p><pre class=\"crayon-plain-tag\">$ curl -i https://api.github.com/users/Psychlist1972 &gt; pete.json</pre><p></p><p style=\"text-align: justify\">我也是一个 PowerShell 用户，甚至还使用 <a href=\"https://github.com/Psychlist1972/Windows-10-PowerShell-MIDI\">Windows 10 MIDI in PowerShell</a> 创建了一些有趣的扩展，也<a href=\"https://github.com/Psychlist1972/Fix-SoundDevices-File-Corruption\">修复</a>过出现在特定的录音硬件设备上的一些文件问题。作为长时间的 .NET 开发者和爱好者，我经常使用和扩展 PowerShell 以满足我的项目需求。但是  PowerShell 并不是一个可以运行所有的那些 Bash 脚本和针对 Linux 的开源工具的地方。我希望以一种最简单、最舒服的方式来完成这些任务，在某种意义上，这意味着我们需要在 Bash 中完成它们。</p><blockquote><p>我已经一掠而过的介绍了 Bash、Bash 脚本以及你可以在 shell 中完成的任务。到目前为止，我谈论的都是有助于开发工作的那些功能。但是在 WSL 中实际的开发和编译工作是怎样的？我在 Build Tour 大会上演示了下面这个部分。</p></blockquote><h3 style=\"text-align: justify\">Build Tour 大会上的演示：NetHack</h3><p style=\"text-align: justify\">这个夏初，来自微软的讲演者们向大家演示了一些来自 Windows 和微软云上的很酷的开发者新功能。作为其中的一部分，我以一种好玩的方式来演示了 WSL，而且这是一种和开发者们相关的方式。</p><p style=\"text-align: justify\">我个人想要展示使用 git 和一些传统的终端开发工具，我已经写好了 Bash 的演示程序，包括了这些基础的东西（用 Python 和 Ruby 写的“Hello World”），不过我还是想要更有冲击力一些。</p><p style=\"text-align: justify\">我回想起我在大学的时光，那时我们在 Unix（DEC Ultrix 及 SunOS）和 VAX/VMS 之间折腾，Unix 几乎全是命令行环境。在我们学校，绝大多数使用图形工作站的用户只是为了在不同的窗口打开多个终端会话而已，当然，会在桌面背景放上一张超酷的月相图。大部分学生都是使用 VT-220 终端来打开他们的会话（学校离波士顿不远，所以我们有很多 DEC 设备）。</p><p style=\"text-align: justify\">那时，计算机系的学生们主要玩两大游戏：MUD （主要是 lpMUD 和当时刚出的 DikuMUD）和 <a href=\"https://en.wikipedia.org/wiki/NetHack\">NetHack</a>。NetHack 和其它的 <a href=\"https://en.wikipedia.org/wiki/Roguelike\">Roguelikes</a> 类游戏被视为历史上最有影响力的游戏之一，它们是许多现在流行的地牢冒险和角色扮演类游戏的鼻祖。</p><p style=\"text-align: justify\">NetHack 有很长的历史，现在的它包含了来自几十年前的几十万行 *nix 代码，以及后来补充的一些代码。该游戏使用 <a href=\"https://en.wikipedia.org/wiki/Curses_(programming_library)\">curses</a> （及其替代品）作为终端交互方式，需要通过 lex、 yacc（或 flex 和 bison）和 cc（或 gcc），以及一堆其它的开发工具构建。</p><p style=\"text-align: justify\">它是由 C 语言编写的，并包括了一些用 <a href=\"https://en.wikipedia.org/wiki/Bourne_shell\">Bourne shell</a> 编写的复杂的脚本配置功能。我觉得它是一个体现 WSL 和 Bash on Windows 10 的开发者能力的不错而有趣的方式。由于使用了 curses（在 Linux 和 WSL 中是 libncurses 库），它也可以用来展示 Windows 10 中命令行窗口中的终端模拟能力。</p><p style=\"text-align: justify\">以前，在我们的分时 Ultrix 服务器上从源代码构建 NetHack 要花费掉我们很多时间，而现在我的个人计算机上只需要几分钟就可以搞定。我喜欢这种技术进步。在 Linux 或 WSL 上配置和编译 NetHack 有容易和复杂两种方式。为了节省时间，我们会以容易的方式来进行。</p><h4 style=\"text-align: justify\">前置需求</h4><p style=\"text-align: justify\">首先，更新你的 WSL 环境，确保你的软件是最新的。在安装新的软件包之前，这是一个好的做法。</p><p></p><pre class=\"crayon-plain-tag\">$ sudo apt update
$ sudo apt upgrade</pre><p></p><p style=\"text-align: justify\">然后，安装必须的开发工具。最简单的办法就是使用 build-essential 软件包，它包括了 Linux 开发者构建以 C/C++ 开发的软件时所需的绝大部分程序。</p><p></p><pre class=\"crayon-plain-tag\">$ sudo apt install build-essential</pre><p></p><p style=\"text-align: justify\">这要花几分钟。如果你想更加深入地了解，你可以分别安装 gcc、gdb、make、flex、bison 以及 NetHack 文档中提到的其它工具。不过如果你是一位开发者，有时候你可能还需要一些其它工具。 build-essential 基本上提供了你所需的工具集。</p><p style=\"text-align: justify\">然后，安装 git。如你所想，很容易：</p><p></p><pre class=\"crayon-plain-tag\">$ sudo apt install git</pre><p></p><p style=\"text-align: justify\">就像在 Linux 中一样，你可以添加一个 git 的 PPA 来获取较新的版本，不过这里我们有一个就行了。</p><p style=\"text-align: justify\">最后，我们需要安装 curses（实际上是 ncurses）来进行终端屏幕交互。</p><p></p><pre class=\"crayon-plain-tag\">$ sudo apt install libncurses-dev</pre><p></p><p style=\"text-align: justify\">当我们完成这些步骤之后，就可以开始构建 NetHack 了。</p><h4 style=\"text-align: justify\">构建 NetHack</h4><p style=\"text-align: justify\">官方的 NetHack 仓库放在 <a href=\"https://github.com/NetHack/NetHack\">GitHub</a> 上，首先我们需要把它抓取下来放到我们的主目录里面。</p><p></p><pre class=\"crayon-plain-tag\">$ cd ~$ git clone http://github.com/NetHack/NetHack</pre><p></p><p style=\"text-align: justify\"><img src=\"http://jbcdn2.b0.upaiyun.com/2016/07/5d751b6d3dccf35a8c949227f7cabf36.png\" alt=\" \" width=\"906\" height=\"225\" /></p><p style=\"text-align: justify\">因为 NetHack 支持很多种操作系统，所以我们需要做一些基础配置来告诉它我们使用的是 Linux，并且用开源的 gcc 代替了了 Unix 上 cc 的作用。</p><p style=\"text-align: justify\">如我所提到的，这有好几种办法可以实现。有些人想很周到，将这些配置信息放到了 hints 文件中。相信我，使用 hints 文件会避免遇到该 GitHub 仓库中提到的很多麻烦。在 README 文件和其它文档中并没有着重提到如何使用 hints 文件，我们可以这样做：</p><p></p><pre class=\"crayon-plain-tag\">$ cd NetHack/sys/unix
$ ./setup.sh hints/linux</pre><p></p><p style=\"text-align: justify\">这将会设置 Makefile 正确的使用 Linux 下的工具、库及其路径。这个设置脚本很强大，它做了大量的配置工作，很高兴它在 WSL 中工作的也很好。如果你很好奇这个脚本是如何写的，你可以使用你的编辑器打开它一窥究竟。</p><p style=\"text-align: justify\">然后，开始最终的构建：</p><p></p><pre class=\"crayon-plain-tag\">$ cd ~/NetHack
$ make all</pre><p></p><p style=\"text-align: justify\">构建完成之后，你需要安装它。这其实就是将可执行文件复制到目标位置：</p><p></p><pre class=\"crayon-plain-tag\">$ make install</pre><p></p><p style=\"text-align: justify\">它会安装到你的 ~/nh 文件夹下， NetHack 放在 ~/nh/install/games 目录，名为 nethack。要运行它，切换到该目录（或输入完整路径）并输入：</p><p></p><pre class=\"crayon-plain-tag\">$ cd ~/nh/install/games
$ nethack</pre><p></p><p style=\"text-align: justify\">然后，屏幕会清屏并显示你可以玩 NetHack 了。注意，所有的东西都是在这个 Ubuntu Linux 环境中完成的，根本不需要任何 Windows 特有的东西。</p><h4 style=\"text-align: justify\">玩 NetHack</h4><p style=\"text-align: justify\">由于终端游戏的局限性和 NetHack 的复杂性，这里只能一带而过。对于初次接触它的人来说，还有一些神秘的地方，不过我觉得我们程序员们从来不怕挑战未知。</p><p style=\"text-align: justify\">方向键和 vi（vim）中的一样，HJKL 是左、下、上、右。要退出游戏，你可以在地下城顶层找到楼梯出口然后使用它就可以，或者直接按下 CTRL-C 强制退出。</p><p style=\"text-align: justify\">在 NetHack 中， @ 符号代表你自己，每一层都由房间、走廊、门，和向上及向下的楼梯组成。<a href=\"https://nethackwiki.com/wiki/Monster\">怪物</a>、<a href=\"https://nethackwiki.com/wiki/Item\">宝箱和物品</a>以各种 ASCII  字符组成，你慢慢就会熟悉它们。为了符合 Roguelikes 游戏规范，并没有存盘功能，你只有一条命。如果你死了就只能重玩，地下城环境是随机生成的，各种物品也是打乱放置的。</p><p style=\"text-align: justify\">NetHack 游戏的目的是在地下城生存，收集金子和物品，尽可能的干掉各种怪物。除了这些目的之外，你就是不断在其中玩来找它们。规则大致遵循“龙与地下城（DnD）”的武器、技能等规则。</p><p style=\"text-align: justify\">下面的 NetHack 截屏上可以看到有三个房间和两个走廊。向上的楼梯在左上角的房间里，我现在在右上角的房间，还有一些宝箱和其它物品。</p><p style=\"text-align: justify\"><img src=\"http://jbcdn2.b0.upaiyun.com/2016/07/0444a5ac1c36099fab318f6f218b3543.png\" alt=\" \" width=\"938\" height=\"540\" /></p><p style=\"text-align: justify\">如果在你的游戏中没有显示颜色，可以创建一个名为 ~/.nethackrc 的文件，并放入如下内容：</p><p></p><pre class=\"crayon-plain-tag\">OPTIONS=color:true,dark_room:true,menucolors:true</pre><p></p><p style=\"text-align: justify\">注：如果 ASCII 字符图形不是你的菜，但是你喜欢这种类型的游戏，你可以在微软商店搜索“roguelike”来找到视觉上更好看的这种游戏。</p><p style=\"text-align: justify\">当然，NetHack 很古老了，可能只有特定年龄段的人们喜欢它。不过，构建它用到了大量重要的开发工具和 *nix 操作系统功能，也包括终端模拟功能。从这里可以看到，从 gcc、gdb、make、bison 和 flex 到更现代一些的 git，都在 WSL 里面工作的很好。</p><p style=\"text-align: justify\">如果你想看看 Build Tour 大会上的演示，你可以在 Build Tour 加拿大大会上看到这个讲演。WSL 的这部分演示在 6:20 开始。</p><p style=\"text-align: justify\">希望你能喜欢在 NetHack 地下城中的探险。</p><blockquote><p>C 和 C++ 都很伟大，就像其他的那些经典的开发工具一样。你甚至还可以用普通的 Bash 脚本做到很多。不过，也有很多开发者喜欢用 Python 做为他们的脚本语言。</p></blockquote><h3 style=\"text-align: justify\">Python</h3><p style=\"text-align: justify\">你可以在网上找到很多 Python 脚本的例子，这意味着 Python 越来越流行，也越来越有用了。当然，大多数情况下这些例子都是运行在 Linux 下的。在过去，这就需要我们有另外一台安装着 Linux 的机器来运行它们，或者使用虚拟机和多引导，否则就需要修改一些东西才能让他们运行在 Windows 下的 Python 环境中。</p><p style=\"text-align: justify\">这是都不是无法解决的问题，但是它会日渐消磨开发人员每天的生活。通过 WSL，不用折腾你就拥有了一个兼容的、具有 Python 功能和 shell 变量的子系统。</p><p style=\"text-align: justify\">要安装最新的 Python 开发版本和 Python 包安装器 pip，在 Bash 中执行如下命令：</p><p></p><pre class=\"crayon-plain-tag\">$ sudo apt install python-pip python-dev
$ sudo pip install --upgrade pip</pre><p></p><p style=\"text-align: justify\">现在 Python 安装好了，我要展示给你如何从网上获取一个典型的 Linux 下的 Python 例子并让它直接工作起来。我去 <a href=\"http://code.activestate.com/recipes/langs/python/?query_start=1\">Activestate Python 菜谱站</a>找一个排名第一的 Python 例子。好吧，我走眼了，排名第一的是打印出整数名称的脚本，这看起来没啥意思，所以我选择了第二名：俄罗斯方块。我们每天都能看到 Python 出现在各种地方，所以这次让我们去玩另外一个游戏。</p><p style=\"text-align: justify\"><img src=\"http://jbcdn2.b0.upaiyun.com/2016/07/7a3462bf51dfc902a3fc42170364562f.png\" alt=\" \" width=\"800\" /></p><p style=\"text-align: justify\">我打开了 nano 编辑器，从 Windows 上的浏览器中打开的页面上复制了这 275 行 Python 代码，然后粘贴到我的 WSL 终端窗口终端中的 nano 中，并保存为 tetris.py ，然后执行它：</p><p></p><pre class=\"crayon-plain-tag\">$ python tetris.py</pre><p></p><p style=\"text-align: justify\">它马上就清屏并出现了俄罗斯方块的游戏。同 NetHack 一样，你可以使用同样的 vi 标准的方向键来移动（以前是使用鼠标和 WSAD 键来移动，而右手使用 HJKL 键更方便）。</p><p style=\"text-align: justify\"><img src=\"http://jbcdn2.b0.upaiyun.com/2016/07/6f239710255586c43a466f9d1a46cf41.png\" alt=\" \" width=\"325\" height=\"560\" /></p><p style=\"text-align: justify\">如我所提到的，你当然可以不用 WSL 就在 Windows 中运行 Python。然而，要想快速简便，不用修改 Linux 下的 Python 代码，只需要简单的复制粘贴代码即可运行，则可以极大的提高开发者的效率。</p><p style=\"text-align: justify\">这是真的。这并不是要替代 Windows 原生的工具，比如 Python、PowerShell、C# 等等，而是当你需要在现代的开发工作流程中快速而有效地完成一些事情时，可以避免种种折腾。</p><p style=\"text-align: justify\">包括 Bash、Python 以及其它所有的 Linux 原生的命令行开发工具，WSL 为我的开发工作提供了所有需要的工具。这不是一个 Linux 服务器，甚至也不是一个完整的客户端，相反，它就是一个可以让我避免每天折腾，让我在 Windows 上开发更有效率、更有快感的一个东西！</p><hr /><h3 style=\"text-align: justify\">重置你的 WSL 环境</h3><p style=\"text-align: justify\">随便去试吧，如果你搞坏了你的 WSL 环境，它很容易重新安装。在进行之前，请确保做好了任何重要内容的备份。</p><p></p><pre class=\"crayon-plain-tag\">C:&gt; lxrun.exe /uninstall /full
C:&gt; lxrun.exe /install</pre><p></p><h3 style=\"text-align: justify\">你使用 Bash 和 WSL 的感觉如何？</h3><p style=\"text-align: justify\">我们希望 WSL ，特别是 Bash 可以在 Windows 10 中帮你带来更高的效率，减少每天的开发中的折腾。</p><p style=\"text-align: justify\">你对 Windows 10 上的 WSL 怎么看？你喜欢使用它吗？</p><p style=\"text-align: justify\">开发团队做了大量的工作希望让 WSL 成为一个为开发者提供的强大的终端工具。如果你有任何反馈或运行出现问题，我们推荐你查看一下 <a href=\"https://github.com/Microsoft/BashOnWindows/issues\">GitHub 反馈页面</a>，以及 <a href=\"https://wpdev.uservoice.com/forums/266908-command-prompt-console-bash-on-ubuntu-on-windo\">用户之声的反馈和投票站点</a>。我们真的希望听到你的声音。</p><h3 style=\"text-align: justify\">更多参考与延伸阅读</h3><p style=\"text-align: justify\">Linux shell 编程是一个庞大的话题，在网上有很多这方面的内容。如果你还不够熟悉它们，想要了解更多，可以看看各种 Bash 教程。<a href=\"https://help.ubuntu.com/community/Beginners/BashScripting\">可以从这一份开始</a>。</p><p style=\"text-align: justify\">还有一些其他的参考资料也许对你有用：</p><ul style=\"text-align: justify\"><li><a href=\"https://channel9.msdn.com/Events/Build/Build-Tour-2016-Toronto\">Build Tour videos</a></li><li><a href=\"https://help.ubuntu.com/community/Beginners/BashScripting\">Bash Scripting 101</a></li><li><a href=\"https://msdn.microsoft.com/commandline/wsl/\">WSL Home</a></li><li><a href=\"https://blogs.msdn.microsoft.com/commandline/2016/06/02/learn-more-about-bash-on-ubuntu-on-windows-and-the-windows-subsystem-for-linux/\">WSL Overview</a></li><li><a href=\"https://msdn.microsoft.com/en-us/commandline/wsl/faq#how-do-i-update-bash-on-ubuntu-on-windows-\">WSL FAQ</a></li><li><a href=\"https://blogs.msdn.microsoft.com/wsl/2016/06/08/wsl-system-calls/\">WSL System Calls</a></li><li><a href=\"http://www.hanselman.com/blog/VIDEOHowToRunLinuxAndBashOnWindows10AnniversaryUpdate.aspx\">Scott Hanselman’s video on how to run WSL</a></li></ul><p style=\"text-align: justify\">哦，当然，要更多的了解 NetHack，请访问 <a href=\"http://www.nethack.org/\">NetHack 主站</a>。</p><div class=\"wp_rp_wrap  wp_rp_plain\" ><div class=\"wp_rp_content\"><h3 class=\"related_post_title\">相关文章</h3><ul class=\"related_post wp_rp\" style=\"visibility: visible\"><li ><a href=\"http://blog.jobbole.com/97676/\" class=\"wp_rp_title\">基于 JavaScript 的操作系统你听说过吗？</a></li><li ><a href=\"http://blog.jobbole.com/93132/\" class=\"wp_rp_title\">Linux Shell 管道命令(pipe)使用及与 Shell 重定向区别</a></li><li ><a href=\"http://blog.jobbole.com/92792/\" class=\"wp_rp_title\">Linux Shell 创建序列数组</a></li><li ><a href=\"http://blog.jobbole.com/104042/\" class=\"wp_rp_title\">如何在 Linux 下检测内存泄漏</a></li><li ><a href=\"http://blog.jobbole.com/40278/\" class=\"wp_rp_title\">如何在安装双启动后卸载 Windows 或者 Linux</a></li><li ><a href=\"http://blog.jobbole.com/98633/\" class=\"wp_rp_title\">StackOverflow 这么大，它的架构是怎么样的？</a></li><li ><a href=\"http://blog.jobbole.com/29668/\" class=\"wp_rp_title\">Ubuntu桌面生存指南(2)：Ubuntu桌面体验简介</a></li><li ><a href=\"http://blog.jobbole.com/31614/\" class=\"wp_rp_title\">Learn Linux The Hard Way/笨办法学Linux</a></li><li ><a href=\"http://blog.jobbole.com/85341/\" class=\"wp_rp_title\">Windows 10 VS. Linux</a></li><li ><a href=\"http://blog.jobbole.com/48195/\" class=\"wp_rp_title\">如何保证Linux服务器的安全</a></li></ul></div></div><p><a href=\"http://blog.jobbole.com/104012/\">玩转 Windows 10 中的 Linux 子系统</a>，首发于<a href=\"http://blog.jobbole.com\">文章 - 伯乐在线</a>。</p>" "http://blog.jobbole.com/104012/" (22429 31055) old 20 nil nil ((title nil "玩转 Windows 10 中的 Linux 子系统") (link nil "http://blog.jobbole.com/104012/") (comments nil "http://blog.jobbole.com/104012/#respond") (pubDate nil "Sun, 31 Jul 2016 04:06:39 +0000") (dc:creator nil "ABOER") (category nil "IT技术") (category nil "Linux") (guid ((isPermaLink . "false")) "http://blog.jobbole.com/?p=104012") (description nil "<p>在今年的 Build 2016 上，微软向全世界介绍了他们还处于 Beta 阶段的 Windows 下的 Linux 子系统WSL，它可以让开发者们在 Windows 10 下通过 Bash shell 运行原生的 Ubuntu 用户态二进制程序。如果你参与了 Windows Insider 计划，你就可以在最新的 Windows 10 年度升级版的 Insider 构建版中体验这个功能了。</p><p><a href=\"http://blog.jobbole.com/104012/\">玩转 Windows 10 中的 Linux 子系统</a>，首发于<a href=\"http://blog.jobbole.com\">文章 - 伯乐在线</a>。</p>") (content:encoded nil "<p style=\"text-align: justify\">在今年的 Build 2016 上，微软向全世界<a href=\"https://linux.cn/article-7177-1.html\">介绍了</a>他们还处于 Beta 阶段的 Windows 下的 Linux 子系统（Windows Subsystem for Linux）（WSL），它可以让开发者们在 Windows 10 下通过 Bash shell 运行原生的 Ubuntu 用户态二进制程序。如果你参与了 Windows Insider 计划，你就可以在最新的 Windows 10 年度升级版的 Insider 构建版中体验这个功能了。</p><p style=\"text-align: justify\">Web 开发人员们不用再苦恼所用的 Windows 开发平台上没有合适的 Linux 工具和库了。WSL 是由 Windows 内核团队与 Canonical 合作设计和开发的，可以让 Windows 10 下的开发者们在拥有 Windows 中那些强力支持之外，还能使用 Linux 下丰富的开发环境与工具，而不用启动到另外的操作系统或者使用虚拟机。这绝对是一个“来自开发者，服务开发者”的 Windows 10 特色，它的目的是让开发者们每天的开发工作都变得顺畅而便捷。</p><p style=\"text-align: justify\">在本文中，我会展示给你一些我认为非常有趣的功能，以及告诉你一些可以让你找到更多信息的资源。首先，我会展示 WSL 所集成的那些主要命令（比如 ssh）是如何操作服务器和设备的。其次，我会演示使用 Bash 脚本是如何以简明的方式来自动化执行任务的。其三，我会利用极棒的命令行编译器、一些其它工具以及对 *nix 兼容的能力来玩一个轻量级的古典黑客级游戏： NetHack。最后，我会展示如何使用已有的 Python 脚本和其它来自网上的脚本。</p><blockquote><p>从我的第一台 286 上运行的 Windows 3.0 开始，Windows 就一直是我的主要操作系统和开发环境。不过，我身边也有很多 Linux 服务器和设备。从树莓派和路由器/网关设备这样的物联网设备，到 Minecraft 服务器，它们堆满了我的办公室的每个角落。而我经常要从我的主工作站中去管理和配置这些 Linux 计算机。</p></blockquote><h3 style=\"text-align: justify\">管理服务器和设备</h3><p style=\"text-align: justify\">我在我的家中运行着一台无显示器的 Ubuntu Minecraft 服务器，这是我去年给我十岁大的儿子的圣诞礼物，但是它已经变成了我的玩具而不是他的（好吧，主要是我的玩具）。我以前在我的 Windows 10 电脑上使用几个客户端来管理它，不过我现在想使用 Windows 中的 Bash 里面的 ssh 命令行来管理它。使用类似 PuTTY 或来自 Cygwin 的 Tera Term 这样的应用当然也可以，但是我想试试真正原生而自然的体验也是一种不错的选择。Cygwin 就像是在披萨店订购的披萨一样，好吃，但是没有那种氛围。</p><p style=\"text-align: justify\">我已经使用 WSL 中的 <code>ssh-keygen</code> 和 <code>ssh-copy-id</code> 设置好了公私密钥对，所以使用 ssh 只需要如下简单输入即可：</p><p></p><pre class=\"crayon-plain-tag\">$ ssh &lt;username&gt;@&lt;server&gt;</pre><p></p><p style=\"text-align: justify\">我还为此创建了一个别名，以便更快一些。这是一个标准的 Linux/Bash 功能：</p><p></p><pre class=\"crayon-plain-tag\">$ alias mc='ssh &lt;user&gt;@&lt;server&gt;'</pre><p></p><p style=\"text-align: justify\">现在，我要访问我的 Minecraft 服务器只需要在 Windows 10 下的 Bash 中输入“mc”即可。</p><p style=\"text-align: justify\"><img src=\"http://jbcdn2.b0.upaiyun.com/2016/07/e2775253ec67d3de168cbeafda33e5ba.png\" alt=\" \" width=\"785\" height=\"603\" /></p><p style=\"text-align: justify\">当然，同样的方法你也可以用于任何 Linux 上的 Web 或数据库服务器上，甚至树莓派或其它的物联网设备也可以。</p><blockquote><p>在终端里面进行 ssh 只是为了方便而已，不过当你在 shell 中工作时，如果还有类似 apt、node、Ruby、Python 等等工具时，你就有了自动化各种工作的可能。</p></blockquote><h3 style=\"text-align: justify\">远程脚本</h3><p style=\"text-align: justify\">假如说你有一大堆 Linux 服务器和设备，而你要在它们上面执行一个远程命令的话，如果已经配置好公私密钥对，你就可以在 Bash 中直接远程执行命令。</p><p style=\"text-align: justify\">举个例子说，想知道远程服务器自从上次重启后已经运行了多长时间了，你只需要输入：</p><p></p><pre class=\"crayon-plain-tag\">$ ssh &lt;user&gt;@&lt;server&gt; 'last -x|grep reboot'</pre><p></p><p style=\"text-align: justify\">ssh 会连接到该服务器并执行 <code>last -x</code> 命令，然后搜索包含“reboot”的一行。我在我的 Ubuntu Minecraft 服务器上运行的结果如下：</p><p></p><pre class=\"crayon-plain-tag\">reboot   system boot  4.4.0-28-generic Thu Jul  7 08:14   still running</pre><p></p><p style=\"text-align: justify\">这只是一台服务器，如果你有许多服务器的话，你可以自动化这个过程。我在 WSL 里我的主目录下创建了一个名为 servers.txt 的文件，它包含了一系列 Linux 服务器/设备的名称，每个一行。然后我就可以创建一个脚本来读取这个文件。</p><p style=\"text-align: justify\">在使用了很多年像树莓派这样的设备之后，我已经变成了一个 nano 人（在 VMS 上我是一个 LSEdit 人），下面是我用我喜爱的 nano 编辑器打开的脚本。</p><p style=\"text-align: justify\"><img src=\"http://jbcdn2.b0.upaiyun.com/2016/07/4b3f3d4144ed32d597a063b9915dc18d.png\" alt=\" \" width=\"836\" height=\"268\" /></p><p style=\"text-align: justify\">当然，你也可以使用 vim 、 emacs 或者其它可以用在 Ubuntu 终端上的编辑器。</p><p style=\"text-align: justify\">该脚本是 Bash 脚本，要执行该脚本，输入：</p><p></p><pre class=\"crayon-plain-tag\">$ ./foreachserver.sh 'last -x|grep reboot'</pre><p></p><p style=\"text-align: justify\">它将迭代输出文件中的每个服务器/设备，然后通过 ssh 远程执行该命令。当然，这个例子非常简单，但是你可以像这样把你的本地脚本或其它命令变成远程的。Bash 脚本语言足够丰富，所以你可以使用它来完成你的大多数远程管理任务。你可以用你下载到 WSL 或远程系统中的其它应用来扩展它的使用。</p><blockquote><p>你是否需要在工作中把本地的 Windows 文件或资源用于其它的 Linux 计算机吗？或者，你根本不使用 Linux ？Bash 可以操作本地的 Windows 文件或资源，还是说它就是一个完全独立的环境？</p></blockquote><h3 style=\"text-align: justify\">使用 Windows 文件</h3><p style=\"text-align: justify\">WSL 系统可以通过 <code>/mnt//</code> 目录（挂载点）来访问你计算机上的文件系统。举个例子，你的 Windows 上的 C: 和 D: 根目录可以在 WSL 中相应地通过 /mnt/c 和 /mnt/d 访问。当你要把你的 Windows 下的项目文件、下载的内容和其它文件用到 Linux/Bash 之中时这很有用。</p><p style=\"text-align: justify\"><img src=\"http://jbcdn2.b0.upaiyun.com/2016/07/1701666cc539d37cc44e132663c3835b.png\" alt=\" \" width=\"604\" height=\"193\" /></p><p style=\"text-align: justify\">上图显示的两个目录分别对应于我的计算机上的 SSD 和硬盘：</p><p style=\"text-align: justify\"><img src=\"http://jbcdn2.b0.upaiyun.com/2016/07/bab4932042fba9e803e88a829b6a200a.png\" alt=\" \" width=\"556\" height=\"104\" /></p><p style=\"text-align: justify\">这是逻辑挂载，所以当你在 shell 中使用类似 <code>mount</code> 这样的命令时它们不会显示。但是它们可以如你预期的那样工作。举个例子，在 Windows 中，我在我的 C 盘根目录下放了一个名为 test.txt 的文件，我可以在 WSL 中如下访问它：</p><p style=\"text-align: justify\"><img src=\"http://jbcdn2.b0.upaiyun.com/2016/07/06344269f0e21908b291acf215d98ba0.png\" alt=\" \" width=\"774\" height=\"151\" /></p><p style=\"text-align: justify\">在 Build  Tour 大会期间，我们要确保所有的演示都可以在没有互联网时也能正常工作（你绝不会知道会场的网络是什么样子的） ，所以为了让 Bash/WSL 可以演示 Git 操作，该演示访问的是本地计算机上的 Windows 文件，我在 Windows 上的 C:gitNetHack 下设置一个本地仓库。 要在 WSL 中进行 clone 操作，我执行了如下命令：</p><p></p><pre class=\"crayon-plain-tag\">$ git –clone file:///mnt/c/git/NetHack</pre><p></p><p style=\"text-align: justify\">该命令告诉 git 使用 <code>file://</code> 协议，并 clone 了位于 /mnt/c/git/NetHack 下的仓库。你可以以类似的方式来访问你的 Windows 下的所有文件。</p><p style=\"text-align: justify\">警示：就像在其它终端中一样，如果你不小心的话，你可以在 Bash 中修改/删除 Windows 文件系统中的文件。举个例子，你可以像下面这样来干掉你的 Windows ，假如你有合适的权限的话。</p><p></p><pre class=\"crayon-plain-tag\">$ rm -rf /mnt/c/  [千万别试！][千万别试！][千万别试！]</pre><p></p><p style=\"text-align: justify\">我之所以郑重提醒是因为我们很多人都是刚刚接触 Linux 命令，它们不是 Windows 命令。</p><p style=\"text-align: justify\">这种可以让文件系统集成到一起的魔法来自 DrvFs。如果你希望了解该文件系统的更多细节，以及它是如何工作在 WSL 中的，WSL 团队为此写了一篇<a href=\"https://blogs.msdn.microsoft.com/wsl/2016/06/15/wsl-file-system-support/\">详细的文章</a>。</p><blockquote><p>当然， 文件系统访问只是 WSL 其中的一部分功能而已，许多开发任务还需要通过 HTTP 或其它网络协议访问远程资源。</p></blockquote><h3 style=\"text-align: justify\">发起 HTTP 请求</h3><p style=\"text-align: justify\">从脚本或命令行而不是从一个编译好的程序或 Web 页面上发起 REST 或其它 HTTP（或 FTP）请求是很有用的。就像在大多数 Linux 发行版一样，WSL 也包括了类似 curl 或 wget 获取资源这样的标准功能，它们可以用来发起 HTTP 或者其它网络请求。举个例子，下面是使用 curl 对 Github 发起 REST 请求来获取我个人的属性信息：</p><p></p><pre class=\"crayon-plain-tag\">$ curl -i https://api.github.com/users/Psychlist1972
HTTP/1.1 200 OK
Server: GitHub.com
Date: Wed, 13 Jul 2016 02:38:08 GMT
Content-Type: application/json; charset=utf-8
Content-Length: 1319
Status: 200 OK
...
{
  \"login\": \"Psychlist1972\",
  \"avatar_url\": \"https://avatars.githubusercontent.com/u/1421146?v=3\",
  \"url\": \"https://api.github.com/users/Psychlist1972\",
  \"name\": \"Pete Brown\",
  \"company\": \"Microsoft\",
   ...
}
$</pre><p></p><p style=\"text-align: justify\">你可以用它和 Bash 脚本来创建一个 REST API 的快速测试客户端，也可以用来探测一个 Web 页面或服务器并报告其返回的状态。它用来从网上下载文件也很棒，你可以简单地重定向输出到一个文件而不是在屏幕上显示它：</p><p></p><pre class=\"crayon-plain-tag\">$ curl -i https://api.github.com/users/Psychlist1972 &gt; pete.json</pre><p></p><p style=\"text-align: justify\">我也是一个 PowerShell 用户，甚至还使用 <a href=\"https://github.com/Psychlist1972/Windows-10-PowerShell-MIDI\">Windows 10 MIDI in PowerShell</a> 创建了一些有趣的扩展，也<a href=\"https://github.com/Psychlist1972/Fix-SoundDevices-File-Corruption\">修复</a>过出现在特定的录音硬件设备上的一些文件问题。作为长时间的 .NET 开发者和爱好者，我经常使用和扩展 PowerShell 以满足我的项目需求。但是  PowerShell 并不是一个可以运行所有的那些 Bash 脚本和针对 Linux 的开源工具的地方。我希望以一种最简单、最舒服的方式来完成这些任务，在某种意义上，这意味着我们需要在 Bash 中完成它们。</p><blockquote><p>我已经一掠而过的介绍了 Bash、Bash 脚本以及你可以在 shell 中完成的任务。到目前为止，我谈论的都是有助于开发工作的那些功能。但是在 WSL 中实际的开发和编译工作是怎样的？我在 Build Tour 大会上演示了下面这个部分。</p></blockquote><h3 style=\"text-align: justify\">Build Tour 大会上的演示：NetHack</h3><p style=\"text-align: justify\">这个夏初，来自微软的讲演者们向大家演示了一些来自 Windows 和微软云上的很酷的开发者新功能。作为其中的一部分，我以一种好玩的方式来演示了 WSL，而且这是一种和开发者们相关的方式。</p><p style=\"text-align: justify\">我个人想要展示使用 git 和一些传统的终端开发工具，我已经写好了 Bash 的演示程序，包括了这些基础的东西（用 Python 和 Ruby 写的“Hello World”），不过我还是想要更有冲击力一些。</p><p style=\"text-align: justify\">我回想起我在大学的时光，那时我们在 Unix（DEC Ultrix 及 SunOS）和 VAX/VMS 之间折腾，Unix 几乎全是命令行环境。在我们学校，绝大多数使用图形工作站的用户只是为了在不同的窗口打开多个终端会话而已，当然，会在桌面背景放上一张超酷的月相图。大部分学生都是使用 VT-220 终端来打开他们的会话（学校离波士顿不远，所以我们有很多 DEC 设备）。</p><p style=\"text-align: justify\">那时，计算机系的学生们主要玩两大游戏：MUD （主要是 lpMUD 和当时刚出的 DikuMUD）和 <a href=\"https://en.wikipedia.org/wiki/NetHack\">NetHack</a>。NetHack 和其它的 <a href=\"https://en.wikipedia.org/wiki/Roguelike\">Roguelikes</a> 类游戏被视为历史上最有影响力的游戏之一，它们是许多现在流行的地牢冒险和角色扮演类游戏的鼻祖。</p><p style=\"text-align: justify\">NetHack 有很长的历史，现在的它包含了来自几十年前的几十万行 *nix 代码，以及后来补充的一些代码。该游戏使用 <a href=\"https://en.wikipedia.org/wiki/Curses_(programming_library)\">curses</a> （及其替代品）作为终端交互方式，需要通过 lex、 yacc（或 flex 和 bison）和 cc（或 gcc），以及一堆其它的开发工具构建。</p><p style=\"text-align: justify\">它是由 C 语言编写的，并包括了一些用 <a href=\"https://en.wikipedia.org/wiki/Bourne_shell\">Bourne shell</a> 编写的复杂的脚本配置功能。我觉得它是一个体现 WSL 和 Bash on Windows 10 的开发者能力的不错而有趣的方式。由于使用了 curses（在 Linux 和 WSL 中是 libncurses 库），它也可以用来展示 Windows 10 中命令行窗口中的终端模拟能力。</p><p style=\"text-align: justify\">以前，在我们的分时 Ultrix 服务器上从源代码构建 NetHack 要花费掉我们很多时间，而现在我的个人计算机上只需要几分钟就可以搞定。我喜欢这种技术进步。在 Linux 或 WSL 上配置和编译 NetHack 有容易和复杂两种方式。为了节省时间，我们会以容易的方式来进行。</p><h4 style=\"text-align: justify\">前置需求</h4><p style=\"text-align: justify\">首先，更新你的 WSL 环境，确保你的软件是最新的。在安装新的软件包之前，这是一个好的做法。</p><p></p><pre class=\"crayon-plain-tag\">$ sudo apt update
$ sudo apt upgrade</pre><p></p><p style=\"text-align: justify\">然后，安装必须的开发工具。最简单的办法就是使用 build-essential 软件包，它包括了 Linux 开发者构建以 C/C++ 开发的软件时所需的绝大部分程序。</p><p></p><pre class=\"crayon-plain-tag\">$ sudo apt install build-essential</pre><p></p><p style=\"text-align: justify\">这要花几分钟。如果你想更加深入地了解，你可以分别安装 gcc、gdb、make、flex、bison 以及 NetHack 文档中提到的其它工具。不过如果你是一位开发者，有时候你可能还需要一些其它工具。 build-essential 基本上提供了你所需的工具集。</p><p style=\"text-align: justify\">然后，安装 git。如你所想，很容易：</p><p></p><pre class=\"crayon-plain-tag\">$ sudo apt install git</pre><p></p><p style=\"text-align: justify\">就像在 Linux 中一样，你可以添加一个 git 的 PPA 来获取较新的版本，不过这里我们有一个就行了。</p><p style=\"text-align: justify\">最后，我们需要安装 curses（实际上是 ncurses）来进行终端屏幕交互。</p><p></p><pre class=\"crayon-plain-tag\">$ sudo apt install libncurses-dev</pre><p></p><p style=\"text-align: justify\">当我们完成这些步骤之后，就可以开始构建 NetHack 了。</p><h4 style=\"text-align: justify\">构建 NetHack</h4><p style=\"text-align: justify\">官方的 NetHack 仓库放在 <a href=\"https://github.com/NetHack/NetHack\">GitHub</a> 上，首先我们需要把它抓取下来放到我们的主目录里面。</p><p></p><pre class=\"crayon-plain-tag\">$ cd ~$ git clone http://github.com/NetHack/NetHack</pre><p></p><p style=\"text-align: justify\"><img src=\"http://jbcdn2.b0.upaiyun.com/2016/07/5d751b6d3dccf35a8c949227f7cabf36.png\" alt=\" \" width=\"906\" height=\"225\" /></p><p style=\"text-align: justify\">因为 NetHack 支持很多种操作系统，所以我们需要做一些基础配置来告诉它我们使用的是 Linux，并且用开源的 gcc 代替了了 Unix 上 cc 的作用。</p><p style=\"text-align: justify\">如我所提到的，这有好几种办法可以实现。有些人想很周到，将这些配置信息放到了 hints 文件中。相信我，使用 hints 文件会避免遇到该 GitHub 仓库中提到的很多麻烦。在 README 文件和其它文档中并没有着重提到如何使用 hints 文件，我们可以这样做：</p><p></p><pre class=\"crayon-plain-tag\">$ cd NetHack/sys/unix
$ ./setup.sh hints/linux</pre><p></p><p style=\"text-align: justify\">这将会设置 Makefile 正确的使用 Linux 下的工具、库及其路径。这个设置脚本很强大，它做了大量的配置工作，很高兴它在 WSL 中工作的也很好。如果你很好奇这个脚本是如何写的，你可以使用你的编辑器打开它一窥究竟。</p><p style=\"text-align: justify\">然后，开始最终的构建：</p><p></p><pre class=\"crayon-plain-tag\">$ cd ~/NetHack
$ make all</pre><p></p><p style=\"text-align: justify\">构建完成之后，你需要安装它。这其实就是将可执行文件复制到目标位置：</p><p></p><pre class=\"crayon-plain-tag\">$ make install</pre><p></p><p style=\"text-align: justify\">它会安装到你的 ~/nh 文件夹下， NetHack 放在 ~/nh/install/games 目录，名为 nethack。要运行它，切换到该目录（或输入完整路径）并输入：</p><p></p><pre class=\"crayon-plain-tag\">$ cd ~/nh/install/games
$ nethack</pre><p></p><p style=\"text-align: justify\">然后，屏幕会清屏并显示你可以玩 NetHack 了。注意，所有的东西都是在这个 Ubuntu Linux 环境中完成的，根本不需要任何 Windows 特有的东西。</p><h4 style=\"text-align: justify\">玩 NetHack</h4><p style=\"text-align: justify\">由于终端游戏的局限性和 NetHack 的复杂性，这里只能一带而过。对于初次接触它的人来说，还有一些神秘的地方，不过我觉得我们程序员们从来不怕挑战未知。</p><p style=\"text-align: justify\">方向键和 vi（vim）中的一样，HJKL 是左、下、上、右。要退出游戏，你可以在地下城顶层找到楼梯出口然后使用它就可以，或者直接按下 CTRL-C 强制退出。</p><p style=\"text-align: justify\">在 NetHack 中， @ 符号代表你自己，每一层都由房间、走廊、门，和向上及向下的楼梯组成。<a href=\"https://nethackwiki.com/wiki/Monster\">怪物</a>、<a href=\"https://nethackwiki.com/wiki/Item\">宝箱和物品</a>以各种 ASCII  字符组成，你慢慢就会熟悉它们。为了符合 Roguelikes 游戏规范，并没有存盘功能，你只有一条命。如果你死了就只能重玩，地下城环境是随机生成的，各种物品也是打乱放置的。</p><p style=\"text-align: justify\">NetHack 游戏的目的是在地下城生存，收集金子和物品，尽可能的干掉各种怪物。除了这些目的之外，你就是不断在其中玩来找它们。规则大致遵循“龙与地下城（DnD）”的武器、技能等规则。</p><p style=\"text-align: justify\">下面的 NetHack 截屏上可以看到有三个房间和两个走廊。向上的楼梯在左上角的房间里，我现在在右上角的房间，还有一些宝箱和其它物品。</p><p style=\"text-align: justify\"><img src=\"http://jbcdn2.b0.upaiyun.com/2016/07/0444a5ac1c36099fab318f6f218b3543.png\" alt=\" \" width=\"938\" height=\"540\" /></p><p style=\"text-align: justify\">如果在你的游戏中没有显示颜色，可以创建一个名为 ~/.nethackrc 的文件，并放入如下内容：</p><p></p><pre class=\"crayon-plain-tag\">OPTIONS=color:true,dark_room:true,menucolors:true</pre><p></p><p style=\"text-align: justify\">注：如果 ASCII 字符图形不是你的菜，但是你喜欢这种类型的游戏，你可以在微软商店搜索“roguelike”来找到视觉上更好看的这种游戏。</p><p style=\"text-align: justify\">当然，NetHack 很古老了，可能只有特定年龄段的人们喜欢它。不过，构建它用到了大量重要的开发工具和 *nix 操作系统功能，也包括终端模拟功能。从这里可以看到，从 gcc、gdb、make、bison 和 flex 到更现代一些的 git，都在 WSL 里面工作的很好。</p><p style=\"text-align: justify\">如果你想看看 Build Tour 大会上的演示，你可以在 Build Tour 加拿大大会上看到这个讲演。WSL 的这部分演示在 6:20 开始。</p><p style=\"text-align: justify\">希望你能喜欢在 NetHack 地下城中的探险。</p><blockquote><p>C 和 C++ 都很伟大，就像其他的那些经典的开发工具一样。你甚至还可以用普通的 Bash 脚本做到很多。不过，也有很多开发者喜欢用 Python 做为他们的脚本语言。</p></blockquote><h3 style=\"text-align: justify\">Python</h3><p style=\"text-align: justify\">你可以在网上找到很多 Python 脚本的例子，这意味着 Python 越来越流行，也越来越有用了。当然，大多数情况下这些例子都是运行在 Linux 下的。在过去，这就需要我们有另外一台安装着 Linux 的机器来运行它们，或者使用虚拟机和多引导，否则就需要修改一些东西才能让他们运行在 Windows 下的 Python 环境中。</p><p style=\"text-align: justify\">这是都不是无法解决的问题，但是它会日渐消磨开发人员每天的生活。通过 WSL，不用折腾你就拥有了一个兼容的、具有 Python 功能和 shell 变量的子系统。</p><p style=\"text-align: justify\">要安装最新的 Python 开发版本和 Python 包安装器 pip，在 Bash 中执行如下命令：</p><p></p><pre class=\"crayon-plain-tag\">$ sudo apt install python-pip python-dev
$ sudo pip install --upgrade pip</pre><p></p><p style=\"text-align: justify\">现在 Python 安装好了，我要展示给你如何从网上获取一个典型的 Linux 下的 Python 例子并让它直接工作起来。我去 <a href=\"http://code.activestate.com/recipes/langs/python/?query_start=1\">Activestate Python 菜谱站</a>找一个排名第一的 Python 例子。好吧，我走眼了，排名第一的是打印出整数名称的脚本，这看起来没啥意思，所以我选择了第二名：俄罗斯方块。我们每天都能看到 Python 出现在各种地方，所以这次让我们去玩另外一个游戏。</p><p style=\"text-align: justify\"><img src=\"http://jbcdn2.b0.upaiyun.com/2016/07/7a3462bf51dfc902a3fc42170364562f.png\" alt=\" \" width=\"800\" /></p><p style=\"text-align: justify\">我打开了 nano 编辑器，从 Windows 上的浏览器中打开的页面上复制了这 275 行 Python 代码，然后粘贴到我的 WSL 终端窗口终端中的 nano 中，并保存为 tetris.py ，然后执行它：</p><p></p><pre class=\"crayon-plain-tag\">$ python tetris.py</pre><p></p><p style=\"text-align: justify\">它马上就清屏并出现了俄罗斯方块的游戏。同 NetHack 一样，你可以使用同样的 vi 标准的方向键来移动（以前是使用鼠标和 WSAD 键来移动，而右手使用 HJKL 键更方便）。</p><p style=\"text-align: justify\"><img src=\"http://jbcdn2.b0.upaiyun.com/2016/07/6f239710255586c43a466f9d1a46cf41.png\" alt=\" \" width=\"325\" height=\"560\" /></p><p style=\"text-align: justify\">如我所提到的，你当然可以不用 WSL 就在 Windows 中运行 Python。然而，要想快速简便，不用修改 Linux 下的 Python 代码，只需要简单的复制粘贴代码即可运行，则可以极大的提高开发者的效率。</p><p style=\"text-align: justify\">这是真的。这并不是要替代 Windows 原生的工具，比如 Python、PowerShell、C# 等等，而是当你需要在现代的开发工作流程中快速而有效地完成一些事情时，可以避免种种折腾。</p><p style=\"text-align: justify\">包括 Bash、Python 以及其它所有的 Linux 原生的命令行开发工具，WSL 为我的开发工作提供了所有需要的工具。这不是一个 Linux 服务器，甚至也不是一个完整的客户端，相反，它就是一个可以让我避免每天折腾，让我在 Windows 上开发更有效率、更有快感的一个东西！</p><hr /><h3 style=\"text-align: justify\">重置你的 WSL 环境</h3><p style=\"text-align: justify\">随便去试吧，如果你搞坏了你的 WSL 环境，它很容易重新安装。在进行之前，请确保做好了任何重要内容的备份。</p><p></p><pre class=\"crayon-plain-tag\">C:&gt; lxrun.exe /uninstall /full
C:&gt; lxrun.exe /install</pre><p></p><h3 style=\"text-align: justify\">你使用 Bash 和 WSL 的感觉如何？</h3><p style=\"text-align: justify\">我们希望 WSL ，特别是 Bash 可以在 Windows 10 中帮你带来更高的效率，减少每天的开发中的折腾。</p><p style=\"text-align: justify\">你对 Windows 10 上的 WSL 怎么看？你喜欢使用它吗？</p><p style=\"text-align: justify\">开发团队做了大量的工作希望让 WSL 成为一个为开发者提供的强大的终端工具。如果你有任何反馈或运行出现问题，我们推荐你查看一下 <a href=\"https://github.com/Microsoft/BashOnWindows/issues\">GitHub 反馈页面</a>，以及 <a href=\"https://wpdev.uservoice.com/forums/266908-command-prompt-console-bash-on-ubuntu-on-windo\">用户之声的反馈和投票站点</a>。我们真的希望听到你的声音。</p><h3 style=\"text-align: justify\">更多参考与延伸阅读</h3><p style=\"text-align: justify\">Linux shell 编程是一个庞大的话题，在网上有很多这方面的内容。如果你还不够熟悉它们，想要了解更多，可以看看各种 Bash 教程。<a href=\"https://help.ubuntu.com/community/Beginners/BashScripting\">可以从这一份开始</a>。</p><p style=\"text-align: justify\">还有一些其他的参考资料也许对你有用：</p><ul style=\"text-align: justify\"><li><a href=\"https://channel9.msdn.com/Events/Build/Build-Tour-2016-Toronto\">Build Tour videos</a></li><li><a href=\"https://help.ubuntu.com/community/Beginners/BashScripting\">Bash Scripting 101</a></li><li><a href=\"https://msdn.microsoft.com/commandline/wsl/\">WSL Home</a></li><li><a href=\"https://blogs.msdn.microsoft.com/commandline/2016/06/02/learn-more-about-bash-on-ubuntu-on-windows-and-the-windows-subsystem-for-linux/\">WSL Overview</a></li><li><a href=\"https://msdn.microsoft.com/en-us/commandline/wsl/faq#how-do-i-update-bash-on-ubuntu-on-windows-\">WSL FAQ</a></li><li><a href=\"https://blogs.msdn.microsoft.com/wsl/2016/06/08/wsl-system-calls/\">WSL System Calls</a></li><li><a href=\"http://www.hanselman.com/blog/VIDEOHowToRunLinuxAndBashOnWindows10AnniversaryUpdate.aspx\">Scott Hanselman’s video on how to run WSL</a></li></ul><p style=\"text-align: justify\">哦，当然，要更多的了解 NetHack，请访问 <a href=\"http://www.nethack.org/\">NetHack 主站</a>。</p><div class=\"wp_rp_wrap  wp_rp_plain\" ><div class=\"wp_rp_content\"><h3 class=\"related_post_title\">相关文章</h3><ul class=\"related_post wp_rp\" style=\"visibility: visible\"><li ><a href=\"http://blog.jobbole.com/97676/\" class=\"wp_rp_title\">基于 JavaScript 的操作系统你听说过吗？</a></li><li ><a href=\"http://blog.jobbole.com/93132/\" class=\"wp_rp_title\">Linux Shell 管道命令(pipe)使用及与 Shell 重定向区别</a></li><li ><a href=\"http://blog.jobbole.com/92792/\" class=\"wp_rp_title\">Linux Shell 创建序列数组</a></li><li ><a href=\"http://blog.jobbole.com/104042/\" class=\"wp_rp_title\">如何在 Linux 下检测内存泄漏</a></li><li ><a href=\"http://blog.jobbole.com/40278/\" class=\"wp_rp_title\">如何在安装双启动后卸载 Windows 或者 Linux</a></li><li ><a href=\"http://blog.jobbole.com/98633/\" class=\"wp_rp_title\">StackOverflow 这么大，它的架构是怎么样的？</a></li><li ><a href=\"http://blog.jobbole.com/29668/\" class=\"wp_rp_title\">Ubuntu桌面生存指南(2)：Ubuntu桌面体验简介</a></li><li ><a href=\"http://blog.jobbole.com/31614/\" class=\"wp_rp_title\">Learn Linux The Hard Way/笨办法学Linux</a></li><li ><a href=\"http://blog.jobbole.com/85341/\" class=\"wp_rp_title\">Windows 10 VS. Linux</a></li><li ><a href=\"http://blog.jobbole.com/48195/\" class=\"wp_rp_title\">如何保证Linux服务器的安全</a></li></ul></div></div><p><a href=\"http://blog.jobbole.com/104012/\">玩转 Windows 10 中的 Linux 子系统</a>，首发于<a href=\"http://blog.jobbole.com\">文章 - 伯乐在线</a>。</p>") (wfw:commentRss nil "http://blog.jobbole.com/104012/feed/") (slash:comments nil "0"))) ("Netty5 HTTP协议栈浅析与实践" "<p><strong>1. 说在前面的话</strong></p><p>前段时间，工作上需要做一个针对视频质量的统计分析系统，各端（PC端、移动端和 WEB端）将视频质量数据放在一个 HTTP 请求中上报到服务器，服务器对数据进行解析、分拣后从不同的维度做实时和离线分析。（ps：这种活儿本该由统计部门去做的，但由于各种原因落在了我头上， 具体原因略过不讲……）</p><p>先用个“概念图”来描绘下整个系统的架构：</p><p><img class=\"alignnone\" src=\"http://ww1.sinaimg.cn/mw690/63918611gw1f6fxshwknqj20i30cu0uc.jpg\" width=\"651\" height=\"462\" /></p><p>嗯，这个是真正的“概念图”，因为我已经把大部分细节都屏蔽了，别笑，因为本文的重点只是整个架构中的一小部分，就是上图中红框内的 http server。</p><p>也许你会问，这不就是个 HTTP 服务器吗，而且是只处理一个请求的 HTTP 服务器，搞个java web 项目在 Tomcat 中一启动不就完事儿了，有啥好讲的呀？。莫慌，且听老夫慢慢道来为啥要用 netty HTTP 协议栈来实现这个接收转发服务。</p><ul><li>首先，接入服务需要支持10W+ tps，而 netty 的多线程模型和异步非阻塞的特性让人很自然就会将它和高并发联系起来。</li><li>其次，接入服务虽然使用 HTTP 协议，但显然这并不是个 WEB 应用，无需运行在相对较重的 Tomcat 这种 WEB 容器上。</li><li>接着，在提供同等服务的情况下对比 netty HTTP 协议栈和 Tomcat HTTP 服务，发现使用 netty 时在机器资源占用（如CPU使用率、内存占用及上下文切换等）方面要优于 Tomcat。</li><li>最后，netty 一直在说对 HTTP 协议提供了非常好的支持，因此想乘机检验一下是否属实。</li></ul><p>基于以上几点原因，老夫就决定使用 netty HTTP 协议栈开干啦~</p><p>本文并非纯理论或纯技术类文章，而是结合理论进而实践（虽然没有特别深入的实践），浅析 netty 的 HTTP 协议栈，并着重聊聊实践中遇到的问题及解决方案。越往后越精彩哦！</p><p><strong>1.1. 关于netty example</strong></p><p>netty 官方提供了关于 HTTP 的例子，大伙儿可以在 netty 项目中查看。</p><ul><li><a href=\"https://github.com/netty/netty/tree/4.1/example/src/main/java/io/netty/example/http\" target=\"_blank\">https://github.com/netty/netty/tree/4.1/example/src/main/java/io/netty/example/http</a></li><li><a href=\"https://github.com/netty/netty/tree/4.1/example/src/main/java/io/netty/example/http2\" target=\"_blank\">https://github.com/netty/netty/tree/4.1/example/src/main/java/io/netty/example/http2</a></li></ul><p><strong>1.2. 关于github项目</strong></p><p>本人在网上使用 “netty + HTTP” 的关键字搜索了下，发现大部分都是原搬照抄 netty 项目中的 example，很少有“原创性”的实践，也几乎没有看到实现一个相对完整的 HTTP 服务器的项目（比如如何解析GET/POST请求、自定义 HTTP decoder、对 HTTP 长短连接的思考等等……），因此就自己整理了一个相对完整一点的项目，项目地址<a href=\"https://github.com/cyfonly/netty-http\" target=\"_blank\">https://github.com/cyfonly/netty-http</a>，该项目实现了基于 netty5 的 HTTP 服务端，暂时实现以下功能：</p><ul><li>HTTP GET 请求解析与响应</li><li>HTTP POST 请求解析与响应，提供 application/json、application/x-www-form-urlencoded、multipart/form-data 三种常见 Content-Type 的 message body 解析示例</li><li>HTTP decoder实现，提供 POST 请求 message body 解码器的 HttpJsonDecoder 及 HttpProtobufDecoder 实现示例</li><li>作为服务端接收浏览器文件上传及保存</li></ul><p>将来可能会继续实现的功能有：</p><ul><li>命名空间</li><li>uri路由</li><li>chunked 传输编码</li></ul><p>如果你也打算使用 netty 来实现 HTTP 服务器，相信这个项目和本文对你是有较大帮助的！</p><p>好了，闲话不多说，下面正式进入正题。</p><p><strong>2. HTTP 协议知多少</strong></p><p>要通过 netty 实现 HTTP 服务端（或者客户端），首先你得了解 HTTP 协议<sup>【1】</sup>。</p><p>HTTP 协议是请求/响应式的协议，客户端需要发送一个请求，服务器才会返回响应内容。例如在浏览器上输入一个网址按下 Enter，或者提交一个 Form 表单，浏览器就会发送一个请求到服务器，而打开的网页的内容，就是服务器返回的响应。</p><p>下面讲下 HTTP 请求和响应包含的内容。</p><p>HTTP 请求有很多种 method，最常用的就是 GET 和 POST，每种 method 的请求之间会有细微的区别。下面分别分析一下 GET 和 POST 请求。</p><p><strong>2.1. GET请求</strong></p><p>下面是浏览器对 http://localhost:8081/test?name=XXG&amp;age=23 的 GET 请求时发送给服务器的数据：</p><p><img src=\"http://images2015.cnblogs.com/blog/897247/201606/897247-20160619225328148-421069272.jpg\" alt=\" \" /></p><p>可以看出请求包含 request line 和 header 两部分。其中 request line 中包含 method（例如 GET、POST）、request uri 和 protocol version 三部分，三个部分之间以空格分开。request line 和每个 header 各占一行，以换行符 CRLF（即 \\r\\n）分割。</p><p><strong>2.2. POST请求</strong></p><p>下面是浏览器对 http://localhost:8081/test 的 POST 请求时发送给服务器的数据，同样带上参数 name=XXG&amp;age=23：</p><p><img src=\"http://images2015.cnblogs.com/blog/897247/201606/897247-20160619225531054-67446933.jpg\" alt=\" \" /></p><p>可以看出，上面的请求包含三个部分：request line、header、message，比之前的 GET 请求多了一个 message body，其中 header 和 message body 之间用一个空行分割。POST 请求的参数不在 URL 中，而是在 message body 中，header 中多了一项 Content-Length 用于表示 message body 的字节数，这样服务器才能知道请求是否发送结束。这也就是 GET 请求和 POST 请求的主要区别。</p><p>HTTP 响应和 HTTP 请求非常相似，HTTP 响应包含三个部分：status line、header、massage body。其中 status line 包含 protocol version、状态码（status code）、reason phrase 三部分。状态码用于描述 HTTP 响应的状态，例如 200 表示成功，404 表示资源未找到，500 表示服务器出错。</p><p><img src=\"http://images2015.cnblogs.com/blog/897247/201606/897247-20160619225733148-810151360.jpg\" alt=\" \" /></p><p>在上面的 HTTP 响应中，Header 中的 Content-Length 同样用于表示 message body 的字节数。Content-Type 表示 message body 的类型，通常浏览网页其类型是HTML，当然还会有其他类型，比如图片、视频等。</p><p><strong>2.3. HTTP POST Content-Type</strong></p><p>HTTP/1.1 协议规定的 HTTP 请求方法有 OPTIONS、GET、HEAD、POST、PUT、DELETE、TRACE、CONNECT 这几种。其中 POST 一般用来向服务端提交数据，本文讨论主要的几种 POST 提交数据方式。</p><p>我们知道，HTTP 协议是以 ASCII 码传输，建立在 TCP/IP 协议之上的应用层规范。规范把 HTTP 请求分为三个部分：状态行、请求头、消息主体。类似于下面这样：</p><div class=\"cnblogs_code\"><pre class=\"crayon-plain-tag\">&lt;method&gt; &lt;request-URL&gt; &lt;version&gt;
&lt;headers&gt;
&lt;entity-body&gt;</pre></div><p>协议规定 POST 提交的数据必须放在消息主体（entity-body）中，但协议并没有规定数据必须使用什么编码方式。实际上，开发者完全可以自己决定消息主体的格式，只要最后发送的 HTTP 请求满足上面的格式就可以。</p><p>但是，数据发送出去，还要服务端解析成功才有意义。一般服务端语言如 php、python 等，以及它们的 framework，都内置了自动解析常见数据格式的功能。服务端通常是根据请求头（headers）中的 Content-Type 字段来获知请求中的消息主体是用何种方式编码，再对主体进行解析。所以说到 POST 提交数据方案，包含了 Content-Type 和消息主体编码方式 Charset 两部分。下面就正式开始介绍它们。</p><p><strong>2.3.1. application/x-www-form-urlencoded</strong></p><p>这应该是最常见的 POST 提交数据的方式了。浏览器的原生 Form 表单，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据。请求类似于下面这样（无关的请求头在本文中都省略掉了）：</p><div class=\"cnblogs_code\"><pre class=\"crayon-plain-tag\">POST http://www.example.com HTTP/1.1
Content-Type: application/x-www-form-urlencoded;charset=utf-8
title=test&amp;sub%5B%5D=1&amp;sub%5B%5D=2&amp;sub%5B%5D=3</pre></div><p>首先，Content-Type 被指定为 application/x-www-form-urlencoded；其次，提交的数据按照 key1=val1&amp;key2=val2 的方式进行编码，key 和 val 都进行了 URL 转码。大部分服务端语言都对这种方式有很好的支持。</p><p>很多时候，我们用 Ajax 提交数据时，也是使用这种方式。例如 JQuery 的 Ajax，Content-Type 默认值都是 application/x-www-form-urlencoded;charset=utf-8 。</p><p><strong>2.3.2. multipart/form-data</strong></p><p>这又是一个常见的 POST 数据提交的方式。我们使用表单上传文件时，必须让 Form 的 enctyped 等于这个值。直接来看一个请求示例：</p><div class=\"cnblogs_code\"><pre class=\"crayon-plain-tag\">POST http://www.example.com HTTP/1.1
Content-Type:multipart/form-data; boundary=----WebKitFormBoundaryrGKCBY7qhFd3TrwA
------WebKitFormBoundaryrGKCBY7qhFd3TrwA
Content-Disposition: form-data; name=&quot;text&quot;
title
------WebKitFormBoundaryrGKCBY7qhFd3TrwA
Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;chrome.png&quot;
Content-Type: image/png
PNG ... content of chrome.png ...
------WebKitFormBoundaryrGKCBY7qhFd3TrwA--</pre></div><p>这个例子稍微复杂点。首先生成了一个 boundary 用于分割不同的字段，为了避免与正文内容重复，boundary 很长很复杂。然后 Content-Type 里指明了数据是以 mutipart/form-data 来编码，本次请求的 boundary 是什么内容。消息主体里按照字段个数又分为多个结构类似的部分，每部分都是以 –boundary 开始，紧接着内容描述信息，然后是回车，最后是字段具体内容（文本或二进制）。如果传输的是文件，还要包含文件名和文件类型信息。消息主体最后以 –boundary– 标示结束。</p><p>这种方式一般用来上传文件，各大服务端语言对它也有着良好的支持。</p><p>上面提到的这两种 POST 数据的方式，都是浏览器原生支持的，而且现阶段原生 Form 表单也只支持这两种方式。但是随着越来越多的 Web 站点，尤其是 WebApp，全部使用 Ajax 进行数据交互之后，我们完全可以定义新的数据提交方式，给开发带来更多便利。</p><p><strong>2.3.3. application/json</strong></p><p>application/json 这个 Content-Type 作为响应头大家肯定不陌生。实际上，现在越来越多的人把它作为请求头，用来告诉服务端消息主体是序列化后的 JSON 字符串。由于 JSON 规范的流行，除了低版本 IE 之外的各大浏览器都原生支持 JSON.stringify，服务端语言也都有处理 JSON 的函数，使用 JSON 不会遇上什么麻烦。</p><p>JSON 格式支持比键值对复杂得多的结构化数据，这一点也很有用，当需要提交的数据层次非常深，就可以考虑把数据 JSON 序列化之后来提交的。</p><div class=\"cnblogs_code\"><pre class=\"crayon-plain-tag\">var data = {'title':'test', 'sub' : [1,2,3]};
$http.post(url, data).success(function(result) {
...
});</pre></div><p>最终发送的请求是：</p><div class=\"cnblogs_code\"><pre class=\"crayon-plain-tag\">POST http://www.example.com HTTP/1.1
Content-Type: application/json;charset=utf-8
{&quot;title&quot;:&quot;test&quot;,&quot;sub&quot;:[1,2,3]}</pre></div><p>这种方案，可以方便的提交复杂的结构化数据，特别适合 RESTful 的接口。各大抓包工具如 Chrome 自带的开发者工具、Fiddler，都会以树形结构展示 JSON 数据，非常友好。</p><p>其他几种 Content-Type 就不一一详细介绍了，感兴趣的童鞋请自行了解。下面进入 netty 支持 HTTP 协议的源码分析阶段。</p><p><strong>3. netty HTTP 编解码</strong></p><p>要通过 netty 处理 HTTP 请求，需要先进行编解码。</p><p><strong>3.1. netty 自带 HTTP 编解码器</strong></p><p>netty5 提供了对 HTTP 协议的几种编解码器：</p><p><strong>3.1.1. HttpRequestDecoder</strong></p><div class=\"cnblogs_code\"><pre class=\"crayon-plain-tag\">Decodes ByteBuf into HttpRequest and HttpContent.</pre></div><p>即把 ByteBuf 解码到 HttpRequest 和 HttpContent。</p><p><strong>3.1.2. HttpResponseEncoder</strong></p><div class=\"cnblogs_code\"><pre class=\"crayon-plain-tag\">Encodes an HttpResponse or an HttpContent into a ByteBuf.</pre></div><p>即把 HttpResponse 或 HttpContent 编码到 ByteBuf。</p><p><strong>3.1.3. HttpServerCodec</strong></p><div class=\"cnblogs_code\"><pre class=\"crayon-plain-tag\">A combination of HttpRequestDecoder and HttpResponseEncoder which enables easier server side HTTP implementation.</pre></div><p>即 HttpRequestDecoder 和 HttpResponseEncoder 的结合。</p><p>因此，基于 netty 实现 HTTP 服务端时，需要在 ChannelPipeline 中加上以上编解码器：</p><div class=\"cnblogs_code\"><pre class=\"crayon-plain-tag\">ch.pipeline().addLast(&quot;codec&quot;,new HttpServerCodec())</pre></div><p>或者</p><div class=\"cnblogs_code\"><pre class=\"crayon-plain-tag\">ch.pipeline().addLast(&quot;decoder&quot;,new HttpRequestDecoder())
.addLast(&quot;encoder&quot;,new HttpResponseEncoder())</pre></div><p>然而，以上编解码器只能够支持部分 HTTP 请求解析，比如 HTTP GET请求所传递的参数是包含在 uri 中的，因此通过 HttpRequest 既能解析出请求参数。但是，对于 HTTP POST 请求，参数信息是放在 message body 中的（对应于 netty 来说就是 HttpMessage），所以以上编解码器并不能完全解析 HTTP POST请求。</p><p>这种情况该怎么办呢？别慌，netty 提供了一个 handler 来处理。</p><p><strong>3.1.4. HttpObjectAggregator</strong></p><div class=\"cnblogs_code\"><pre class=\"crayon-plain-tag\">A ChannelHandler that aggregates an HttpMessage and its following HttpContent into a single FullHttpRequest or FullHttpResponse
(depending on if it used to handle requests or responses) with no following HttpContent.
It is useful when you don't want to take care of HTTP messages whose transfer encoding is 'chunked'.</pre></div><p>即通过它可以把 HttpMessage 和 HttpContent 聚合成一个 FullHttpRequest 或者 FullHttpResponse （取决于是处理请求还是响应），而且它还可以帮助你在解码时忽略是否为“块”传输方式。</p><p>因此，在解析 HTTP POST 请求时，请务必在 ChannelPipeline 中加上 HttpObjectAggregator。（具体细节请自行查阅代码）</p><p>当然，netty 还提供了其他 HTTP 编解码器，有些涉及到高级应用（较复杂的应用），在此就不一一解释了，以上只是介绍netty HTTP 协议栈最基本的编解码器（切合文章主题<strong>——浅析</strong>）。</p><p><strong>3.2. HTTP GET 解析实践</strong></p><p>上面提到过，HTTP GET 请求的参数是包含在 uri 中的，可通过以下方式解析出 uri：</p><div class=\"cnblogs_code\"><pre class=\"crayon-plain-tag\">HttpRequest request = (HttpRequest) msg;
String uri = request.uri();</pre></div><p>特别注意的是，用浏览器发起 HTTP 请求时，常常会被 uri = “/favicon.ico” 所干扰，因此最好对其特殊处理：</p><div class=\"cnblogs_code\"><pre class=\"crayon-plain-tag\">if(uri.equals(FAVICON_ICO)){
return;
}</pre></div><p>接下来就是解析 uri 了。这里需要用到 <strong>QueryStringDecoder</strong>：</p><div class=\"cnblogs_code\"><pre class=\"crayon-plain-tag\">Splits an HTTP query string into a path string and key-value parameter pairs.
This decoder is for one time use only.  Create a new instance for each URI:
QueryStringDecoder decoder = new QueryStringDecoder(&quot;/hello?recipient=world&amp;amp;x=1;y=2&quot;);
assert decoder.getPath().equals(&quot;/hello&quot;);
assert decoder.getParameters().get(&quot;recipient&quot;).get(0).equals(&quot;world&quot;);
assert decoder.getParameters().get(&quot;x&quot;).get(0).equals(&quot;1&quot;);
assert decoder.getParameters().get(&quot;y&quot;).get(0).equals(&quot;2&quot;);
This decoder can also decode the content of an HTTP POST request whose
content type is application/x-www-form-urlencoded:
QueryStringDecoder decoder = new QueryStringDecoder(&quot;recipient=world&amp;amp;x=1;y=2&quot;, false);
...</pre></div><p>从上面的描述可以看出，QueryStringDecoder 的作用就是把 HTTP uri 分割成 path 和 key-value 参数对，也可以用来解码 Content-Type = “application/x-www-form-urlencoded” 的 HTTP POST。特别注意的是，该 decoder 仅能使用一次。</p><p>解析代码如下：</p><div class=\"cnblogs_code\"><pre class=\"crayon-plain-tag\">String uri = request.uri();
HttpMethod method = request.method();
if(method.equals(HttpMethod.GET)){
　　QueryStringDecoder queryDecoder = new QueryStringDecoder(uri, Charsets.toCharset(CharEncoding.UTF_8));
　　Map&lt;String, List&lt;String&gt;&gt; uriAttributes = queryDecoder.parameters();
　　//此处仅打印请求参数（你可以根据业务需求自定义处理）
　　for (Map.Entry&lt;String, List&lt;String&gt;&gt; attr : uriAttributes.entrySet()) {
　　　　for (String attrVal : attr.getValue()) {
　　　　　　System.out.println(attr.getKey() + \"=\" + attrVal);
　　　　}
　　}
}</pre></div><p><strong>3.3. HTTP POST 解析实践</strong></p><p>如3.1.4小结所说的那样，解析 HTTP POST 请求的 message body，一定要使用 HttpObjectAggregator。但是，是否一定要把 msg 转换成 FullHttpRequest 呢？答案是否定的，且往下看。</p><p>首先解释下 FullHttpRequest 是什么：</p><div class=\"cnblogs_code\"><pre class=\"crayon-plain-tag\">Combinate the HttpRequest and FullHttpMessage, so the request is a complete HTTP request.</pre></div><p>即 FullHttpRequest 包含了 HttpRequest 和 FullHttpMessage，是一个 HTTP 请求的完全体。</p><p>而把 msg 转换成 FullHttpRequest 的方法很简单：</p><div class=\"cnblogs_code\"><pre class=\"crayon-plain-tag\">FullHttpRequest fullRequest = (FullHttpRequest) msg;</pre></div><p>接下来就是分几种 Content-Type 进行解析了。</p><p><strong>3.3.1. 解析 application/json</strong></p><p>处理 JSON 格式是非常方便的，我们只需要将 msg 转换成 FullHttpRequest，然后将其 content 反序列化成 JSONObject 对象即可，如下：</p><div class=\"cnblogs_code\"><pre class=\"crayon-plain-tag\">FullHttpRequest fullRequest = (FullHttpRequest) msg;
String jsonStr = fullRequest.content().toString(Charsets.toCharset(CharEncoding.UTF_8));
JSONObject obj = JSON.parseObject(jsonStr);
for(Entry&lt;String, Object&gt; item : obj.entrySet()){
　　System.out.println(item.getKey()+\"=\"+item.getValue().toString());
}</pre></div><p><strong>3.3.2. 解析 application/x-www-form-urlencoded</strong></p><p>解析此类型有两种方法，一种是使用 QueryStringDecoder，另外一种就是使用 HttpPostRequestDecoder。</p><p><strong>方法一：</strong>3.2节中讲 QueryStringDecoder 时提到：QueryStringDecoder 可以用来解码 Content-Type = “application/x-www-form-urlencoded” 的 HTTP POST。因此我们可以用它来解析 message body，剩下的处理就跟 HTTP GET没什么两样了：</p><div class=\"cnblogs_code\"><pre class=\"crayon-plain-tag\">FullHttpRequest fullRequest = (FullHttpRequest) msg;
String jsonStr = fullRequest.content().toString(Charsets.toCharset(CharEncoding.UTF_8));
QueryStringDecoder queryDecoder = new QueryStringDecoder(jsonStr, false);
Map&lt;String, List&lt;String&gt;&gt; uriAttributes = queryDecoder.parameters();
for (Map.Entry&lt;String, List&lt;String&gt;&gt; attr : uriAttributes.entrySet()) {
　　for (String attrVal : attr.getValue()) {
System.out.println(attr.getKey()+\"=\"+attrVal);
}
}</pre></div><p><strong>方法二：</strong>使用 HttpPostRequestDecoder 解析时，无需先将 msg 转换成 FullHttpRequest。</p><p>我们先来了解下 <strong>HttpPostRequestDecoder</strong> ：</p><div class=\"cnblogs_code\"><pre class=\"crayon-plain-tag\">public HttpPostRequestDecoder(HttpDataFactory factory, HttpRequest request, Charset charset) {
　　if (factory == null) {
　　　　throw new NullPointerException(&quot;factory&quot;);
　　}
　　if (request == null) {
　　　　throw new NullPointerException(&quot;request&quot;);
　　}
　　if (charset == null) {
　　　　throw new NullPointerException(&quot;charset&quot;);
　　}
　　// Fill default values
　　if (isMultipart(request)) {
　　　　decoder = new HttpPostMultipartRequestDecoder(factory, request, charset);
　　} else {
　　　　decoder = new HttpPostStandardRequestDecoder(factory, request, charset);
　　}
}</pre></div><p>由它的定义可知，它的内部实现其实有两种方式，一种是针对 multipart 类型的解析，一种是普通类型的解析。这两种方式的具体实现中，我把它们相同的代码提取出来，如下：</p><div class=\"cnblogs_code\"><pre class=\"crayon-plain-tag\">if (request instanceof HttpContent) {
　　// Offer automatically if the given request is als type of HttpContent
　　offer((HttpContent) request);
} else {
　　undecodedChunk = buffer();
　　parseBody();
}</pre></div><p>由于我们使用过 HttpObjectAggregator， request 都是 HttpContent 类型，因此会 Offer automatically，我们就不必自己手动去 offer 了，也不用处理 Chunk，所以使用 HttpObjectAggregator 确实是带来了很多简便的。</p><p>好了，接下来就是使用 HttpPostRequestDecoder 来解析了，直接上代码：</p><div class=\"cnblogs_code\"><pre class=\"crayon-plain-tag\">HttpRequest request = (HttpRequest) msg;
HttpPostRequestDecoder decoder = new HttpPostRequestDecoder(factory, request, Charsets.toCharset(CharEncoding.UTF_8));
List&lt;InterfaceHttpData&gt; datas = decoder.getBodyHttpDatas();
for (InterfaceHttpData data : datas) {
　　if(data.getHttpDataType() == HttpDataType.Attribute) {
　　　　Attribute attribute = (Attribute) data;
　　　　System.out.println(attribute.getName() + \"=\" + attribute.getValue());
　　}
}</pre></div><p>是不是很简单？没错。但是这里有点我要说明下， InterfaceHttpData 是一个interface，没有 API 可以直接拿到它的 value。那怎么办呢？莫方，在它的类内部定义了个枚举类型，如下：</p><div class=\"cnblogs_code\"><pre class=\"crayon-plain-tag\">enum HttpDataType {
　　Attribute, FileUpload, InternalAttribute
}</pre></div><p>这种情况下它是 Attribute 类型，因此你转换一下就能拿到值了。好奇的你可能会问，除 Attribute 外，其他两个是什么时候用呢？没错，接下来马上就讲 FileUpload，至于 InternalAttribute 嘛，老夫就不多说啦，有兴趣可以自己去研究了哈~</p><p><strong>3.3.3. 解析 multipart/form-data （文件上传）</strong></p><p>上面说到了 FileUpload，那在这里就来说说如何使用 netty HTTP 协议栈实现文件上传和保存功能。</p><p>这里依然使用 HttpPostRequestDecoder，废话就不多少了，直接上代码：</p><div class=\"cnblogs_code\"><pre class=\"crayon-plain-tag\">DiskFileUpload.baseDirectory = \"/data/fileupload/\";
HttpRequest request = (HttpRequest) msg;
HttpPostRequestDecoder decoder = new HttpPostRequestDecoder(factory, request, Charsets.toCharset(CharEncoding.UTF_8));
List&lt;InterfaceHttpData&gt; datas = decoder.getBodyHttpDatas();
for (InterfaceHttpData data : datas) {
　　if(data.getHttpDataType() == HttpDataType.FileUpload) {
　　　　FileUpload fileUpload = (FileUpload) data;
　　　　String fileName = fileUpload.getFilename();
　　　　if(fileUpload.isCompleted()) {
　　　　　　//保存到磁盘
　　　　　　StringBuffer fileNameBuf = new StringBuffer();
　　　　　　fileNameBuf.append(DiskFileUpload.baseDirectory).append(fileName);
　　　　　　fileUpload.renameTo(new File(fileNameBuf.toString()));
　　　　}
　　}
}</pre></div><p>至于效果，你可以直接在本地起个服务搞个简单的页面，向服务器传个文件就行了。如果你很懒，直接用下面的HTML代码改改将就着用吧：</p><div class=\"cnblogs_code\"><pre class=\"crayon-plain-tag\">&lt;form action=\"http://localhost:8080\" method=\"post\" enctype =\"multipart/form-data\"&gt;
　　&lt;input id=\"File1\" runat=\"server\" name=\"UpLoadFile\" type=\"file\" /&gt;
　　&lt;input type=\"submit\" name=\"Button\" value=\"上传\" id=\"Button\" /&gt;
&lt;/form&gt;</pre></div><p>至于其他类型的 Method、其他类型的 Content-Type，我也不打算细无巨细一一给大伙儿详细讲解了，看看上面罗列的，其实都很简单是不是？</p><p>上面说的都是 netty 自己实现的东西，下面就来讲讲如何实现一个简单的 HTTP decoder。</p><p><strong>4. 自定义 HTTP POST 的 message body 解码器</strong></p><p>关于解码器，我也不打算实现很复杂很牛逼的，只是写了两个粗糙的 decoder，一个是带参数的一个是不带参数的。既然是浅析，那就下面就简单的聊聊。</p><p>如果你要实现一个顶层解码器，就要继承 MessageToMessageDecoder 并重写其 decode 方法。MessageToMessageDecoder 继承了 ChannelHandlerAdapter，也就是说解码器其实就是一个 handler，只不过是专门用来做解码的事情。下面我们来看看它重写的 channelRead 方法：</p><div class=\"cnblogs_code\"><pre class=\"crayon-plain-tag\">@Override
public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
　　RecyclableArrayList out = RecyclableArrayList.newInstance();
　　try {
　　　　if (acceptInboundMessage(msg)) {
　　　　　　@SuppressWarnings(\"unchecked\")
　　　　　　I cast = (I) msg;
　　　　　　try {
　　　　　　　　decode(ctx, cast, out);
　　　　　　} finally {
　　　　　　　　ReferenceCountUtil.release(cast);
　　　　　　}
　　　　} else {
　　　　　　out.add(msg);
　　　　}
　　} catch (DecoderException e) {
　　　　throw e;
　　} catch (Exception e) {
　　　　throw new DecoderException(e);
　　} finally {
　　　　int size = out.size();
　　　　for (int i = 0; i &lt; size; i ++) {
　　　　　　ctx.fireChannelRead(out.get(i));
　　　　}
　　　　out.recycle();
　　}
}</pre></div><p>其中 decode 方法是你实现 decoder 时需要重写的，经过解码之后，会调用 ctx.fireChannelRead() 将 out 传递给给下一个 handler 执行相关逻辑。</p><p><strong>4.1. HttpJsonDecoder</strong></p><p>从名字可以看出，这是个针对 message body 为 JsonString 的解码器。处理过程很简单，只需要把 HTTP 请求的 content （即 ByteBuf）的可读字节转换成 JSONObject 对象，如下：</p><div class=\"cnblogs_code\"><pre class=\"crayon-plain-tag\">@Override
protected void decode(ChannelHandlerContext ctx, HttpRequest msg, List&lt;Object&gt; out) throws Exception {
　　FullHttpRequest fullRequest = (FullHttpRequest) msg;
　　ByteBuf content = fullRequest.content();
　　int length = content.readableBytes();
　　byte[] bytes = new byte[length];
　　for(int i=0; i&lt;length; i++){
　　　　bytes[i] = content.getByte(i);
　　}
　　try{
　　　　JSONObject obj = JSON.parseObject(new String(bytes));
　　　　out.add(obj);
　　}catch(ClassCastException e){
　　　　throw new CodecException(\"HTTP message body is not a JSONObject\");
　　}
}</pre></div><p>使用方法也很简单，在 Server 的 HttpServerCodec() 和 HttpObjectAggregator() 后面加上：</p><div class=\"cnblogs_code\"><pre class=\"crayon-plain-tag\">.addLast(&quot;jsonDecoder&quot;, new HttpJsonDecoder())</pre></div><p>然后在业务 handler channelRead方法中使用即可：</p><div class=\"cnblogs_code\"><pre class=\"crayon-plain-tag\">if(msg instanceof JSONObject){
　　JSONObject obj = (JSONObject) msg;
　　......
}</pre></div><p><strong>4.2. HttpProtobufDecoder</strong></p><p>这是一个带参数的 decoder，用来解析使用 protobuf 序列化后的 message body。使用的时候需要传递 MessageLite 进来，直接上代码：</p><div class=\"cnblogs_code\"><pre class=\"crayon-plain-tag\">private final MessageLite prototype;
public HttpProtobufDecoder(MessageLite prototype){
　　if (prototype == null) {
　　　　throw new NullPointerException(\"prototype\");
　　}
　　this.prototype = prototype.getDefaultInstanceForType();
}
@Override
protected void decode(ChannelHandlerContext ctx, HttpRequest msg, List&lt;Object&gt; out) {
　　FullHttpRequest fullRequest = (FullHttpRequest) msg;
　　ByteBuf content = fullRequest.content();
　　int length = content.readableBytes();
　　byte[] bytes = new byte[length];
　　for(int i=0; i&lt;length; i++){
　　　　bytes[i] = content.getByte(i);
　　}
　　try {
　　　　out.add(prototype.getParserForType().parseFrom(bytes, 0, length));
　　} catch (InvalidProtocolBufferException e) {
　　　　throw new CodecException(\"HTTP message body is not \" + prototype + \"type\");
　　}
}</pre></div><p>使用方法跟 HttpJsonDecoder无异。此处以 protobuf 对象 UserProtobuf.User 为例，在 Server 的 HttpServerCodec() 和 HttpObjectAggregator() 后面加上：</p><div class=\"cnblogs_code\"><pre class=\"crayon-plain-tag\">.addLast(&quot;protobufDecoder&quot;, new HttpProtobufDecoder(UserProbuf.User.getDefaultInstance()))</pre></div><p>然后在业务 handler channelRead方法中使用即可：</p><div class=\"cnblogs_code\"><pre class=\"crayon-plain-tag\">if(msg instanceof UserProbuf.User){
　　UserProbuf.User user = (UserProbuf.User) msg;
　　......
}</pre></div><p><strong>5. 聊聊开发中遇到的问题【推荐】</strong></p><p>如果你没有亲自使用过 netty 却说自己熟悉甚至精通 netty，我劝你千万别这么做，因为你的脸会被打肿的。netty 作为一个异步非阻塞的 IO 框架，它到底多牛逼在这就不多扯了，而作为一个首次使用 netty HTTP 协议栈的我来说，踩坑是必不可少的过程。当然了，踩了坑就要填上，我还很乐意在这把我踩过的几个坑给大家分享下，前车之鉴。</p><p><strong>5.1. 关于内存泄漏</strong></p><p>首先说下经历的情况。在文章开篇提到的接收服务，经过多轮的单元测试几乎没发现什么问题，于是对于接下来的压力测试我是自信满满。然而，当我第一次跑压测时就抛出一个异常，如下：</p><div class=\"cnblogs_code\"><pre class=\"crayon-plain-tag\">[ERROR] 2016-07-24 15:25:46 [io.netty.util.internal.logging.Slf4JLogger:176] - LEAK: ByteBuf.release() was not called before it's garbage-collected. Enable advanced leak reporting to find out where the leak occurred. To enable advanced leak reporting, specify the JVM option '-Dio.netty.leakDetectionLevel=advanced' or call ResourceLeakDetector.setLevel() See http://netty.io/wiki/reference-counted-objects.html for more information.</pre></div><p>着实让我开心了一把，终于出现异常了！异常信息表达的是 “ByteBuf 在被 JVM GC 之前没有调用 ByteBuf.release() ，启用高级泄漏报告，找出发生泄漏的地方”，于是马上google了一把，原来是从 netty4 开始，对象的生命周期由它们的引用计数（reference counts）管理，而不是由垃圾收集器（garbage collector）管理了。</p><p>要解决这个问题，先从源头了解开始。</p><p><strong>5.1.1. netty 引用计数对象<sup>【2】</sup></strong></p><p>对于 netty Inbound message，当 event loop 读入了数据并创建了 ByteBuf，并用这个 ByteBuf 触发了一个 channelRead() 事件时，那么管道（pipeline）中相应的ChannelHandler 就负责释放这个 buffer 。因此，处理接数据的 handler 应该在它的 channelRead() 中调用 buffer 的 release()，如下：</p><div class=\"cnblogs_code\"><pre class=\"crayon-plain-tag\">public void channelRead(ChannelHandlerContext ctx, Object msg) {
ByteBuf buf = (ByteBuf) msg;
try {
...
} finally {
buf.release();
}
}</pre></div><p>而有时候，ByteBuf 会被一个 buffer holder 持有，它们都扩展了一个公共接口 ByteBufHolder。正因如此， ByteBuf 并不是 netty 中唯一一种引用计数对象。由 decoder 生成的消息对象很可能也是引用计数对象，比如 HTTP 协议栈中的 HttpContent，因为它也扩展了 ByteBufHolder。</p><div class=\"cnblogs_code\"><pre class=\"crayon-plain-tag\">public void channelRead(ChannelHandlerContext ctx, Object msg) {
if (msg instanceof HttpRequest) {
HttpRequest req = (HttpRequest) msg;
...
}
if (msg instanceof HttpContent) {
HttpContent content = (HttpContent) msg;
try {
...
} finally {
content.release();
}
}
}</pre></div><p>如果你抱有疑问，或者你想简化这些释放消息的工作，你可以使用 ReferenceCountUtil.release()：</p><div class=\"cnblogs_code\"><pre class=\"crayon-plain-tag\">public void channelRead(ChannelHandlerContext ctx, Object msg) {
try {
...
} finally {
ReferenceCountUtil.release(msg);
}
}</pre></div><p>或者可以考虑继承 SimpleChannelHandler，它在所有接收消息的地方都调用了 ReferenceCountUtil.release(msg)。</p><p>对于 netty Outbound message，你的程序所创建的消息对象都由 netty 负责释放，释放的时机是在这些消息被发送到网络之后。但是，在发送消息的过程中，如果有 handler 截获（intercept）了你的发送请求并创建了一些中间对象，则这些 handler 要确保正确释放这些中间对象。比如 encoder，此处不赘述。</p><p>通过以上信息，自然就很容易找到 OOM 问题的原因所在了。由于在处理 HTTP 请求过程中没有释放 ByteBuf，因此在代码 finally 块中加上 ReferenceCountUtil.release(msg) 就解决啦！</p><p><strong>5.1.2. 如何规避内存泄漏<sup>【3】</sup></strong></p><p>netty 提供了内存泄漏的监测机制，默认就会从分配的 ByteBuf 里抽样出大约 1% 的来进行跟踪。如果泄漏，就会打印5.1.1节中的异常信息，并提示你通过指定 JVM 选项</p><div class=\"cnblogs_code\"><pre class=\"crayon-plain-tag\">-Dio.netty.leakDetectionLevel=advanced</pre></div><p>来查看泄漏报告。泄漏年监测有4个等级：</p><ul><li>禁用（DISABLED） – 完全禁止泄露检测，省点消耗。</li><li>简单（SIMPLE） – 默认等级，告诉我们取样的 1% 的 ByteBuf 是否发生了泄露，但总共一次只打印一次，看不到就没有了。</li><li>高级（ADVANCED） – 告诉我们取样的 1% 的 ByteBuf 发生泄露的地方。每种类型的泄漏（创建的地方与访问路径一致）只打印一次。</li><li>偏执（PARANOID） – 跟高级选项类似，但此选项检测所有 ByteBuf，而不仅仅是取样的那 1%。在高压力测试时，对性能有明显影响。</li></ul><p>一般情况下我们采用 SIMPLE 级别即可。</p><p><strong>5.2. 关于 HTTP 长连接</strong></p><p>按照惯例，先说下开发中踩到的坑。</p><p>对于接收服务，我采用的是 nginx + netty http，其中 nginx 配置如下（阉割隐藏版）：</p><div class=\"cnblogs_code\"><pre class=\"crayon-plain-tag\">upstream xxx.com{
keepalive 32;
server xxxx.xx.xx.xx:8080;
}
server{
listen  80;
server_name     xxx.com;
location / {
proxy_next_upstream http_502 http_504 error timeout invalid_header;
proxy_pass xxx.com;
proxy_http_version 1.1;
proxy_set_header Connection &quot;&quot;;
#proxy_set_header  Host             $host;
#proxy_set_header  X-Forwarded-For  $remote_addr;
#proxy_set_header  REMOTE_ADDR      $remote_addr;
#proxy_set_header  X-Real-IP     $remote_addr;
proxy_read_timeout 60s;
client_max_body_size 1m;
}
error_page   500 502 503 504  /50x.html;
location = /50x.html{
root   html;
}
}</pre></div><p>然后编写了一个简单的 HttpClient 发送消息，如下（截取）：</p><pre class=\"crayon-plain-tag\">OutputStream outStream = conn.getOutputStream();
outStream.write(data);
outStream.flush();
outStream.close();
if (conn.getResponseCode() == 200) {
　　&lt;span style=\"color: #ff0000;\"&gt;BufferedReader in = new BufferedReader(new InputStreamReader((InputStream) conn.getInputStream(), \"UTF-8\"));&lt;/span&gt;
　　String msg = in.readLine();
　　System.out.println(\"msg = \" + msg);
　　in.close();
}
conn.disconnect();</pre><p>接着，正常发送 HTTP 请求到服务器，然而，老夫整整等了60多秒才接到响应信息！而且每次都这样！！</p><p>我首先怀疑是不是 ngxin 出问题了，有一个配置项立马引起了我的怀疑，没错，就是上面红色的那行 proxy_read_timeout 60s; 。为了验证，我首先把 60s 改成了 10s，效果很明显，发送的请求 10 秒过一点就收到响应了！更加彻底证明是 nginx 的锅，我去掉了 nginx，让客户端直接发送请求给服务端。然而，蛋疼的事情出现了，客户端竟然一直阻塞在 BufferedReader in = new BufferedReader(new InputStreamReader((InputStream) conn.getInputStream(), “UTF-8”)); 处。这说明根本就不是 nginx 的问题啊！</p><p>我冷静下来，review 了一下代码同时 search 了相关资料，发现了一个小小的区别，在我的返回代码中，对 ChannelFuture 少了对 CLOSE 事件的监听器：</p><div class=\"cnblogs_code\"><pre class=\"crayon-plain-tag\">ctx.writeAndFlush(response)&lt;span class=&quot;pl-k&quot;&gt;.addListener(&lt;span class=&quot;pl-smi&quot;&gt;ChannelFutureListener&lt;span class=&quot;pl-c1&quot;&gt;&lt;span class=&quot;pl-k&quot;&gt;.CLOSE)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;;</pre></div><p>于是，我加上 Listener 再试一下，马上就得到响应了！</p><p>就在这一刻明白了这是 HTTP 长连接的问题。首先从上面的 nginx 配置中可以看到，我显式指定了 nginx 和 HTTP 服务器是用的 HTTP1.1 版本，HTTP1.1 版本默认是长连接方式（也就是 Connection=Keep-Alive），而我在 netty HTTP 服务器中并没有对长、短连接方式做区别处理，并且在 HttpResponse 响应中并没有显式加上 Content-Length 头部信息，恰巧 netty Http 协议栈并没有在框架上做这件工作，导致服务端虽然把响应消息发出去了，但是客户端并不知道你是否发送完成了（即没办法判断数据是否已经发送完）。</p><p>于是，把响应的处理完善一下即可：</p><div class=\"cnblogs_code\"><pre class=\"crayon-plain-tag\">/**
* 响应报文处理
* @param channel 当前上下文Channel
* @param status 响应码
* @param msg 响应消息
* @param forceClose 是否强制关闭
*/
private void writeResponse(Channel channel, HttpResponseStatus status, String msg, boolean forceClose){
　　ByteBuf byteBuf = Unpooled.wrappedBuffer(msg.getBytes());
　　response = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, status, byteBuf);
　　boolean close = isClose();
　　if(!close &amp;&amp;!forceClose){
　　　　response.headers().add(org.apache.http.HttpHeaders.CONTENT_LENGTH, String.valueOf(byteBuf.readableBytes()));
　　}
　　ChannelFuture future = channel.write(response);
　　　　if(close || forceClose){
　　　　　　future.addListener(ChannelFutureListener.CLOSE);
　　　　}
　　}
private boolean isClose(){
　　if(request.headers().contains(org.apache.http.HttpHeaders.CONNECTION, CONNECTION_CLOSE, true) ||
　　　　(request.protocolVersion().equals(HttpVersion.HTTP_1_0) &amp;&amp;
　　　　　　!request.headers().contains(org.apache.http.HttpHeaders.CONNECTION, CONNECTION_KEEP_ALIVE, true)))
　　　　return true;
　　return false;
}</pre></div><p>好了，问题是解决了，那么你对 HTTP 长连接真的了解吗？不了解，好，那就来不补课。</p><p><strong>5.2.1. TCP KeepAlive 和 HTTP KeepAlive<sup>【4】</sup></strong></p><p>netty 中有个地方比较让初学者迷惑，就是 childOption(<span class=\"pl-smi\">ChannelOption<span class=\"pl-c1\"><span class=\"pl-k\">.SO_KEEPALIVE, <span class=\"pl-c1\">true) 和 HttpRequest.Headers.get(“Connection”).equals(“Keep-Alive”) （非标准写法，仅作示例）的异同。有些人可能会问，我在 <span class=\"pl-smi\">ServerBootstrap 中指定了 childOption(<span class=\"pl-smi\">ChannelOption<span class=\"pl-c1\"><span class=\"pl-k\">.SO_KEEPALIVE, <span class=\"pl-c1\">true)，是不是就意味着客户端和服务器是长连接了？</span></span></span></span></span></span></span></span></span></p><p><span class=\"pl-smi\"><span class=\"pl-c1\"><span class=\"pl-k\"><span class=\"pl-c1\"><span class=\"pl-smi\"><span class=\"pl-smi\"><span class=\"pl-c1\"><span class=\"pl-k\"><span class=\"pl-c1\">答案当然不是。</span></span></span></span></span></span></span></span></span></p><p><span class=\"pl-smi\"><span class=\"pl-c1\"><span class=\"pl-k\"><span class=\"pl-c1\"><span class=\"pl-smi\"><span class=\"pl-smi\"><span class=\"pl-c1\"><span class=\"pl-k\"><span class=\"pl-c1\">首先，TCP 的 KeepAlive 是 TCP 连接的探测机制，用来检测当前 TCP 连接是否活着。它支持三个系统内核参数</span></span></span></span></span></span></span></span></span></p><ul><li><span class=\"pl-smi\">tcp_keepalive_time</span></li><li><span class=\"pl-smi\">tcp_keepalive_intvl</span></li><li><span class=\"pl-smi\">tcp_keepalive_probes</span></li></ul><p><span class=\"pl-smi\"><span class=\"pl-c1\"><span class=\"pl-k\"><span class=\"pl-c1\"><span class=\"pl-smi\"><span class=\"pl-smi\"><span class=\"pl-c1\"><span class=\"pl-k\"><span class=\"pl-c1\">当网络两端建立了 TCP 连接之后，闲置 idle（双方没有任何数据流发送往来）了 tcp_keepalive_time 后，服务器内核就会尝试向客户端发送侦测包，来判断 TCP 连接状况(有可能客户端崩溃、强制关闭了应用、主机不可达等等)。如果没有收到对方的回答( ACK 包)，则会在 tcp_keepalive_intvl 后再次尝试发送侦测包，直到收到对对方的 ACK，如果一直没有收到对方的 ACK，一共会尝试 tcp_keepalive_probes 次，每次的间隔时间在这里分别是 15s、30s、45s、60s、75s。如果尝试 tcp_keepalive_probes，依然没有收到对方的 ACK 包，则会丢弃该 TCP 连接。TCP 连接默认闲置时间是2小时。</span></span></span></span></span></span></span></span></span></p><p>而对于 HTTP 的 KeepAlive，则是让 TCP 连接活长一点，在一次 TCP 连接中可以持续发送多份数据而不会断开连接。通过使用 keep-alive 机制，可以减少 TCP 连接建立次数，也意味着可以减少 TIME_WAIT 状态连接，以此提高性能和提高 TTTP 服务器的吞吐率（更少的 TCP 连接意味着更少的系统内核调用，socket 的 accept() 和 close() 调用）。</p><p><a href=\"http://jbcdn2.b0.upaiyun.com/2016/08/011ecee7d295c066ae68d4396215c3d0.png\"><img class=\"alignnone size-full wp-image-104095\" src=\"http://jbcdn2.b0.upaiyun.com/2016/08/011ecee7d295c066ae68d4396215c3d0.png\" alt=\"4\" /></a></p><p>对于建立 HTTP 长连接的好处，总结如下<sup>【5】</sup>：</p><ul><li>By opening and closing fewer TCP connections, CPU time is saved in routers and hosts (clients, servers, proxies, gateways, tunnels, or caches), and memory used for TCP protocol control blocks can be saved in hosts.</li><li>HTTP requests and responses can be pipelined on a connection. Pipelining allows a client to make multiple requests without waiting for each response, allowing a single TCP connection to be used much more efficiently, with much lower elapsed time.</li><li>Network congestion is reduced by reducing the number of packets caused by TCP opens, and by allowing TCP sufficient time to determine the congestion state of the network.</li><li>Latency on subsequent requests is reduced since there is no time spent in TCP’s connection opening handshake.</li><li>HTTP can evolve more gracefully, since errors can be reported without the penalty of closing the TCP connection. Clients using future versions of HTTP might optimistically try a new feature, but if communicating with an older server, retry with old semantics after an error is reported.</li></ul><p><strong> 5.2.2. 长连接方式中如何判断数据发送完成<sup>【6】</sup></strong></p><p>回到本节最开始提出的问题，KeepAlive 模式下，HTTP 服务器在发送完数据后并不会主动断开连接，那客户端如何判断数据发送完成了？</p><p>对于短连接方式，服务端在发送完数据后会断开连接，客户端过服务器关闭连接能确定消息的传输长度。（请求端不能通过关闭连接来指明请求消息体的结束，因为这样让服务器没有机会继续给予响应）。</p><p>但对于长连接方式，服务端只有在 Keep-alive timeout 或者达到 max 请求次数时才会断开连接。这种情况下有两种判断方法。</p><p><strong>使用消息头部 Content-Length</strong></p><p>Conent-Length 表示实体内容长度，客户端（或服务器）可以根据这个值来判断数据是否接收完成。但是如果消息中没有 Conent-Length，那该如何来判断呢？又在什么情况下会没有 Conent-Length 呢？</p><p><strong>使用消息首部字段 Transfer-Encoding</strong></p><p>当请求或响应的内容是动态的，客户端或服务器无法预先知道要传输的数据大小时，就要使用 Transfer-Encoding（即 chunked 编码传输）。chunked 编码将数据分成一块一块的发送。chunked 编码将使用若干个chunk 串连而成，由一个标明长度为 0 的 chunk 标示结束。每个 chunk 分为头部和正文两部分，头部内容指定正文的字符总数（十六进制的数字）和数量单位（一般不写），正文部分就是指定长度的实际内容，两部分之间用回车换行 (CRLF)隔开。在最后一个长度为 0 的 chunk 中的内容是称为footer的内容，是一些附加的Header信息（通常可以直接忽略）。</p><p>如果一个请求包含一个消息主体并且没有给出 Content-Length，那么服务器如果不能判断消息长度的话应该以400响应（Bad Request），或者以411响应（Length Required）如果它坚持想要收到一个有效的 Content-length。所有的能接收实体的 HTTP/1.1 应用程序必须能接受 chunked 的传输编码，因此当消息的长度不能被提前确定时，可以利用这种机制来处理消息。消息不能同时都包括 Content-Length 头域和 非identity （Transfer-Encoding）传输编码。如果消息包括了一个 非identity 的传输编码，Content-Length头域必须被忽略。当 Content-Length 头域出现在一个具有消息主体（message-body）的消息里，它的域值必须精确匹配消息主体里字节数量。</p><p>&nbsp;</p><p>好了，本章较长，虽然不是很深奥难懂的知识，也不是很牛逼的技术实现，但是耐心看完之后相信你终究是有所收获的。在此本文就要完结了，后续会对 netty HTTP 协议栈做更深入的研究，至于<a href=\"https://github.com/cyfonly/netty-http\" target=\"_blank\">这个 github 上的项目</a>，后面也会继续完善 TODO LIST。大家可以通过多种方式与我交流，并欢迎大家提出宝贵意见。</p><p>&nbsp;</p><p><strong>参考文章：</strong></p><p>【1】《<a href=\"http://www.cnblogs.com/wucao/p/3989863.html\" target=\"_blank\">Mina、Netty、Twisted一起学（八）：HTTP服务器</a>》</p><p>【2】《<a href=\"http://damacheng009.iteye.com/blog/2013657\" target=\"_blank\">【Netty官方文档翻译】引用计数对象（reference counted objects）</a>》</p><p>【3】《<a href=\"http://m635674608.iteye.com/blog/2236834\" target=\"_blank\">Netty之有效规避内存泄漏</a>》</p><p>【4】《<a href=\"http://www.92csz.com/17/1152.html\" target=\"_blank\">详解http_keepalive</a>》</p><p>【5】《<a href=\"http://www.cnblogs.com/skynet/archive/2010/12/11/1903347.html\" target=\"_blank\">HTTP Keep-Alive模式</a>》</p><p>【6】《<a href=\"http://www.cnblogs.com/cswuyg/p/3653263.html\" target=\"_blank\">HTTP的长连接和短连接</a>》</p><div class=\"wp_rp_wrap  wp_rp_plain\" id=\"wp_rp_first\"><div class=\"wp_rp_content\"><h3 class=\"related_post_title\">相关文章</h3><ul class=\"related_post wp_rp\" style=\"visibility: visible\"><li ><a href=\"http://blog.jobbole.com/98633/\" class=\"wp_rp_title\">StackOverflow 这么大，它的架构是怎么样的？</a></li><li ><a href=\"http://blog.jobbole.com/21622/\" class=\"wp_rp_title\">SPDY 是什么？如何部署 SPDY？</a></li><li ><a href=\"http://blog.jobbole.com/87509/\" class=\"wp_rp_title\">如何生成每秒百万级别的 HTTP 请求？</a></li><li ><a href=\"http://blog.jobbole.com/42763/\" class=\"wp_rp_title\">HTTP代理与SPDY协议</a></li><li ><a href=\"http://blog.jobbole.com/86660/\" class=\"wp_rp_title\">大型网站的 HTTPS 实践（1）：HTTPS 协议和原理</a></li><li ><a href=\"http://blog.jobbole.com/86670/\" class=\"wp_rp_title\">大型网站的 HTTPS 实践（4）：协议层以外的实践</a></li><li ><a href=\"http://blog.jobbole.com/88199/\" class=\"wp_rp_title\">HTTP 协议漫谈</a></li><li ><a href=\"http://blog.jobbole.com/86664/\" class=\"wp_rp_title\">大型网站的 HTTPS 实践（2）：HTTPS 对性能的影响</a></li><li ><a href=\"http://blog.jobbole.com/84429/\" class=\"wp_rp_title\">通信协议：HTTP、TCP、UDP</a></li><li ><a href=\"http://blog.jobbole.com/93960/\" class=\"wp_rp_title\">HTTP 长连接和短连接</a></li></ul></div></div><p><a href=\"http://blog.jobbole.com/104103/\">Netty5 HTTP协议栈浅析与实践</a>，首发于<a href=\"http://blog.jobbole.com\">文章 - 伯乐在线</a>。</p>" "http://blog.jobbole.com/104103/" (22432 47411) old 5 nil nil ((title nil "Netty5 HTTP协议栈浅析与实践") (link nil "http://blog.jobbole.com/104103/") (comments nil "http://blog.jobbole.com/104103/#respond") (pubDate nil "Tue, 02 Aug 2016 15:16:03 +0000") (dc:creator nil "黄山松") (category nil "IT技术") (category nil "HTTP") (category nil "netty") (guid ((isPermaLink . "false")) "http://blog.jobbole.com/?p=104103") (description nil "<p>前段时间，工作上需要做一个针对视频质量的统计分析系统，各端（PC端、移动端和 WEB端）将视频质量数据放在一个 HTTP 请求中上报到服务器，服务器对数据进行解析、分拣后从不同的维度做实时和离线分析。（ps：这种活儿本该由统计部门去做的，但由于各种原因落在了我头上， 具体原因略过不讲……）</p><p><a href=\"http://blog.jobbole.com/104103/\">Netty5 HTTP协议栈浅析与实践</a>，首发于<a href=\"http://blog.jobbole.com\">文章 - 伯乐在线</a>。</p>") (content:encoded nil "<p><strong>1. 说在前面的话</strong></p><p>前段时间，工作上需要做一个针对视频质量的统计分析系统，各端（PC端、移动端和 WEB端）将视频质量数据放在一个 HTTP 请求中上报到服务器，服务器对数据进行解析、分拣后从不同的维度做实时和离线分析。（ps：这种活儿本该由统计部门去做的，但由于各种原因落在了我头上， 具体原因略过不讲……）</p><p>先用个“概念图”来描绘下整个系统的架构：</p><p><img class=\"alignnone\" src=\"http://ww1.sinaimg.cn/mw690/63918611gw1f6fxshwknqj20i30cu0uc.jpg\" width=\"651\" height=\"462\" /></p><p>嗯，这个是真正的“概念图”，因为我已经把大部分细节都屏蔽了，别笑，因为本文的重点只是整个架构中的一小部分，就是上图中红框内的 http server。</p><p>也许你会问，这不就是个 HTTP 服务器吗，而且是只处理一个请求的 HTTP 服务器，搞个java web 项目在 Tomcat 中一启动不就完事儿了，有啥好讲的呀？。莫慌，且听老夫慢慢道来为啥要用 netty HTTP 协议栈来实现这个接收转发服务。</p><ul><li>首先，接入服务需要支持10W+ tps，而 netty 的多线程模型和异步非阻塞的特性让人很自然就会将它和高并发联系起来。</li><li>其次，接入服务虽然使用 HTTP 协议，但显然这并不是个 WEB 应用，无需运行在相对较重的 Tomcat 这种 WEB 容器上。</li><li>接着，在提供同等服务的情况下对比 netty HTTP 协议栈和 Tomcat HTTP 服务，发现使用 netty 时在机器资源占用（如CPU使用率、内存占用及上下文切换等）方面要优于 Tomcat。</li><li>最后，netty 一直在说对 HTTP 协议提供了非常好的支持，因此想乘机检验一下是否属实。</li></ul><p>基于以上几点原因，老夫就决定使用 netty HTTP 协议栈开干啦~</p><p>本文并非纯理论或纯技术类文章，而是结合理论进而实践（虽然没有特别深入的实践），浅析 netty 的 HTTP 协议栈，并着重聊聊实践中遇到的问题及解决方案。越往后越精彩哦！</p><p><strong>1.1. 关于netty example</strong></p><p>netty 官方提供了关于 HTTP 的例子，大伙儿可以在 netty 项目中查看。</p><ul><li><a href=\"https://github.com/netty/netty/tree/4.1/example/src/main/java/io/netty/example/http\" target=\"_blank\">https://github.com/netty/netty/tree/4.1/example/src/main/java/io/netty/example/http</a></li><li><a href=\"https://github.com/netty/netty/tree/4.1/example/src/main/java/io/netty/example/http2\" target=\"_blank\">https://github.com/netty/netty/tree/4.1/example/src/main/java/io/netty/example/http2</a></li></ul><p><strong>1.2. 关于github项目</strong></p><p>本人在网上使用 “netty + HTTP” 的关键字搜索了下，发现大部分都是原搬照抄 netty 项目中的 example，很少有“原创性”的实践，也几乎没有看到实现一个相对完整的 HTTP 服务器的项目（比如如何解析GET/POST请求、自定义 HTTP decoder、对 HTTP 长短连接的思考等等……），因此就自己整理了一个相对完整一点的项目，项目地址<a href=\"https://github.com/cyfonly/netty-http\" target=\"_blank\">https://github.com/cyfonly/netty-http</a>，该项目实现了基于 netty5 的 HTTP 服务端，暂时实现以下功能：</p><ul><li>HTTP GET 请求解析与响应</li><li>HTTP POST 请求解析与响应，提供 application/json、application/x-www-form-urlencoded、multipart/form-data 三种常见 Content-Type 的 message body 解析示例</li><li>HTTP decoder实现，提供 POST 请求 message body 解码器的 HttpJsonDecoder 及 HttpProtobufDecoder 实现示例</li><li>作为服务端接收浏览器文件上传及保存</li></ul><p>将来可能会继续实现的功能有：</p><ul><li>命名空间</li><li>uri路由</li><li>chunked 传输编码</li></ul><p>如果你也打算使用 netty 来实现 HTTP 服务器，相信这个项目和本文对你是有较大帮助的！</p><p>好了，闲话不多说，下面正式进入正题。</p><p><strong>2. HTTP 协议知多少</strong></p><p>要通过 netty 实现 HTTP 服务端（或者客户端），首先你得了解 HTTP 协议<sup>【1】</sup>。</p><p>HTTP 协议是请求/响应式的协议，客户端需要发送一个请求，服务器才会返回响应内容。例如在浏览器上输入一个网址按下 Enter，或者提交一个 Form 表单，浏览器就会发送一个请求到服务器，而打开的网页的内容，就是服务器返回的响应。</p><p>下面讲下 HTTP 请求和响应包含的内容。</p><p>HTTP 请求有很多种 method，最常用的就是 GET 和 POST，每种 method 的请求之间会有细微的区别。下面分别分析一下 GET 和 POST 请求。</p><p><strong>2.1. GET请求</strong></p><p>下面是浏览器对 http://localhost:8081/test?name=XXG&amp;age=23 的 GET 请求时发送给服务器的数据：</p><p><img src=\"http://images2015.cnblogs.com/blog/897247/201606/897247-20160619225328148-421069272.jpg\" alt=\" \" /></p><p>可以看出请求包含 request line 和 header 两部分。其中 request line 中包含 method（例如 GET、POST）、request uri 和 protocol version 三部分，三个部分之间以空格分开。request line 和每个 header 各占一行，以换行符 CRLF（即 \\r\\n）分割。</p><p><strong>2.2. POST请求</strong></p><p>下面是浏览器对 http://localhost:8081/test 的 POST 请求时发送给服务器的数据，同样带上参数 name=XXG&amp;age=23：</p><p><img src=\"http://images2015.cnblogs.com/blog/897247/201606/897247-20160619225531054-67446933.jpg\" alt=\" \" /></p><p>可以看出，上面的请求包含三个部分：request line、header、message，比之前的 GET 请求多了一个 message body，其中 header 和 message body 之间用一个空行分割。POST 请求的参数不在 URL 中，而是在 message body 中，header 中多了一项 Content-Length 用于表示 message body 的字节数，这样服务器才能知道请求是否发送结束。这也就是 GET 请求和 POST 请求的主要区别。</p><p>HTTP 响应和 HTTP 请求非常相似，HTTP 响应包含三个部分：status line、header、massage body。其中 status line 包含 protocol version、状态码（status code）、reason phrase 三部分。状态码用于描述 HTTP 响应的状态，例如 200 表示成功，404 表示资源未找到，500 表示服务器出错。</p><p><img src=\"http://images2015.cnblogs.com/blog/897247/201606/897247-20160619225733148-810151360.jpg\" alt=\" \" /></p><p>在上面的 HTTP 响应中，Header 中的 Content-Length 同样用于表示 message body 的字节数。Content-Type 表示 message body 的类型，通常浏览网页其类型是HTML，当然还会有其他类型，比如图片、视频等。</p><p><strong>2.3. HTTP POST Content-Type</strong></p><p>HTTP/1.1 协议规定的 HTTP 请求方法有 OPTIONS、GET、HEAD、POST、PUT、DELETE、TRACE、CONNECT 这几种。其中 POST 一般用来向服务端提交数据，本文讨论主要的几种 POST 提交数据方式。</p><p>我们知道，HTTP 协议是以 ASCII 码传输，建立在 TCP/IP 协议之上的应用层规范。规范把 HTTP 请求分为三个部分：状态行、请求头、消息主体。类似于下面这样：</p><div class=\"cnblogs_code\"><pre class=\"crayon-plain-tag\">&lt;method&gt; &lt;request-URL&gt; &lt;version&gt;
&lt;headers&gt;
&lt;entity-body&gt;</pre></div><p>协议规定 POST 提交的数据必须放在消息主体（entity-body）中，但协议并没有规定数据必须使用什么编码方式。实际上，开发者完全可以自己决定消息主体的格式，只要最后发送的 HTTP 请求满足上面的格式就可以。</p><p>但是，数据发送出去，还要服务端解析成功才有意义。一般服务端语言如 php、python 等，以及它们的 framework，都内置了自动解析常见数据格式的功能。服务端通常是根据请求头（headers）中的 Content-Type 字段来获知请求中的消息主体是用何种方式编码，再对主体进行解析。所以说到 POST 提交数据方案，包含了 Content-Type 和消息主体编码方式 Charset 两部分。下面就正式开始介绍它们。</p><p><strong>2.3.1. application/x-www-form-urlencoded</strong></p><p>这应该是最常见的 POST 提交数据的方式了。浏览器的原生 Form 表单，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据。请求类似于下面这样（无关的请求头在本文中都省略掉了）：</p><div class=\"cnblogs_code\"><pre class=\"crayon-plain-tag\">POST http://www.example.com HTTP/1.1
Content-Type: application/x-www-form-urlencoded;charset=utf-8

title=test&amp;sub%5B%5D=1&amp;sub%5B%5D=2&amp;sub%5B%5D=3</pre></div><p>首先，Content-Type 被指定为 application/x-www-form-urlencoded；其次，提交的数据按照 key1=val1&amp;key2=val2 的方式进行编码，key 和 val 都进行了 URL 转码。大部分服务端语言都对这种方式有很好的支持。</p><p>很多时候，我们用 Ajax 提交数据时，也是使用这种方式。例如 JQuery 的 Ajax，Content-Type 默认值都是 application/x-www-form-urlencoded;charset=utf-8 。</p><p><strong>2.3.2. multipart/form-data</strong></p><p>这又是一个常见的 POST 数据提交的方式。我们使用表单上传文件时，必须让 Form 的 enctyped 等于这个值。直接来看一个请求示例：</p><div class=\"cnblogs_code\"><pre class=\"crayon-plain-tag\">POST http://www.example.com HTTP/1.1
Content-Type:multipart/form-data; boundary=----WebKitFormBoundaryrGKCBY7qhFd3TrwA

------WebKitFormBoundaryrGKCBY7qhFd3TrwA
Content-Disposition: form-data; name=&quot;text&quot;

title
------WebKitFormBoundaryrGKCBY7qhFd3TrwA
Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;chrome.png&quot;
Content-Type: image/png

PNG ... content of chrome.png ...
------WebKitFormBoundaryrGKCBY7qhFd3TrwA--</pre></div><p>这个例子稍微复杂点。首先生成了一个 boundary 用于分割不同的字段，为了避免与正文内容重复，boundary 很长很复杂。然后 Content-Type 里指明了数据是以 mutipart/form-data 来编码，本次请求的 boundary 是什么内容。消息主体里按照字段个数又分为多个结构类似的部分，每部分都是以 –boundary 开始，紧接着内容描述信息，然后是回车，最后是字段具体内容（文本或二进制）。如果传输的是文件，还要包含文件名和文件类型信息。消息主体最后以 –boundary– 标示结束。</p><p>这种方式一般用来上传文件，各大服务端语言对它也有着良好的支持。</p><p>上面提到的这两种 POST 数据的方式，都是浏览器原生支持的，而且现阶段原生 Form 表单也只支持这两种方式。但是随着越来越多的 Web 站点，尤其是 WebApp，全部使用 Ajax 进行数据交互之后，我们完全可以定义新的数据提交方式，给开发带来更多便利。</p><p><strong>2.3.3. application/json</strong></p><p>application/json 这个 Content-Type 作为响应头大家肯定不陌生。实际上，现在越来越多的人把它作为请求头，用来告诉服务端消息主体是序列化后的 JSON 字符串。由于 JSON 规范的流行，除了低版本 IE 之外的各大浏览器都原生支持 JSON.stringify，服务端语言也都有处理 JSON 的函数，使用 JSON 不会遇上什么麻烦。</p><p>JSON 格式支持比键值对复杂得多的结构化数据，这一点也很有用，当需要提交的数据层次非常深，就可以考虑把数据 JSON 序列化之后来提交的。</p><div class=\"cnblogs_code\"><pre class=\"crayon-plain-tag\">var data = {'title':'test', 'sub' : [1,2,3]};
$http.post(url, data).success(function(result) {
...
});</pre></div><p>最终发送的请求是：</p><div class=\"cnblogs_code\"><pre class=\"crayon-plain-tag\">POST http://www.example.com HTTP/1.1
Content-Type: application/json;charset=utf-8

{&quot;title&quot;:&quot;test&quot;,&quot;sub&quot;:[1,2,3]}</pre></div><p>这种方案，可以方便的提交复杂的结构化数据，特别适合 RESTful 的接口。各大抓包工具如 Chrome 自带的开发者工具、Fiddler，都会以树形结构展示 JSON 数据，非常友好。</p><p>其他几种 Content-Type 就不一一详细介绍了，感兴趣的童鞋请自行了解。下面进入 netty 支持 HTTP 协议的源码分析阶段。</p><p><strong>3. netty HTTP 编解码</strong></p><p>要通过 netty 处理 HTTP 请求，需要先进行编解码。</p><p><strong>3.1. netty 自带 HTTP 编解码器</strong></p><p>netty5 提供了对 HTTP 协议的几种编解码器：</p><p><strong>3.1.1. HttpRequestDecoder</strong></p><div class=\"cnblogs_code\"><pre class=\"crayon-plain-tag\">Decodes ByteBuf into HttpRequest and HttpContent.</pre></div><p>即把 ByteBuf 解码到 HttpRequest 和 HttpContent。</p><p><strong>3.1.2. HttpResponseEncoder</strong></p><div class=\"cnblogs_code\"><pre class=\"crayon-plain-tag\">Encodes an HttpResponse or an HttpContent into a ByteBuf.</pre></div><p>即把 HttpResponse 或 HttpContent 编码到 ByteBuf。</p><p><strong>3.1.3. HttpServerCodec</strong></p><div class=\"cnblogs_code\"><pre class=\"crayon-plain-tag\">A combination of HttpRequestDecoder and HttpResponseEncoder which enables easier server side HTTP implementation.</pre></div><p>即 HttpRequestDecoder 和 HttpResponseEncoder 的结合。</p><p>因此，基于 netty 实现 HTTP 服务端时，需要在 ChannelPipeline 中加上以上编解码器：</p><div class=\"cnblogs_code\"><pre class=\"crayon-plain-tag\">ch.pipeline().addLast(&quot;codec&quot;,new HttpServerCodec())</pre></div><p>或者</p><div class=\"cnblogs_code\"><pre class=\"crayon-plain-tag\">ch.pipeline().addLast(&quot;decoder&quot;,new HttpRequestDecoder())
             .addLast(&quot;encoder&quot;,new HttpResponseEncoder())</pre></div><p>然而，以上编解码器只能够支持部分 HTTP 请求解析，比如 HTTP GET请求所传递的参数是包含在 uri 中的，因此通过 HttpRequest 既能解析出请求参数。但是，对于 HTTP POST 请求，参数信息是放在 message body 中的（对应于 netty 来说就是 HttpMessage），所以以上编解码器并不能完全解析 HTTP POST请求。</p><p>这种情况该怎么办呢？别慌，netty 提供了一个 handler 来处理。</p><p><strong>3.1.4. HttpObjectAggregator</strong></p><div class=\"cnblogs_code\"><pre class=\"crayon-plain-tag\">A ChannelHandler that aggregates an HttpMessage and its following HttpContent into a single FullHttpRequest or FullHttpResponse 
(depending on if it used to handle requests or responses) with no following HttpContent.  
It is useful when you don't want to take care of HTTP messages whose transfer encoding is 'chunked'.</pre></div><p>即通过它可以把 HttpMessage 和 HttpContent 聚合成一个 FullHttpRequest 或者 FullHttpResponse （取决于是处理请求还是响应），而且它还可以帮助你在解码时忽略是否为“块”传输方式。</p><p>因此，在解析 HTTP POST 请求时，请务必在 ChannelPipeline 中加上 HttpObjectAggregator。（具体细节请自行查阅代码）</p><p>当然，netty 还提供了其他 HTTP 编解码器，有些涉及到高级应用（较复杂的应用），在此就不一一解释了，以上只是介绍netty HTTP 协议栈最基本的编解码器（切合文章主题<strong>——浅析</strong>）。</p><p><strong>3.2. HTTP GET 解析实践</strong></p><p>上面提到过，HTTP GET 请求的参数是包含在 uri 中的，可通过以下方式解析出 uri：</p><div class=\"cnblogs_code\"><pre class=\"crayon-plain-tag\">HttpRequest request = (HttpRequest) msg;
String uri = request.uri();</pre></div><p>特别注意的是，用浏览器发起 HTTP 请求时，常常会被 uri = &#8220;/favicon.ico&#8221; 所干扰，因此最好对其特殊处理：</p><div class=\"cnblogs_code\"><pre class=\"crayon-plain-tag\">if(uri.equals(FAVICON_ICO)){
    return;
}</pre></div><p>接下来就是解析 uri 了。这里需要用到 <strong>QueryStringDecoder</strong>：</p><div class=\"cnblogs_code\"><pre class=\"crayon-plain-tag\">Splits an HTTP query string into a path string and key-value parameter pairs.
 This decoder is for one time use only.  Create a new instance for each URI:
 
 QueryStringDecoder decoder = new QueryStringDecoder(&quot;/hello?recipient=world&amp;amp;x=1;y=2&quot;);
 assert decoder.getPath().equals(&quot;/hello&quot;);
 assert decoder.getParameters().get(&quot;recipient&quot;).get(0).equals(&quot;world&quot;);
 assert decoder.getParameters().get(&quot;x&quot;).get(0).equals(&quot;1&quot;);
 assert decoder.getParameters().get(&quot;y&quot;).get(0).equals(&quot;2&quot;);

 This decoder can also decode the content of an HTTP POST request whose
 content type is application/x-www-form-urlencoded:

 QueryStringDecoder decoder = new QueryStringDecoder(&quot;recipient=world&amp;amp;x=1;y=2&quot;, false);
 ...</pre></div><p>从上面的描述可以看出，QueryStringDecoder 的作用就是把 HTTP uri 分割成 path 和 key-value 参数对，也可以用来解码 Content-Type = &#8220;application/x-www-form-urlencoded&#8221; 的 HTTP POST。特别注意的是，该 decoder 仅能使用一次。</p><p>解析代码如下：</p><div class=\"cnblogs_code\"><pre class=\"crayon-plain-tag\">String uri = request.uri();
HttpMethod method = request.method();
if(method.equals(HttpMethod.GET)){
　　QueryStringDecoder queryDecoder = new QueryStringDecoder(uri, Charsets.toCharset(CharEncoding.UTF_8));
　　Map&lt;String, List&lt;String&gt;&gt; uriAttributes = queryDecoder.parameters();
　　//此处仅打印请求参数（你可以根据业务需求自定义处理）
　　for (Map.Entry&lt;String, List&lt;String&gt;&gt; attr : uriAttributes.entrySet()) {
　　　　for (String attrVal : attr.getValue()) {
　　　　　　System.out.println(attr.getKey() + \"=\" + attrVal);
　　　　}
　　}
}</pre></div><p><strong>3.3. HTTP POST 解析实践</strong></p><p>如3.1.4小结所说的那样，解析 HTTP POST 请求的 message body，一定要使用 HttpObjectAggregator。但是，是否一定要把 msg 转换成 FullHttpRequest 呢？答案是否定的，且往下看。</p><p>首先解释下 FullHttpRequest 是什么：</p><div class=\"cnblogs_code\"><pre class=\"crayon-plain-tag\">Combinate the HttpRequest and FullHttpMessage, so the request is a complete HTTP request.</pre></div><p>即 FullHttpRequest 包含了 HttpRequest 和 FullHttpMessage，是一个 HTTP 请求的完全体。</p><p>而把 msg 转换成 FullHttpRequest 的方法很简单：</p><div class=\"cnblogs_code\"><pre class=\"crayon-plain-tag\">FullHttpRequest fullRequest = (FullHttpRequest) msg;</pre></div><p>接下来就是分几种 Content-Type 进行解析了。</p><p><strong>3.3.1. 解析 application/json</strong></p><p>处理 JSON 格式是非常方便的，我们只需要将 msg 转换成 FullHttpRequest，然后将其 content 反序列化成 JSONObject 对象即可，如下：</p><div class=\"cnblogs_code\"><pre class=\"crayon-plain-tag\">FullHttpRequest fullRequest = (FullHttpRequest) msg;
String jsonStr = fullRequest.content().toString(Charsets.toCharset(CharEncoding.UTF_8));
JSONObject obj = JSON.parseObject(jsonStr);
for(Entry&lt;String, Object&gt; item : obj.entrySet()){
　　System.out.println(item.getKey()+\"=\"+item.getValue().toString());
}</pre></div><p><strong>3.3.2. 解析 application/x-www-form-urlencoded</strong></p><p>解析此类型有两种方法，一种是使用 QueryStringDecoder，另外一种就是使用 HttpPostRequestDecoder。</p><p><strong>方法一：</strong>3.2节中讲 QueryStringDecoder 时提到：QueryStringDecoder 可以用来解码 Content-Type = &#8220;application/x-www-form-urlencoded&#8221; 的 HTTP POST。因此我们可以用它来解析 message body，剩下的处理就跟 HTTP GET没什么两样了：</p><div class=\"cnblogs_code\"><pre class=\"crayon-plain-tag\">FullHttpRequest fullRequest = (FullHttpRequest) msg;
String jsonStr = fullRequest.content().toString(Charsets.toCharset(CharEncoding.UTF_8));
QueryStringDecoder queryDecoder = new QueryStringDecoder(jsonStr, false);
Map&lt;String, List&lt;String&gt;&gt; uriAttributes = queryDecoder.parameters();
for (Map.Entry&lt;String, List&lt;String&gt;&gt; attr : uriAttributes.entrySet()) {
　　for (String attrVal : attr.getValue()) {
        System.out.println(attr.getKey()+\"=\"+attrVal);
    }
}</pre></div><p><strong>方法二：</strong>使用 HttpPostRequestDecoder 解析时，无需先将 msg 转换成 FullHttpRequest。</p><p>我们先来了解下 <strong>HttpPostRequestDecoder</strong> ：</p><div class=\"cnblogs_code\"><pre class=\"crayon-plain-tag\">public HttpPostRequestDecoder(HttpDataFactory factory, HttpRequest request, Charset charset) {
　　if (factory == null) {
　　　　throw new NullPointerException(&quot;factory&quot;);
　　}
　　if (request == null) {
　　　　throw new NullPointerException(&quot;request&quot;);
　　}
　　if (charset == null) {
　　　　throw new NullPointerException(&quot;charset&quot;);
　　}
　　// Fill default values
　　if (isMultipart(request)) {
　　　　decoder = new HttpPostMultipartRequestDecoder(factory, request, charset);
　　} else {
　　　　decoder = new HttpPostStandardRequestDecoder(factory, request, charset);
　　}
}</pre></div><p>由它的定义可知，它的内部实现其实有两种方式，一种是针对 multipart 类型的解析，一种是普通类型的解析。这两种方式的具体实现中，我把它们相同的代码提取出来，如下：</p><div class=\"cnblogs_code\"><pre class=\"crayon-plain-tag\">if (request instanceof HttpContent) {
　　// Offer automatically if the given request is als type of HttpContent
　　offer((HttpContent) request);
} else {
　　undecodedChunk = buffer();
　　parseBody();
}</pre></div><p>由于我们使用过 HttpObjectAggregator， request 都是 HttpContent 类型，因此会 Offer automatically，我们就不必自己手动去 offer 了，也不用处理 Chunk，所以使用 HttpObjectAggregator 确实是带来了很多简便的。</p><p>好了，接下来就是使用 HttpPostRequestDecoder 来解析了，直接上代码：</p><div class=\"cnblogs_code\"><pre class=\"crayon-plain-tag\">HttpRequest request = (HttpRequest) msg;
HttpPostRequestDecoder decoder = new HttpPostRequestDecoder(factory, request, Charsets.toCharset(CharEncoding.UTF_8));
List&lt;InterfaceHttpData&gt; datas = decoder.getBodyHttpDatas();
for (InterfaceHttpData data : datas) {
　　if(data.getHttpDataType() == HttpDataType.Attribute) {
　　　　Attribute attribute = (Attribute) data;
　　　　System.out.println(attribute.getName() + \"=\" + attribute.getValue());
　　}
}</pre></div><p>是不是很简单？没错。但是这里有点我要说明下， InterfaceHttpData 是一个interface，没有 API 可以直接拿到它的 value。那怎么办呢？莫方，在它的类内部定义了个枚举类型，如下：</p><div class=\"cnblogs_code\"><pre class=\"crayon-plain-tag\">enum HttpDataType {
　　Attribute, FileUpload, InternalAttribute
}</pre></div><p>这种情况下它是 Attribute 类型，因此你转换一下就能拿到值了。好奇的你可能会问，除 Attribute 外，其他两个是什么时候用呢？没错，接下来马上就讲 FileUpload，至于 InternalAttribute 嘛，老夫就不多说啦，有兴趣可以自己去研究了哈~</p><p><strong>3.3.3. 解析 multipart/form-data （文件上传）</strong></p><p>上面说到了 FileUpload，那在这里就来说说如何使用 netty HTTP 协议栈实现文件上传和保存功能。</p><p>这里依然使用 HttpPostRequestDecoder，废话就不多少了，直接上代码：</p><div class=\"cnblogs_code\"><pre class=\"crayon-plain-tag\">DiskFileUpload.baseDirectory = \"/data/fileupload/\";
HttpRequest request = (HttpRequest) msg;
HttpPostRequestDecoder decoder = new HttpPostRequestDecoder(factory, request, Charsets.toCharset(CharEncoding.UTF_8));
List&lt;InterfaceHttpData&gt; datas = decoder.getBodyHttpDatas();
for (InterfaceHttpData data : datas) {
　　if(data.getHttpDataType() == HttpDataType.FileUpload) {
　　　　FileUpload fileUpload = (FileUpload) data;
　　　　String fileName = fileUpload.getFilename();
　　　　if(fileUpload.isCompleted()) {
　　　　　　//保存到磁盘
　　　　　　StringBuffer fileNameBuf = new StringBuffer(); 
　　　　　　fileNameBuf.append(DiskFileUpload.baseDirectory).append(fileName);
　　　　　　fileUpload.renameTo(new File(fileNameBuf.toString()));
　　　　}
　　}
}</pre></div><p>至于效果，你可以直接在本地起个服务搞个简单的页面，向服务器传个文件就行了。如果你很懒，直接用下面的HTML代码改改将就着用吧：</p><div class=\"cnblogs_code\"><pre class=\"crayon-plain-tag\">&lt;form action=\"http://localhost:8080\" method=\"post\" enctype =\"multipart/form-data\"&gt; 
　　&lt;input id=\"File1\" runat=\"server\" name=\"UpLoadFile\" type=\"file\" /&gt;
　　&lt;input type=\"submit\" name=\"Button\" value=\"上传\" id=\"Button\" /&gt;
&lt;/form&gt;</pre></div><p>至于其他类型的 Method、其他类型的 Content-Type，我也不打算细无巨细一一给大伙儿详细讲解了，看看上面罗列的，其实都很简单是不是？</p><p>上面说的都是 netty 自己实现的东西，下面就来讲讲如何实现一个简单的 HTTP decoder。</p><p><strong>4. 自定义 HTTP POST 的 message body 解码器</strong></p><p>关于解码器，我也不打算实现很复杂很牛逼的，只是写了两个粗糙的 decoder，一个是带参数的一个是不带参数的。既然是浅析，那就下面就简单的聊聊。</p><p>如果你要实现一个顶层解码器，就要继承 MessageToMessageDecoder 并重写其 decode 方法。MessageToMessageDecoder 继承了 ChannelHandlerAdapter，也就是说解码器其实就是一个 handler，只不过是专门用来做解码的事情。下面我们来看看它重写的 channelRead 方法：</p><div class=\"cnblogs_code\"><pre class=\"crayon-plain-tag\">@Override
public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
　　RecyclableArrayList out = RecyclableArrayList.newInstance();
　　try {
　　　　if (acceptInboundMessage(msg)) {
　　　　　　@SuppressWarnings(\"unchecked\")
　　　　　　I cast = (I) msg;
　　　　　　try {
　　　　　　　　decode(ctx, cast, out);
　　　　　　} finally {
　　　　　　　　ReferenceCountUtil.release(cast);
　　　　　　}
　　　　} else {
　　　　　　out.add(msg);
　　　　}
　　} catch (DecoderException e) {
　　　　throw e;
　　} catch (Exception e) {
　　　　throw new DecoderException(e);
　　} finally {
　　　　int size = out.size();
　　　　for (int i = 0; i &lt; size; i ++) {
　　　　　　ctx.fireChannelRead(out.get(i));
　　　　}
　　　　out.recycle();
　　}
}</pre></div><p>其中 decode 方法是你实现 decoder 时需要重写的，经过解码之后，会调用 ctx.fireChannelRead() 将 out 传递给给下一个 handler 执行相关逻辑。</p><p><strong>4.1. HttpJsonDecoder</strong></p><p>从名字可以看出，这是个针对 message body 为 JsonString 的解码器。处理过程很简单，只需要把 HTTP 请求的 content （即 ByteBuf）的可读字节转换成 JSONObject 对象，如下：</p><div class=\"cnblogs_code\"><pre class=\"crayon-plain-tag\">@Override
protected void decode(ChannelHandlerContext ctx, HttpRequest msg, List&lt;Object&gt; out) throws Exception {
　　FullHttpRequest fullRequest = (FullHttpRequest) msg;
　　ByteBuf content = fullRequest.content();
　　int length = content.readableBytes();
　　byte[] bytes = new byte[length];
　　for(int i=0; i&lt;length; i++){
　　　　bytes[i] = content.getByte(i);
　　}
　　try{
　　　　JSONObject obj = JSON.parseObject(new String(bytes));
　　　　out.add(obj);
　　}catch(ClassCastException e){
　　　　throw new CodecException(\"HTTP message body is not a JSONObject\");
　　}
}</pre></div><p>使用方法也很简单，在 Server 的 HttpServerCodec() 和 HttpObjectAggregator() 后面加上：</p><div class=\"cnblogs_code\"><pre class=\"crayon-plain-tag\">.addLast(&quot;jsonDecoder&quot;, new HttpJsonDecoder())</pre></div><p>然后在业务 handler channelRead方法中使用即可：</p><div class=\"cnblogs_code\"><pre class=\"crayon-plain-tag\">if(msg instanceof JSONObject){
　　JSONObject obj = (JSONObject) msg;
　　......
 }</pre></div><p><strong>4.2. HttpProtobufDecoder</strong></p><p>这是一个带参数的 decoder，用来解析使用 protobuf 序列化后的 message body。使用的时候需要传递 MessageLite 进来，直接上代码：</p><div class=\"cnblogs_code\"><pre class=\"crayon-plain-tag\">private final MessageLite prototype;
    
public HttpProtobufDecoder(MessageLite prototype){
　　if (prototype == null) {
　　　　throw new NullPointerException(\"prototype\");
　　}
　　this.prototype = prototype.getDefaultInstanceForType();
}
    
@Override
protected void decode(ChannelHandlerContext ctx, HttpRequest msg, List&lt;Object&gt; out) {
　　FullHttpRequest fullRequest = (FullHttpRequest) msg;
　　ByteBuf content = fullRequest.content();
　　int length = content.readableBytes();
　　byte[] bytes = new byte[length];
　　for(int i=0; i&lt;length; i++){
　　　　bytes[i] = content.getByte(i);
　　}
　　try {
　　　　out.add(prototype.getParserForType().parseFrom(bytes, 0, length));
　　} catch (InvalidProtocolBufferException e) {
　　　　throw new CodecException(\"HTTP message body is not \" + prototype + \"type\");
　　}
}</pre></div><p>使用方法跟 HttpJsonDecoder无异。此处以 protobuf 对象 UserProtobuf.User 为例，在 Server 的 HttpServerCodec() 和 HttpObjectAggregator() 后面加上：</p><div class=\"cnblogs_code\"><pre class=\"crayon-plain-tag\">.addLast(&quot;protobufDecoder&quot;, new HttpProtobufDecoder(UserProbuf.User.getDefaultInstance()))</pre></div><p>然后在业务 handler channelRead方法中使用即可：</p><div class=\"cnblogs_code\"><pre class=\"crayon-plain-tag\">if(msg instanceof UserProbuf.User){
　　UserProbuf.User user = (UserProbuf.User) msg;
　　......
}</pre></div><p><strong>5. 聊聊开发中遇到的问题【推荐】</strong></p><p>如果你没有亲自使用过 netty 却说自己熟悉甚至精通 netty，我劝你千万别这么做，因为你的脸会被打肿的。netty 作为一个异步非阻塞的 IO 框架，它到底多牛逼在这就不多扯了，而作为一个首次使用 netty HTTP 协议栈的我来说，踩坑是必不可少的过程。当然了，踩了坑就要填上，我还很乐意在这把我踩过的几个坑给大家分享下，前车之鉴。</p><p><strong>5.1. 关于内存泄漏</strong></p><p>首先说下经历的情况。在文章开篇提到的接收服务，经过多轮的单元测试几乎没发现什么问题，于是对于接下来的压力测试我是自信满满。然而，当我第一次跑压测时就抛出一个异常，如下：</p><div class=\"cnblogs_code\"><pre class=\"crayon-plain-tag\">[ERROR] 2016-07-24 15:25:46 [io.netty.util.internal.logging.Slf4JLogger:176] - LEAK: ByteBuf.release() was not called before it's garbage-collected. Enable advanced leak reporting to find out where the leak occurred. To enable advanced leak reporting, specify the JVM option '-Dio.netty.leakDetectionLevel=advanced' or call ResourceLeakDetector.setLevel() See http://netty.io/wiki/reference-counted-objects.html for more information.</pre></div><p>着实让我开心了一把，终于出现异常了！异常信息表达的是 “ByteBuf 在被 JVM GC 之前没有调用 ByteBuf.release() ，启用高级泄漏报告，找出发生泄漏的地方”，于是马上google了一把，原来是从 netty4 开始，对象的生命周期由它们的引用计数（reference counts）管理，而不是由垃圾收集器（garbage collector）管理了。</p><p>要解决这个问题，先从源头了解开始。</p><p><strong>5.1.1. netty 引用计数对象<sup>【2】</sup></strong></p><p>对于 netty Inbound message，当 event loop 读入了数据并创建了 ByteBuf，并用这个 ByteBuf 触发了一个 channelRead() 事件时，那么管道（pipeline）中相应的ChannelHandler 就负责释放这个 buffer 。因此，处理接数据的 handler 应该在它的 channelRead() 中调用 buffer 的 release()，如下：</p><div class=\"cnblogs_code\"><pre class=\"crayon-plain-tag\">public void channelRead(ChannelHandlerContext ctx, Object msg) {
    ByteBuf buf = (ByteBuf) msg;
    try {
        ...
    } finally {
        buf.release();
    }
}</pre></div><p>而有时候，ByteBuf 会被一个 buffer holder 持有，它们都扩展了一个公共接口 ByteBufHolder。正因如此， ByteBuf 并不是 netty 中唯一一种引用计数对象。由 decoder 生成的消息对象很可能也是引用计数对象，比如 HTTP 协议栈中的 HttpContent，因为它也扩展了 ByteBufHolder。</p><div class=\"cnblogs_code\"><pre class=\"crayon-plain-tag\">public void channelRead(ChannelHandlerContext ctx, Object msg) {
    if (msg instanceof HttpRequest) {
        HttpRequest req = (HttpRequest) msg;
        ...
    }
    if (msg instanceof HttpContent) {
        HttpContent content = (HttpContent) msg;
        try {
            ...
        } finally {
            content.release();
        }
    }
}</pre></div><p>如果你抱有疑问，或者你想简化这些释放消息的工作，你可以使用 ReferenceCountUtil.release()：</p><div class=\"cnblogs_code\"><pre class=\"crayon-plain-tag\">public void channelRead(ChannelHandlerContext ctx, Object msg) {
    try {
        ...
    } finally {
        ReferenceCountUtil.release(msg);
    }
}</pre></div><p>或者可以考虑继承 SimpleChannelHandler，它在所有接收消息的地方都调用了 ReferenceCountUtil.release(msg)。</p><p>对于 netty Outbound message，你的程序所创建的消息对象都由 netty 负责释放，释放的时机是在这些消息被发送到网络之后。但是，在发送消息的过程中，如果有 handler 截获（intercept）了你的发送请求并创建了一些中间对象，则这些 handler 要确保正确释放这些中间对象。比如 encoder，此处不赘述。</p><p>通过以上信息，自然就很容易找到 OOM 问题的原因所在了。由于在处理 HTTP 请求过程中没有释放 ByteBuf，因此在代码 finally 块中加上 ReferenceCountUtil.release(msg) 就解决啦！</p><p><strong>5.1.2. 如何规避内存泄漏<sup>【3】</sup></strong></p><p>netty 提供了内存泄漏的监测机制，默认就会从分配的 ByteBuf 里抽样出大约 1% 的来进行跟踪。如果泄漏，就会打印5.1.1节中的异常信息，并提示你通过指定 JVM 选项</p><div class=\"cnblogs_code\"><pre class=\"crayon-plain-tag\">-Dio.netty.leakDetectionLevel=advanced</pre></div><p>来查看泄漏报告。泄漏年监测有4个等级：</p><ul><li>禁用（DISABLED） &#8211; 完全禁止泄露检测，省点消耗。</li><li>简单（SIMPLE） &#8211; 默认等级，告诉我们取样的 1% 的 ByteBuf 是否发生了泄露，但总共一次只打印一次，看不到就没有了。</li><li>高级（ADVANCED） &#8211; 告诉我们取样的 1% 的 ByteBuf 发生泄露的地方。每种类型的泄漏（创建的地方与访问路径一致）只打印一次。</li><li>偏执（PARANOID） &#8211; 跟高级选项类似，但此选项检测所有 ByteBuf，而不仅仅是取样的那 1%。在高压力测试时，对性能有明显影响。</li></ul><p>一般情况下我们采用 SIMPLE 级别即可。</p><p><strong>5.2. 关于 HTTP 长连接</strong></p><p>按照惯例，先说下开发中踩到的坑。</p><p>对于接收服务，我采用的是 nginx + netty http，其中 nginx 配置如下（阉割隐藏版）：</p><div class=\"cnblogs_code\"><pre class=\"crayon-plain-tag\">upstream xxx.com{
        keepalive 32;
        server xxxx.xx.xx.xx:8080;
}
server{
        listen  80;
         server_name     xxx.com;
        location / {
                proxy_next_upstream http_502 http_504 error timeout invalid_header;
                proxy_pass xxx.com;
                proxy_http_version 1.1;
                proxy_set_header Connection &quot;&quot;;
                #proxy_set_header  Host             $host;
                #proxy_set_header  X-Forwarded-For  $remote_addr;
                #proxy_set_header  REMOTE_ADDR      $remote_addr;
                #proxy_set_header  X-Real-IP     $remote_addr;
                proxy_read_timeout 60s;
                client_max_body_size 1m;
        }
        error_page   500 502 503 504  /50x.html;
        location = /50x.html{
                root   html;
        }
}</pre></div><p>然后编写了一个简单的 HttpClient 发送消息，如下（截取）：</p><pre class=\"crayon-plain-tag\">OutputStream outStream = conn.getOutputStream();
outStream.write(data);
outStream.flush();
outStream.close();
             
if (conn.getResponseCode() == 200) {
　　&lt;span style=\"color: #ff0000;\"&gt;BufferedReader in = new BufferedReader(new InputStreamReader((InputStream) conn.getInputStream(), \"UTF-8\"));&lt;/span&gt;
　　String msg = in.readLine();
　　System.out.println(\"msg = \" + msg);
　　in.close();
}
conn.disconnect();</pre><p>接着，正常发送 HTTP 请求到服务器，然而，老夫整整等了60多秒才接到响应信息！而且每次都这样！！</p><p>我首先怀疑是不是 ngxin 出问题了，有一个配置项立马引起了我的怀疑，没错，就是上面红色的那行 proxy_read_timeout 60s; 。为了验证，我首先把 60s 改成了 10s，效果很明显，发送的请求 10 秒过一点就收到响应了！更加彻底证明是 nginx 的锅，我去掉了 nginx，让客户端直接发送请求给服务端。然而，蛋疼的事情出现了，客户端竟然一直阻塞在 BufferedReader in = new BufferedReader(new InputStreamReader((InputStream) conn.getInputStream(), &#8220;UTF-8&#8221;)); 处。这说明根本就不是 nginx 的问题啊！</p><p>我冷静下来，review 了一下代码同时 search 了相关资料，发现了一个小小的区别，在我的返回代码中，对 ChannelFuture 少了对 CLOSE 事件的监听器：</p><div class=\"cnblogs_code\"><pre class=\"crayon-plain-tag\">ctx.writeAndFlush(response)&lt;span class=&quot;pl-k&quot;&gt;.addListener(&lt;span class=&quot;pl-smi&quot;&gt;ChannelFutureListener&lt;span class=&quot;pl-c1&quot;&gt;&lt;span class=&quot;pl-k&quot;&gt;.CLOSE)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;;</pre></div><p>于是，我加上 Listener 再试一下，马上就得到响应了！</p><p>就在这一刻明白了这是 HTTP 长连接的问题。首先从上面的 nginx 配置中可以看到，我显式指定了 nginx 和 HTTP 服务器是用的 HTTP1.1 版本，HTTP1.1 版本默认是长连接方式（也就是 Connection=Keep-Alive），而我在 netty HTTP 服务器中并没有对长、短连接方式做区别处理，并且在 HttpResponse 响应中并没有显式加上 Content-Length 头部信息，恰巧 netty Http 协议栈并没有在框架上做这件工作，导致服务端虽然把响应消息发出去了，但是客户端并不知道你是否发送完成了（即没办法判断数据是否已经发送完）。</p><p>于是，把响应的处理完善一下即可：</p><div class=\"cnblogs_code\"><pre class=\"crayon-plain-tag\">/**
 * 响应报文处理
 * @param channel 当前上下文Channel
 * @param status 响应码
 * @param msg 响应消息
 * @param forceClose 是否强制关闭
 */
private void writeResponse(Channel channel, HttpResponseStatus status, String msg, boolean forceClose){
　　ByteBuf byteBuf = Unpooled.wrappedBuffer(msg.getBytes());
　　response = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, status, byteBuf);
　　boolean close = isClose();
　　if(!close &amp;&amp;!forceClose){
　　　　response.headers().add(org.apache.http.HttpHeaders.CONTENT_LENGTH, String.valueOf(byteBuf.readableBytes()));
　　}
　　ChannelFuture future = channel.write(response);
　　　　if(close || forceClose){
　　　　　　future.addListener(ChannelFutureListener.CLOSE);
　　　　}
　　}
private boolean isClose(){
　　if(request.headers().contains(org.apache.http.HttpHeaders.CONNECTION, CONNECTION_CLOSE, true) ||
　　　　(request.protocolVersion().equals(HttpVersion.HTTP_1_0) &amp;&amp; 
　　　　　　!request.headers().contains(org.apache.http.HttpHeaders.CONNECTION, CONNECTION_KEEP_ALIVE, true)))
　　　　return true;
　　return false;
}</pre></div><p>好了，问题是解决了，那么你对 HTTP 长连接真的了解吗？不了解，好，那就来不补课。</p><p><strong>5.2.1. TCP KeepAlive 和 HTTP KeepAlive<sup>【4】</sup></strong></p><p>netty 中有个地方比较让初学者迷惑，就是 childOption(<span class=\"pl-smi\">ChannelOption<span class=\"pl-c1\"><span class=\"pl-k\">.SO_KEEPALIVE, <span class=\"pl-c1\">true) 和 HttpRequest.Headers.get(&#8220;Connection&#8221;).equals(&#8220;Keep-Alive&#8221;) （非标准写法，仅作示例）的异同。有些人可能会问，我在 <span class=\"pl-smi\">ServerBootstrap 中指定了 childOption(<span class=\"pl-smi\">ChannelOption<span class=\"pl-c1\"><span class=\"pl-k\">.SO_KEEPALIVE, <span class=\"pl-c1\">true)，是不是就意味着客户端和服务器是长连接了？</span></span></span></span></span></span></span></span></span></p><p><span class=\"pl-smi\"><span class=\"pl-c1\"><span class=\"pl-k\"><span class=\"pl-c1\"><span class=\"pl-smi\"><span class=\"pl-smi\"><span class=\"pl-c1\"><span class=\"pl-k\"><span class=\"pl-c1\">答案当然不是。</span></span></span></span></span></span></span></span></span></p><p><span class=\"pl-smi\"><span class=\"pl-c1\"><span class=\"pl-k\"><span class=\"pl-c1\"><span class=\"pl-smi\"><span class=\"pl-smi\"><span class=\"pl-c1\"><span class=\"pl-k\"><span class=\"pl-c1\">首先，TCP 的 KeepAlive 是 TCP 连接的探测机制，用来检测当前 TCP 连接是否活着。它支持三个系统内核参数</span></span></span></span></span></span></span></span></span></p><ul><li><span class=\"pl-smi\">tcp_keepalive_time</span></li><li><span class=\"pl-smi\">tcp_keepalive_intvl</span></li><li><span class=\"pl-smi\">tcp_keepalive_probes</span></li></ul><p><span class=\"pl-smi\"><span class=\"pl-c1\"><span class=\"pl-k\"><span class=\"pl-c1\"><span class=\"pl-smi\"><span class=\"pl-smi\"><span class=\"pl-c1\"><span class=\"pl-k\"><span class=\"pl-c1\">当网络两端建立了 TCP 连接之后，闲置 idle（双方没有任何数据流发送往来）了 tcp_keepalive_time 后，服务器内核就会尝试向客户端发送侦测包，来判断 TCP 连接状况(有可能客户端崩溃、强制关闭了应用、主机不可达等等)。如果没有收到对方的回答( ACK 包)，则会在 tcp_keepalive_intvl 后再次尝试发送侦测包，直到收到对对方的 ACK，如果一直没有收到对方的 ACK，一共会尝试 tcp_keepalive_probes 次，每次的间隔时间在这里分别是 15s、30s、45s、60s、75s。如果尝试 tcp_keepalive_probes，依然没有收到对方的 ACK 包，则会丢弃该 TCP 连接。TCP 连接默认闲置时间是2小时。</span></span></span></span></span></span></span></span></span></p><p>而对于 HTTP 的 KeepAlive，则是让 TCP 连接活长一点，在一次 TCP 连接中可以持续发送多份数据而不会断开连接。通过使用 keep-alive 机制，可以减少 TCP 连接建立次数，也意味着可以减少 TIME_WAIT 状态连接，以此提高性能和提高 TTTP 服务器的吞吐率（更少的 TCP 连接意味着更少的系统内核调用，socket 的 accept() 和 close() 调用）。</p><p><a href=\"http://jbcdn2.b0.upaiyun.com/2016/08/011ecee7d295c066ae68d4396215c3d0.png\"><img class=\"alignnone size-full wp-image-104095\" src=\"http://jbcdn2.b0.upaiyun.com/2016/08/011ecee7d295c066ae68d4396215c3d0.png\" alt=\"4\" /></a></p><p>对于建立 HTTP 长连接的好处，总结如下<sup>【5】</sup>：</p><ul><li>By opening and closing fewer TCP connections, CPU time is saved in routers and hosts (clients, servers, proxies, gateways, tunnels, or caches), and memory used for TCP protocol control blocks can be saved in hosts.</li><li>HTTP requests and responses can be pipelined on a connection. Pipelining allows a client to make multiple requests without waiting for each response, allowing a single TCP connection to be used much more efficiently, with much lower elapsed time.</li><li>Network congestion is reduced by reducing the number of packets caused by TCP opens, and by allowing TCP sufficient time to determine the congestion state of the network.</li><li>Latency on subsequent requests is reduced since there is no time spent in TCP&#8217;s connection opening handshake.</li><li>HTTP can evolve more gracefully, since errors can be reported without the penalty of closing the TCP connection. Clients using future versions of HTTP might optimistically try a new feature, but if communicating with an older server, retry with old semantics after an error is reported.</li></ul><p><strong> 5.2.2. 长连接方式中如何判断数据发送完成<sup>【6】</sup></strong></p><p>回到本节最开始提出的问题，KeepAlive 模式下，HTTP 服务器在发送完数据后并不会主动断开连接，那客户端如何判断数据发送完成了？</p><p>对于短连接方式，服务端在发送完数据后会断开连接，客户端过服务器关闭连接能确定消息的传输长度。（请求端不能通过关闭连接来指明请求消息体的结束，因为这样让服务器没有机会继续给予响应）。</p><p>但对于长连接方式，服务端只有在 Keep-alive timeout 或者达到 max 请求次数时才会断开连接。这种情况下有两种判断方法。</p><p><strong>使用消息头部 Content-Length</strong></p><p>Conent-Length 表示实体内容长度，客户端（或服务器）可以根据这个值来判断数据是否接收完成。但是如果消息中没有 Conent-Length，那该如何来判断呢？又在什么情况下会没有 Conent-Length 呢？</p><p><strong>使用消息首部字段 Transfer-Encoding</strong></p><p>当请求或响应的内容是动态的，客户端或服务器无法预先知道要传输的数据大小时，就要使用 Transfer-Encoding（即 chunked 编码传输）。chunked 编码将数据分成一块一块的发送。chunked 编码将使用若干个chunk 串连而成，由一个标明长度为 0 的 chunk 标示结束。每个 chunk 分为头部和正文两部分，头部内容指定正文的字符总数（十六进制的数字）和数量单位（一般不写），正文部分就是指定长度的实际内容，两部分之间用回车换行 (CRLF)隔开。在最后一个长度为 0 的 chunk 中的内容是称为footer的内容，是一些附加的Header信息（通常可以直接忽略）。</p><p>如果一个请求包含一个消息主体并且没有给出 Content-Length，那么服务器如果不能判断消息长度的话应该以400响应（Bad Request），或者以411响应（Length Required）如果它坚持想要收到一个有效的 Content-length。所有的能接收实体的 HTTP/1.1 应用程序必须能接受 chunked 的传输编码，因此当消息的长度不能被提前确定时，可以利用这种机制来处理消息。消息不能同时都包括 Content-Length 头域和 非identity （Transfer-Encoding）传输编码。如果消息包括了一个 非identity 的传输编码，Content-Length头域必须被忽略。当 Content-Length 头域出现在一个具有消息主体（message-body）的消息里，它的域值必须精确匹配消息主体里字节数量。</p><p>&nbsp;</p><p>好了，本章较长，虽然不是很深奥难懂的知识，也不是很牛逼的技术实现，但是耐心看完之后相信你终究是有所收获的。在此本文就要完结了，后续会对 netty HTTP 协议栈做更深入的研究，至于<a href=\"https://github.com/cyfonly/netty-http\" target=\"_blank\">这个 github 上的项目</a>，后面也会继续完善 TODO LIST。大家可以通过多种方式与我交流，并欢迎大家提出宝贵意见。</p><p>&nbsp;</p><p><strong>参考文章：</strong></p><p>【1】《<a href=\"http://www.cnblogs.com/wucao/p/3989863.html\" target=\"_blank\">Mina、Netty、Twisted一起学（八）：HTTP服务器</a>》</p><p>【2】《<a href=\"http://damacheng009.iteye.com/blog/2013657\" target=\"_blank\">【Netty官方文档翻译】引用计数对象（reference counted objects）</a>》</p><p>【3】《<a href=\"http://m635674608.iteye.com/blog/2236834\" target=\"_blank\">Netty之有效规避内存泄漏</a>》</p><p>【4】《<a href=\"http://www.92csz.com/17/1152.html\" target=\"_blank\">详解http_keepalive</a>》</p><p>【5】《<a href=\"http://www.cnblogs.com/skynet/archive/2010/12/11/1903347.html\" target=\"_blank\">HTTP Keep-Alive模式</a>》</p><p>【6】《<a href=\"http://www.cnblogs.com/cswuyg/p/3653263.html\" target=\"_blank\">HTTP的长连接和短连接</a>》</p><div class=\"wp_rp_wrap  wp_rp_plain\" id=\"wp_rp_first\"><div class=\"wp_rp_content\"><h3 class=\"related_post_title\">相关文章</h3><ul class=\"related_post wp_rp\" style=\"visibility: visible\"><li ><a href=\"http://blog.jobbole.com/98633/\" class=\"wp_rp_title\">StackOverflow 这么大，它的架构是怎么样的？</a></li><li ><a href=\"http://blog.jobbole.com/21622/\" class=\"wp_rp_title\">SPDY 是什么？如何部署 SPDY？</a></li><li ><a href=\"http://blog.jobbole.com/87509/\" class=\"wp_rp_title\">如何生成每秒百万级别的 HTTP 请求？</a></li><li ><a href=\"http://blog.jobbole.com/42763/\" class=\"wp_rp_title\">HTTP代理与SPDY协议</a></li><li ><a href=\"http://blog.jobbole.com/86660/\" class=\"wp_rp_title\">大型网站的 HTTPS 实践（1）：HTTPS 协议和原理</a></li><li ><a href=\"http://blog.jobbole.com/86670/\" class=\"wp_rp_title\">大型网站的 HTTPS 实践（4）：协议层以外的实践</a></li><li ><a href=\"http://blog.jobbole.com/88199/\" class=\"wp_rp_title\">HTTP 协议漫谈</a></li><li ><a href=\"http://blog.jobbole.com/86664/\" class=\"wp_rp_title\">大型网站的 HTTPS 实践（2）：HTTPS 对性能的影响</a></li><li ><a href=\"http://blog.jobbole.com/84429/\" class=\"wp_rp_title\">通信协议：HTTP、TCP、UDP</a></li><li ><a href=\"http://blog.jobbole.com/93960/\" class=\"wp_rp_title\">HTTP 长连接和短连接</a></li></ul></div></div><p><a href=\"http://blog.jobbole.com/104103/\">Netty5 HTTP协议栈浅析与实践</a>，首发于<a href=\"http://blog.jobbole.com\">文章 - 伯乐在线</a>。</p>") (wfw:commentRss nil "http://blog.jobbole.com/104103/feed/") (slash:comments nil "0"))) ("图解：二叉搜索树算法" "<p style=\"text-align: justify\">“岁月极美，在于它必然的流逝”</p><div><p style=\"text-align: left\">“春花 秋月 夏日 冬雪”<br />
— 三毛</p><h3 style=\"text-align: justify\">一、树 &amp; 二叉树</h3><p style=\"text-align: justify\"><strong>树</strong>是由节点和边构成，储存元素的集合。节点分根节点、父节点和子节点的概念。<br />
如图：树深=4; 5是根节点；同样8与3的关系是父子节点关系。</p><p style=\"text-align: justify\"><a href=\"http://www.bysocket.com/wp-content/uploads/2016/07/1.png\"><img src=\"http://www.bysocket.com/wp-content/uploads/2016/07/1.png\" alt=\"1\" width=\"460\" height=\"527\" /></a><br /><strong>二叉树binary tree</strong>，则加了“二叉”（binary），意思是在树中作区分。每个节点至多有两个子（child）,left child &amp; right child。二叉树在很多例子中使用，比如二叉树表示算术表达式。<br />
如图：1/8是左节点；2/3是右节点；</p><p style=\"text-align: justify\"><a href=\"http://www.bysocket.com/wp-content/uploads/2016/07/2.png\"><img src=\"http://www.bysocket.com/wp-content/uploads/2016/07/2.png\" alt=\"2\" width=\"447\" height=\"445\" /></a></p><h3 style=\"text-align: justify\"><strong>二、二叉搜索树 BST</strong></h3><p style=\"text-align: justify\">顾名思义，二叉树上又加了个搜索的限制。其要求：每个节点比其左子树元素大，比其右子树元素小。<br />
如图：每个节点比它左子树的任意节点大，而且比它右子树的任意节点小</p><p style=\"text-align: justify\"><a href=\"http://www.bysocket.com/wp-content/uploads/2016/07/3.png\"><img src=\"http://www.bysocket.com/wp-content/uploads/2016/07/3.png\" alt=\"3\" width=\"457\" height=\"457\" /></a></p><h3 style=\"text-align: justify\">三、BST Java实现</h3><p style=\"text-align: justify\">直接上代码，对应代码分享在 <a href=\"https://github.com/JeffLi1993/algorithm-core-learning\" target=\"_blank\">Github</a> 主页<br />
BinarySearchTree.java</p><p></p><pre class=\"crayon-plain-tag\">package org.algorithm.tree;
/*
* Copyright [2015] [Jeff Lee]
*
* Licensed under the Apache License, Version 2.0 (the \"License\");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an \"AS IS\" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
/**
* 二叉搜索树(BST)实现
*
* Created by bysocket on 16/7/7.
*/
public class BinarySearchTree {
/**
* 根节点
*/
public static TreeNode root;
public BinarySearchTree() {
this.root = null;
}
/**
* 查找
*      树深(N) O(lgN)
*      1. 从root节点开始
*      2. 比当前节点值小,则找其左节点
*      3. 比当前节点值大,则找其右节点
*      4. 与当前节点值相等,查找到返回TRUE
*      5. 查找完毕未找到,
* @param key
* @return
*/
public TreeNode search (int key) {
TreeNode current = root;
while (current != null
&amp;&amp; key != current.value) {
if (key  key) {
isLeftChild = true;
current = current.left;
} else {
isLeftChild = false;
current = current.right;
}
if (current == null) {
return current;
}
}
// 如果删除节点左节点为空 , 右节点也为空
if (current.left == null &amp;&amp; current.right == null) {
if (current == root) {
root = null;
}
// 在左子树
if (isLeftChild == true) {
parent.left = null;
} else {
parent.right = null;
}
}
// 如果删除节点只有一个子节点 右节点 或者 左节点
else if (current.right == null) {
if (current == root) {
root = current.left;
} else if (isLeftChild) {
parent.left = current.left;
} else {
parent.right = current.left;
}
}
else if (current.left == null) {
if (current == root) {
root = current.right;
} else if (isLeftChild) {
parent.left = current.right;
} else {
parent.right = current.right;
}
}
// 如果删除节点左右子节点都不为空
else if (current.left != null &amp;&amp; current.right != null) {
// 找到删除节点的后继者
TreeNode successor = getDeleteSuccessor(current);
if (current == root) {
root = successor;
} else if (isLeftChild) {
parent.left = successor;
} else {
parent.right = successor;
}
successor.left = current.left;
}
return current;
}
/**
* 获取删除节点的后继者
*      删除节点的后继者是在其右节点树种最小的节点
* @param deleteNode
* @return
*/
public TreeNode getDeleteSuccessor(TreeNode deleteNode) {
// 后继者
TreeNode successor = null;
TreeNode successorParent = null;
TreeNode current = deleteNode.right;
while (current != null) {
successorParent = successor;
successor = current;
current = current.left;
}
// 检查后继者(不可能有左节点树)是否有右节点树
// 如果它有右节点树,则替换后继者位置,加到后继者父亲节点的左节点.
if (successor != deleteNode.right) {
successorParent.left = successor.right;
successor.right = deleteNode.right;
}
return successor;
}
public void toString(TreeNode root) {
if (root != null) {
toString(root.left);
System.out.print(\"value = \" + root.value + \" -&gt; \");
toString(root.right);
}
}
}
/**
* 节点
*/
class TreeNode {
/**
* 节点值
*/
int value;
/**
* 左节点
*/
TreeNode left;
/**
* 右节点
*/
TreeNode right;
public TreeNode(int value) {
this.value = value;
left  = null;
right = null;
}
}</pre><p></p><p style=\"text-align: justify\">1. <strong>节点数据结构</strong><br />
首先定义了节点的数据接口，节点分左节点和右节点及本身节点值。如图</p><p style=\"text-align: justify\"><a href=\"http://www.bysocket.com/wp-content/uploads/2016/07/4.png\"><img src=\"http://www.bysocket.com/wp-content/uploads/2016/07/4.png\" alt=\"4\" width=\"584\" height=\"176\" /></a></p><p style=\"text-align: justify\">代码如下：</p><p></p><pre class=\"crayon-plain-tag\">/**
* 节点
*/
class TreeNode {
/**
* 节点值
*/
int value;
/**
* 左节点
*/
TreeNode left;
/**
* 右节点
*/
TreeNode right;
public TreeNode(int value) {
this.value = value;
left  = null;
right = null;
}
}</pre><p></p><p style=\"text-align: justify\"><strong>2. 插入</strong><br />
插入，和删除一样会引起二叉搜索树的动态变化。插入相对删处理逻辑相对简单些。如图插入的逻辑：</p><p style=\"text-align: justify\"><a href=\"http://www.bysocket.com/wp-content/uploads/2016/07/5.png\"><img src=\"http://www.bysocket.com/wp-content/uploads/2016/07/5.png\" alt=\"5\" width=\"498\" height=\"558\" /></a><br />
a. 从root节点开始<br />
b.如果root为空,root为插入值<br />
c.循环:<br />
d.如果当前节点值大于插入值,找左节点<br />
e.如果当前节点值小于插入值,找右节点<br />
代码对应：</p><p></p><pre class=\"crayon-plain-tag\">/**
* 插入
*      1. 从root节点开始
*      2. 如果root为空,root为插入值
*      循环:
*      3. 如果当前节点值大于插入值,找左节点
*      4. 如果当前节点值小于插入值,找右节点
* @param key
* @return
*/
public TreeNode insert (int key) {
// 新增节点
TreeNode newNode = new TreeNode(key);
// 当前节点
TreeNode current = root;
// 上个节点
TreeNode parent  = null;
// 如果根节点为空
if (current == null) {
root = newNode;
return newNode;
}
while (true) {
parent = current;
if (key</pre><p></p><p style=\"text-align: justify\"><strong>3.查找</strong></p><p style=\"text-align: justify\">其算法复杂度 : O(lgN),树深(N)。如图查找逻辑：</p><p style=\"text-align: justify\"><a href=\"http://www.bysocket.com/wp-content/uploads/2016/07/6.png\"><img src=\"http://www.bysocket.com/wp-content/uploads/2016/07/6.png\" alt=\"6\" width=\"483\" height=\"581\" /></a><br />
a.从root节点开始<br />
b.比当前节点值小,则找其左节点<br />
c.比当前节点值大,则找其右节点<br />
d.与当前节点值相等,查找到返回TRUE<br />
e.查找完毕未找到<br />
代码对应：</p><p></p><pre class=\"crayon-plain-tag\">/**
* 查找
*      树深(N) O(lgN)
*      1. 从root节点开始
*      2. 比当前节点值小,则找其左节点
*      3. 比当前节点值大,则找其右节点
*      4. 与当前节点值相等,查找到返回TRUE
*      5. 查找完毕未找到,
* @param key
* @return
*/
public TreeNode search (int key) {
TreeNode current = root;
while (current != null
&amp;&amp; key != current.value) {
if (key</pre><p></p><p style=\"text-align: justify\">4. 删除<br />
首先找到删除节点，其寻找方法：删除节点的后继者是在其右节点树种最小的节点。如图删除对应逻辑：<a href=\"http://www.bysocket.com/wp-content/uploads/2016/07/7.png\"><img src=\"http://www.bysocket.com/wp-content/uploads/2016/07/7.png\" alt=\"7\" width=\"469\" height=\"473\" /></a></p><p style=\"text-align: justify\">结果为：</p><p style=\"text-align: justify\"><a href=\"http://www.bysocket.com/wp-content/uploads/2016/07/8.png\"><img src=\"http://www.bysocket.com/wp-content/uploads/2016/07/8.png\" alt=\"8\" width=\"465\" height=\"441\" /></a><br />
a.找到删除节点<br />
b.如果删除节点左节点为空 , 右节点也为空;<br />
c.如果删除节点只有一个子节点 右节点 或者 左节点<br />
d.如果删除节点左右子节点都不为空<br />
代码对应见上面完整代码。</p><p style=\"text-align: justify\">案例测试代码如下，BinarySearchTreeTest.java</p><p></p><pre class=\"crayon-plain-tag\">package org.algorithm.tree;
/*
* Copyright [2015] [Jeff Lee]
*
* Licensed under the Apache License, Version 2.0 (the \"License\");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an \"AS IS\" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
/**
* 二叉搜索树(BST)测试案例 {<a href=\"http://www.jobbole.com/members/57845349\">@link</a> BinarySearchTree}
*
* Created by bysocket on 16/7/10.
*/
public class BinarySearchTreeTest {
public static void main(String[] args) {
BinarySearchTree b = new BinarySearchTree();
b.insert(3);b.insert(8);b.insert(1);b.insert(4);b.insert(6);
b.insert(2);b.insert(10);b.insert(9);b.insert(20);b.insert(25);
// 打印二叉树
b.toString(b.root);
System.out.println();
// 是否存在节点值10
TreeNode node01 = b.search(10);
System.out.println(\"是否存在节点值为10 =&gt; \" + node01.value);
// 是否存在节点值11
TreeNode node02 = b.search(11);
System.out.println(\"是否存在节点值为11 =&gt; \" + node02);
// 删除节点8
TreeNode node03 = b.delete(8);
System.out.println(\"删除节点8 =&gt; \" + node03.value);
b.toString(b.root);
}
}</pre><p></p><p style=\"text-align: justify\">运行结果如下：</p><p></p><pre class=\"crayon-plain-tag\">value = 1 -&gt; value = 2 -&gt; value = 3 -&gt; value = 4 -&gt; value = 6 -&gt; value = 8 -&gt; value = 9 -&gt; value = 10 -&gt; value = 20 -&gt; value = 25 -&gt;
是否存在节点值为10 =&gt; 10
是否存在节点值为11 =&gt; null
删除节点8 =&gt; 8
value = 1 -&gt; value = 2 -&gt; value = 3 -&gt; value = 4 -&gt; value = 6 -&gt; value = 9 -&gt; value = 10 -&gt; value = 20 -&gt; value = 25 -&gt;</pre><p></p><h3 style=\"text-align: justify\">四、小结</h3><p style=\"text-align: justify\">与偶尔吃一碗“老坛酸菜牛肉面”一样的味道，品味一个算法，比如BST，的时候，总是那种说不出的味道。</p><p style=\"text-align: justify\">树，二叉树的概念</p><p style=\"text-align: justify\">BST算法</p><p style=\"text-align: justify\">相关代码分享在 <a href=\"https://github.com/JeffLi1993/algorithm-core-learning\" target=\"_blank\">Github</a> 主页</p></div><div class=\"wp_rp_wrap  wp_rp_plain\" ><div class=\"wp_rp_content\"><h3 class=\"related_post_title\">相关文章</h3><ul class=\"related_post wp_rp\" style=\"visibility: visible\"><li ><a href=\"http://blog.jobbole.com/84089/\" class=\"wp_rp_title\">Hadoop学习笔记：MapReduce框架详解</a></li><li ><a href=\"http://blog.jobbole.com/84694/\" class=\"wp_rp_title\">关于寻路算法的一些思考（2）：Heuristics 函数</a></li><li ><a href=\"http://blog.jobbole.com/90310/\" class=\"wp_rp_title\">矩阵相乘优化算法实现讲解</a></li><li ><a href=\"http://blog.jobbole.com/90770/\" class=\"wp_rp_title\">如何向非技术人员解释“稀疏傅里叶变换”算法？</a></li><li ><a href=\"http://blog.jobbole.com/98633/\" class=\"wp_rp_title\">StackOverflow 这么大，它的架构是怎么样的？</a></li><li ><a href=\"http://blog.jobbole.com/93621/\" class=\"wp_rp_title\">美国国防部机密文件销毁算法</a></li><li ><a href=\"http://blog.jobbole.com/79305/\" class=\"wp_rp_title\">浅谈算法和数据结构（7）：二叉查找树</a></li><li ><a href=\"http://blog.jobbole.com/79288/\" class=\"wp_rp_title\">浅谈算法和数据结构（2）：基本排序算法</a></li><li ><a href=\"http://blog.jobbole.com/100786/\" class=\"wp_rp_title\">算法分析的正确姿势</a></li><li ><a href=\"http://blog.jobbole.com/79314/\" class=\"wp_rp_title\">浅谈算法和数据结构（12）：无向图相关算法基础</a></li></ul></div></div><p><a href=\"http://blog.jobbole.com/104106/\">图解：二叉搜索树算法</a>，首发于<a href=\"http://blog.jobbole.com\">文章 - 伯乐在线</a>。</p>" "http://blog.jobbole.com/104106/" (22432 47305) old 6 nil nil ((title nil "图解：二叉搜索树算法") (link nil "http://blog.jobbole.com/104106/") (comments nil "http://blog.jobbole.com/104106/#respond") (pubDate nil "Tue, 02 Aug 2016 15:14:17 +0000") (dc:creator nil "ABOER") (category nil "IT技术") (category nil "二叉搜索树") (category nil "算法") (guid ((isPermaLink . "false")) "http://blog.jobbole.com/?p=104106") (description nil "<p> 二叉树是由节点和边构成，储存元素的集合。节点分根节点、父节点和子节点的概念。</p><p><a href=\"http://blog.jobbole.com/104106/\">图解：二叉搜索树算法</a>，首发于<a href=\"http://blog.jobbole.com\">文章 - 伯乐在线</a>。</p>") (content:encoded nil "<p style=\"text-align: justify\">“岁月极美，在于它必然的流逝”</p><div><p style=\"text-align: left\">“春花 秋月 夏日 冬雪”<br />
— 三毛</p><h3 style=\"text-align: justify\">一、树 &amp; 二叉树</h3><p style=\"text-align: justify\"><strong>树</strong>是由节点和边构成，储存元素的集合。节点分根节点、父节点和子节点的概念。<br />
如图：树深=4; 5是根节点；同样8与3的关系是父子节点关系。</p><p style=\"text-align: justify\"><a href=\"http://www.bysocket.com/wp-content/uploads/2016/07/1.png\"><img src=\"http://www.bysocket.com/wp-content/uploads/2016/07/1.png\" alt=\"1\" width=\"460\" height=\"527\" /></a><br /><strong>二叉树binary tree</strong>，则加了“二叉”（binary），意思是在树中作区分。每个节点至多有两个子（child）,left child &amp; right child。二叉树在很多例子中使用，比如二叉树表示算术表达式。<br />
如图：1/8是左节点；2/3是右节点；</p><p style=\"text-align: justify\"><a href=\"http://www.bysocket.com/wp-content/uploads/2016/07/2.png\"><img src=\"http://www.bysocket.com/wp-content/uploads/2016/07/2.png\" alt=\"2\" width=\"447\" height=\"445\" /></a></p><h3 style=\"text-align: justify\"><strong>二、二叉搜索树 BST</strong></h3><p style=\"text-align: justify\">顾名思义，二叉树上又加了个搜索的限制。其要求：每个节点比其左子树元素大，比其右子树元素小。<br />
如图：每个节点比它左子树的任意节点大，而且比它右子树的任意节点小</p><p style=\"text-align: justify\"><a href=\"http://www.bysocket.com/wp-content/uploads/2016/07/3.png\"><img src=\"http://www.bysocket.com/wp-content/uploads/2016/07/3.png\" alt=\"3\" width=\"457\" height=\"457\" /></a></p><h3 style=\"text-align: justify\">三、BST Java实现</h3><p style=\"text-align: justify\">直接上代码，对应代码分享在 <a href=\"https://github.com/JeffLi1993/algorithm-core-learning\" target=\"_blank\">Github</a> 主页<br />
BinarySearchTree.java</p><p></p><pre class=\"crayon-plain-tag\">package org.algorithm.tree;
/*
 * Copyright [2015] [Jeff Lee]
 *
 * Licensed under the Apache License, Version 2.0 (the \"License\");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an \"AS IS\" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * 二叉搜索树(BST)实现
 *
 * Created by bysocket on 16/7/7.
 */
public class BinarySearchTree {
    /**
     * 根节点
     */
    public static TreeNode root;

    public BinarySearchTree() {
        this.root = null;
    }

    /**
     * 查找
     *      树深(N) O(lgN)
     *      1. 从root节点开始
     *      2. 比当前节点值小,则找其左节点
     *      3. 比当前节点值大,则找其右节点
     *      4. 与当前节点值相等,查找到返回TRUE
     *      5. 查找完毕未找到,
     * @param key
     * @return
     */
    public TreeNode search (int key) {
        TreeNode current = root;
        while (current != null
                &amp;&amp; key != current.value) {
            if (key  key) {
                isLeftChild = true;
                current = current.left;
            } else {
                isLeftChild = false;
                current = current.right;
            }

            if (current == null) {
                return current;
            }
        }

        // 如果删除节点左节点为空 , 右节点也为空
        if (current.left == null &amp;&amp; current.right == null) {
            if (current == root) {
                root = null;
            }
            // 在左子树
            if (isLeftChild == true) {
                parent.left = null;
            } else {
                parent.right = null;
            }
        }
        // 如果删除节点只有一个子节点 右节点 或者 左节点
        else if (current.right == null) {
            if (current == root) {
                root = current.left;
            } else if (isLeftChild) {
                parent.left = current.left;
            } else {
                parent.right = current.left;
            }

        }
        else if (current.left == null) {
            if (current == root) {
                root = current.right;
            } else if (isLeftChild) {
                parent.left = current.right;
            } else {
                parent.right = current.right;
            }
        }
        // 如果删除节点左右子节点都不为空
        else if (current.left != null &amp;&amp; current.right != null) {
            // 找到删除节点的后继者
            TreeNode successor = getDeleteSuccessor(current);
            if (current == root) {
                root = successor;
            } else if (isLeftChild) {
                parent.left = successor;
            } else {
                parent.right = successor;
            }
            successor.left = current.left;
        }
        return current;
    }

    /**
     * 获取删除节点的后继者
     *      删除节点的后继者是在其右节点树种最小的节点
     * @param deleteNode
     * @return
     */
    public TreeNode getDeleteSuccessor(TreeNode deleteNode) {
        // 后继者
        TreeNode successor = null;
        TreeNode successorParent = null;
        TreeNode current = deleteNode.right;

        while (current != null) {
            successorParent = successor;
            successor = current;
            current = current.left;
        }

        // 检查后继者(不可能有左节点树)是否有右节点树
        // 如果它有右节点树,则替换后继者位置,加到后继者父亲节点的左节点.
        if (successor != deleteNode.right) {
            successorParent.left = successor.right;
            successor.right = deleteNode.right;
        }

        return successor;
    }

    public void toString(TreeNode root) {
        if (root != null) {
            toString(root.left);
            System.out.print(\"value = \" + root.value + \" -&gt; \");
            toString(root.right);
        }
    }
}

/**
 * 节点
 */
class TreeNode {

    /**
     * 节点值
     */
    int value;

    /**
     * 左节点
     */
    TreeNode left;

    /**
     * 右节点
     */
    TreeNode right;

    public TreeNode(int value) {
        this.value = value;
        left  = null;
        right = null;
    }
}</pre><p></p><p style=\"text-align: justify\">1. <strong>节点数据结构</strong><br />
首先定义了节点的数据接口，节点分左节点和右节点及本身节点值。如图</p><p style=\"text-align: justify\"><a href=\"http://www.bysocket.com/wp-content/uploads/2016/07/4.png\"><img src=\"http://www.bysocket.com/wp-content/uploads/2016/07/4.png\" alt=\"4\" width=\"584\" height=\"176\" /></a></p><p style=\"text-align: justify\">代码如下：</p><p></p><pre class=\"crayon-plain-tag\">/**
 * 节点
 */
class TreeNode {

    /**
     * 节点值
     */
    int value;

    /**
     * 左节点
     */
    TreeNode left;

    /**
     * 右节点
     */
    TreeNode right;

    public TreeNode(int value) {
        this.value = value;
        left  = null;
        right = null;
    }
}</pre><p></p><p style=\"text-align: justify\"><strong>2. 插入</strong><br />
插入，和删除一样会引起二叉搜索树的动态变化。插入相对删处理逻辑相对简单些。如图插入的逻辑：</p><p style=\"text-align: justify\"><a href=\"http://www.bysocket.com/wp-content/uploads/2016/07/5.png\"><img src=\"http://www.bysocket.com/wp-content/uploads/2016/07/5.png\" alt=\"5\" width=\"498\" height=\"558\" /></a><br />
a. 从root节点开始<br />
b.如果root为空,root为插入值<br />
c.循环:<br />
d.如果当前节点值大于插入值,找左节点<br />
e.如果当前节点值小于插入值,找右节点<br />
代码对应：</p><p></p><pre class=\"crayon-plain-tag\">/**
     * 插入
     *      1. 从root节点开始
     *      2. 如果root为空,root为插入值
     *      循环:
     *      3. 如果当前节点值大于插入值,找左节点
     *      4. 如果当前节点值小于插入值,找右节点
     * @param key
     * @return
     */
    public TreeNode insert (int key) {
        // 新增节点
        TreeNode newNode = new TreeNode(key);
        // 当前节点
        TreeNode current = root;
        // 上个节点
        TreeNode parent  = null;
        // 如果根节点为空
        if (current == null) {
            root = newNode;
            return newNode;
        }
        while (true) {
            parent = current;
            if (key</pre><p></p><p style=\"text-align: justify\"><strong>3.查找</strong></p><p style=\"text-align: justify\">其算法复杂度 : O(lgN),树深(N)。如图查找逻辑：</p><p style=\"text-align: justify\"><a href=\"http://www.bysocket.com/wp-content/uploads/2016/07/6.png\"><img src=\"http://www.bysocket.com/wp-content/uploads/2016/07/6.png\" alt=\"6\" width=\"483\" height=\"581\" /></a><br />
a.从root节点开始<br />
b.比当前节点值小,则找其左节点<br />
c.比当前节点值大,则找其右节点<br />
d.与当前节点值相等,查找到返回TRUE<br />
e.查找完毕未找到<br />
代码对应：</p><p></p><pre class=\"crayon-plain-tag\">/**
     * 查找
     *      树深(N) O(lgN)
     *      1. 从root节点开始
     *      2. 比当前节点值小,则找其左节点
     *      3. 比当前节点值大,则找其右节点
     *      4. 与当前节点值相等,查找到返回TRUE
     *      5. 查找完毕未找到,
     * @param key
     * @return
     */
    public TreeNode search (int key) {
        TreeNode current = root;
        while (current != null
                &amp;&amp; key != current.value) {
            if (key</pre><p></p><p style=\"text-align: justify\">4. 删除<br />
首先找到删除节点，其寻找方法：删除节点的后继者是在其右节点树种最小的节点。如图删除对应逻辑：<a href=\"http://www.bysocket.com/wp-content/uploads/2016/07/7.png\"><img src=\"http://www.bysocket.com/wp-content/uploads/2016/07/7.png\" alt=\"7\" width=\"469\" height=\"473\" /></a></p><p style=\"text-align: justify\">结果为：</p><p style=\"text-align: justify\"><a href=\"http://www.bysocket.com/wp-content/uploads/2016/07/8.png\"><img src=\"http://www.bysocket.com/wp-content/uploads/2016/07/8.png\" alt=\"8\" width=\"465\" height=\"441\" /></a><br />
a.找到删除节点<br />
b.如果删除节点左节点为空 , 右节点也为空;<br />
c.如果删除节点只有一个子节点 右节点 或者 左节点<br />
d.如果删除节点左右子节点都不为空<br />
代码对应见上面完整代码。</p><p style=\"text-align: justify\">案例测试代码如下，BinarySearchTreeTest.java</p><p></p><pre class=\"crayon-plain-tag\">package org.algorithm.tree;
/*
 * Copyright [2015] [Jeff Lee]
 *
 * Licensed under the Apache License, Version 2.0 (the \"License\");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an \"AS IS\" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * 二叉搜索树(BST)测试案例 {<a href=\"http://www.jobbole.com/members/57845349\">@link</a> BinarySearchTree}
 *
 * Created by bysocket on 16/7/10.
 */
public class BinarySearchTreeTest {

    public static void main(String[] args) {
        BinarySearchTree b = new BinarySearchTree();
        b.insert(3);b.insert(8);b.insert(1);b.insert(4);b.insert(6);
        b.insert(2);b.insert(10);b.insert(9);b.insert(20);b.insert(25);

        // 打印二叉树
        b.toString(b.root);
        System.out.println();

        // 是否存在节点值10
        TreeNode node01 = b.search(10);
        System.out.println(\"是否存在节点值为10 =&gt; \" + node01.value);
        // 是否存在节点值11
        TreeNode node02 = b.search(11);
        System.out.println(\"是否存在节点值为11 =&gt; \" + node02);

        // 删除节点8
        TreeNode node03 = b.delete(8);
        System.out.println(\"删除节点8 =&gt; \" + node03.value);
        b.toString(b.root);


    }
}</pre><p></p><p style=\"text-align: justify\">运行结果如下：</p><p></p><pre class=\"crayon-plain-tag\">value = 1 -&gt; value = 2 -&gt; value = 3 -&gt; value = 4 -&gt; value = 6 -&gt; value = 8 -&gt; value = 9 -&gt; value = 10 -&gt; value = 20 -&gt; value = 25 -&gt; 
是否存在节点值为10 =&gt; 10
是否存在节点值为11 =&gt; null
删除节点8 =&gt; 8
value = 1 -&gt; value = 2 -&gt; value = 3 -&gt; value = 4 -&gt; value = 6 -&gt; value = 9 -&gt; value = 10 -&gt; value = 20 -&gt; value = 25 -&gt;</pre><p></p><h3 style=\"text-align: justify\">四、小结</h3><p style=\"text-align: justify\">与偶尔吃一碗“老坛酸菜牛肉面”一样的味道，品味一个算法，比如BST，的时候，总是那种说不出的味道。</p><p style=\"text-align: justify\">树，二叉树的概念</p><p style=\"text-align: justify\">BST算法</p><p style=\"text-align: justify\">相关代码分享在 <a href=\"https://github.com/JeffLi1993/algorithm-core-learning\" target=\"_blank\">Github</a> 主页</p></div><div class=\"wp_rp_wrap  wp_rp_plain\" ><div class=\"wp_rp_content\"><h3 class=\"related_post_title\">相关文章</h3><ul class=\"related_post wp_rp\" style=\"visibility: visible\"><li ><a href=\"http://blog.jobbole.com/84089/\" class=\"wp_rp_title\">Hadoop学习笔记：MapReduce框架详解</a></li><li ><a href=\"http://blog.jobbole.com/84694/\" class=\"wp_rp_title\">关于寻路算法的一些思考（2）：Heuristics 函数</a></li><li ><a href=\"http://blog.jobbole.com/90310/\" class=\"wp_rp_title\">矩阵相乘优化算法实现讲解</a></li><li ><a href=\"http://blog.jobbole.com/90770/\" class=\"wp_rp_title\">如何向非技术人员解释“稀疏傅里叶变换”算法？</a></li><li ><a href=\"http://blog.jobbole.com/98633/\" class=\"wp_rp_title\">StackOverflow 这么大，它的架构是怎么样的？</a></li><li ><a href=\"http://blog.jobbole.com/93621/\" class=\"wp_rp_title\">美国国防部机密文件销毁算法</a></li><li ><a href=\"http://blog.jobbole.com/79305/\" class=\"wp_rp_title\">浅谈算法和数据结构（7）：二叉查找树</a></li><li ><a href=\"http://blog.jobbole.com/79288/\" class=\"wp_rp_title\">浅谈算法和数据结构（2）：基本排序算法</a></li><li ><a href=\"http://blog.jobbole.com/100786/\" class=\"wp_rp_title\">算法分析的正确姿势</a></li><li ><a href=\"http://blog.jobbole.com/79314/\" class=\"wp_rp_title\">浅谈算法和数据结构（12）：无向图相关算法基础</a></li></ul></div></div><p><a href=\"http://blog.jobbole.com/104106/\">图解：二叉搜索树算法</a>，首发于<a href=\"http://blog.jobbole.com\">文章 - 伯乐在线</a>。</p>") (wfw:commentRss nil "http://blog.jobbole.com/104106/feed/") (slash:comments nil "0"))) ("构建高可用ZooKeeper集群" "<p>ZooKeeper 是 Apache 的一个顶级项目，为分布式应用提供高效、高可用的分布式协调服务，提供了诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知和分布式锁等分布式基 础服务。由于 ZooKeeper 便捷的使用方式、卓越的性能和良好的稳定性，被广泛地应用于诸如 Hadoop、HBase、Kafka 和 Dubbo 等大型分布式系统中。</p><p>本文的目标读者是对 ZooKeeper 有一定了解的技术人员，将从 ZooKeeper 运行模式、集群组成、容灾和水平扩容四方面逐步深入，最终构建出高可用的 ZooKeeper 集群。</p><p><a href=\"http://jbcdn2.b0.upaiyun.com/2016/08/1278ec7406ec24ad48e2e37779fdaab3.png\"><img class=\"alignnone size-full wp-image-104096\" src=\"http://jbcdn2.b0.upaiyun.com/2016/08/1278ec7406ec24ad48e2e37779fdaab3.png\" alt=\"897247-20160630014524577-1260202033\" /></a></p><p><strong>运行模式</strong></p><p>Zookeeper 有三种运行模式：单机模式、伪集群模式和集群模式。</p><p><strong>单机模式</strong></p><p>这种模式一般适用于开发测试环境，一方面我们没有那么多机器资源，另外就是平时的开发调试并不需要极好的稳定性。</p><p>在 Linux 环境下运行单机模式需要执行以下步骤：</p><p><strong>1. 准备 Java 运行环境</strong></p><p>安装 Java 1.6 或更高版本的 JDK，并配置好 Java 相关的环境变量 $JAVA_HOME 。</p><p><strong>2. 下载 ZooKeeper 安装包</strong></p><p>下载地址：<a href=\"http://zookeeper.apache.org/releases.html\" target=\"_blank\">http://zookeeper.apache.org/releases.html</a>。选择最新的 stable 版本并解压到指定目录，我们用 $ZK_HOME 表示该目录。</p><p><strong>3. 配置 zoo.cfg</strong></p><p>首次使用 ZooKeeper，需要将 $ZK_HOME 下的 zoo_sample.cfg 文件重命名为 zoo.cfg，并进行以下配置</p><div class=\"cnblogs_code\"><div class=\"cnblogs_code_toolbar\"></div><p></p><pre class=\"crayon-plain-tag\">tickTime=2000    ##Zookeeper最小时间单元，单位毫秒(ms)，默认值为3000
dataDir=/var/lib/zookeeper    ##Zookeeper服务器存储快照文件的目录，必须配置
dataLogDir=/var/lib/log     ##Zookeeper服务器存储事务日志的目录，默认为dataDir
clientPort=2181    ##服务器对外服务端口，一般设置为2181
initLimit=5    ##Leader服务器等待Follower启动并完成数据同步的时间，默认值10，表示tickTime的10倍
syncLimit=2    ##Leader服务器和Follower之间进行心跳检测的最大延时时间，默认值5，表示tickTime的5倍</pre><p></p><div class=\"cnblogs_code_toolbar\"></div></div><p><strong>4. 启动服务</strong></p><p>使用 $ZK_HOME/bin 目录下的 zkServer.sh 脚本进行服务的启动。</p><p><strong>集群模式</strong></p><p>一个 ZooKeeper 集群通常由一组机器组成，一般 3 台以上就可以组成一个可用的 ZooKeeper 集群了。</p><p>组成 ZooKeeper 集群的每台机器都会在内存中维护当前的服务器状态，并且每台机器之间都会互相保持通信。<em>重要的一点是，只要集群中存在超过一半的机器能够正常工作，那么整个集群就能够正常对外服务。</em></p><p>ZooKeeper 的客户端程序会选择和集群中的任意一台服务器创建一个 TCP 连接，而且一旦客户端和服务器断开连接，客户端就会自动连接到集群中的其他服务器。</p><p><a href=\"http://jbcdn2.b0.upaiyun.com/2016/08/665f644e43731ff9db3d341da5c827e1.png\"><img class=\"alignnone size-full wp-image-104097\" src=\"http://jbcdn2.b0.upaiyun.com/2016/08/665f644e43731ff9db3d341da5c827e1.png\" alt=\"2\" /></a></p><p>那么如何运行 ZooKeeper 集群模式呢？首先假如我们有三台服务器，IP 分别为 IP<sub>1</sub>、IP<sub>2</sub> 和 IP<sub>3</sub>，则需要执行以下步骤：</p><p><strong>1. 准备 Java 运行环境（同上）</strong></p><p><strong>2. 下载 ZooKeeper 安装包（同上）</strong></p><p><strong>3. 配置 zoo.cfg</strong></p><div class=\"cnblogs_code\"><pre class=\"crayon-plain-tag\">tickTime=2000
dataDir=/var/lib/zookeeper
dataLogDir=/var/lib/log
clientPort=2181
initLimit=5
syncLimit=2
server.1=IP&lt;sub&gt;1&lt;/sub&gt;:2888:3888
server.2=IP&lt;sub&gt;2&lt;/sub&gt;:2888:3888
server.3=IP&lt;sub&gt;3&lt;/sub&gt;:2888:3888</pre></div><p>可以看到，相比于单机模式，集群模式多了 server.id=host:port<sub>1</sub>:port<sub>2</sub> 的配置。其中，id 被称为 Server ID，用来标识该机器在集群中的机器序号（在每台机器的 dataDir 目录下创建 myid 文件，文件内容即为该机器对应的 Server ID 数字）。host 为机器 IP，port<sub>1</sub> 用于指定 Follower 服务器与 Leader 服务器进行通信和数据同步的端口，port<sub>2</sub> 用于进行 Leader 选举过程中的投票通信。</p><p><strong>4. 创建 myid 文件</strong></p><p>在 dataDir 目录下创建名为 myid 的文件，在文件第一行写上对应的 Server ID。</p><p><strong>5. 按照相同步骤，为其他机器配置 zoo.cfg 和 myid文件</strong></p><p><strong>6. 启动服务</strong></p><p><strong>伪集群模式</strong></p><p>这是一种特殊的集群模式，即集群的所有服务器都部署在一台机器上。当你手头上有一台比较好的机器，如果作为单机模式进行部署，就会浪费资源，这 种情况下，ZooKeeper允许你在一台机器上通过启动不同的端口来启动多个 ZooKeeper 服务实例，以此来以集群的特性来对外服务。</p><p>这种模式下，只需要把 zoo.cfg 做如下修改：</p><div class=\"cnblogs_code\"><pre class=\"crayon-plain-tag\">tickTime=2000
dataDir=/var/lib/zookeeper
dataLogDir=/var/lib/log
clientPort=2181
initLimit=5
syncLimit=2
server.1=IP&lt;sub&gt;1&lt;/sub&gt;:2888:3888
server.2=IP&lt;sub&gt;1&lt;/sub&gt;:2889:3889
server.3=IP&lt;sub&gt;1&lt;/sub&gt;:2890:3890</pre></div><p><strong>集群组成</strong></p><p>要搭建一个高可用的 ZooKeeper 集群，我们首先需要确定好集群的规模。关于 ZooKeeper 集群的服务器组成，相信很多对 ZooKeeper 了解但是理解不够深入的读者，都存在或曾经存在过这样一个错误的认识：<em><strong>为了使得 ZooKeeper 集群能够顺利地选举出 Leader，必须将 ZooKeeper 集群的服务器数部署成奇数</strong>。</em>这里我们需要澄清的一点是：<strong>任意台 ZooKeeper 服务器都能部署且能正常运行。</strong></p><p>那么存在于这么多读者中的这个错误认识是怎么回事呢？其实关于 ZooKeeper 集群服务器数，ZooKeeper 官方确实给出了关于奇数的建议，但绝大部分 ZooKeeper 用户对于这个建议认识有偏差。在本书前面提到的“<strong>过半存活即可用</strong>” 特性中，我们已经了解了，一个 ZooKeeper 集群如果要对外提供可用的服务，那么集群中必须要有过半的机器正常工作并且彼此之间能够正常通信。基于这个特性，如果想搭建一个能够允许 N 台机器 down 掉的集群，那么就要部署一个由 2*N+1 台服务器构成的 ZooKeeper 集群。因此，一个由 3 台机器构成的 ZooKeeper 集群，能够在挂掉 1 台机器后依然正常工作，而对于一个由 5 台服务器构成的 ZooKeeper 集群，能够对 2 台机器挂掉的情况进行容灾。注意，如果是一个由6台服务器构成的 ZooKeeper 集群，同样只能够挂掉 2 台机器，因为如果挂掉 3 台，剩下的机器就无法实现过半了。</p><p>因此，从上面的讲解中，我们其实可以看出，对于一个由 6 台机器构成的 ZooKeeper 集群来说，和一个由 5 台机器构成的 ZooKeeper 集群，其在容灾能力上并没有任何显著的优势，反而多占用了一个服务器资源。基于这个原因，ZooKeeper 集群通常设计部署成奇数台服务器即可。</p><p><strong>容灾</strong></p><p>所谓容灾，在 IT 行业通常是指我们的计算机信息系统具有的一种在遭受诸如火灾、地震、断电和其他基础网络设备故障等毁灭性灾难的时候，依然能够对外提供可用服务的能力。</p><p>对于一些普通的应用，为了达到容灾标准，通常我们会选择在多台机器上进行部署来组成一个集群，这样即使在集群的一台或是若干台机器出现故障的情况下，整个集群依然能够对外提供可用的服务。</p><p>而对于一些核心应用，不仅要通过使用多台机器构建集群的方式来提供服务，而且还要将集群中的机器部署在两个机房，这样的话，即使其中一个机房遭遇灾难，依然能够对外提供可用的服务。</p><p>上面讲到的都是应用层面的容灾模式，那么对于 ZooKeeper 这种底层组件来说，如何进行容灾呢？讲到这里，可能多少读者会有疑问，ZooKeeper 既然已经解决了单点问题，那为什么还要进行容灾呢？</p><p><strong>单点问题</strong></p><p>单点问题是分布式环境中最常见也是最经典的问题之一，在很多分布式系统中都会存在这样的单点问题。具体地说，单点问题是指在一个分布式系统中，如果某一个组件出现故障就会引起整个系统的可用性大大下降甚至是处于瘫痪状态，那么我们就认为该组件存在单点问题。</p><p>ZooKeeper 确实已经很好地解决了单点问题。我们已经了解到，基于“过半”设计原则，ZooKeeper 在运行期间，集群中至少有过半的机器保存了最新的数据。因此，只要集群中超过半数的机器还能够正常工作，整个集群就能够对外提供服务。</p><p><strong>容灾</strong></p><p>解决了单点问题，是不是该考虑容灾了呢？答案是否定的，在搭建一个高可用的集群的时候依然需要考虑容灾问题。正如上面讲到的，如果集群中超过半数的机器还在正常工作，集群就能够对外提供正常的服务。那么，如果整个机房出现灾难性的事故，这时显然已经不是单点问题的范畴了。</p><p>在进行 ZooKeeper 的容灾方案设计过程中，我们要充分考虑到“过半原则”。也就是说，无论发生什么情况，我们必须保证 ZooKeeper 集群中有超过半数的机器能够正常工作。因此，通常有以下两种部署方案。</p><p><strong>双机房部署</strong></p><p>在进行容灾方案的设计时，我们通常是以机房为单位来考虑问题。在现实中，很多公司的机房规模并不大，因此双机房部署是个比较常见的方案。但是遗憾的是，在目前版本的 ZooKeeper 中，还没有办法能够在双机房条件下实现比较好的容灾效果——因为无论哪个机房发生异常情况，都有可能使得 ZooKeeper 集群中可用的机器无法超过半数。当 然，在拥有两个机房的场景下，通常有一个机房是主要机房（一般而言，公司会花费更多的钱去租用一个稳定性更好、设备更可靠的机房，这个机房就是主要机房， 而另外一个机房则更加廉价一些）。我们唯一能做的，就是尽量在主要机房部署更多的机器。例如，对于一个由 7 台机器组成的 ZooKeeper 集群，通常在主要机房中部署 4 台机器，剩下的 3 台机器部署到另外一个机房中。</p><p><strong>三机房部署</strong></p><p>既然在双机房部署模式下并不能实现好的容灾效果，那么对于有条件的公司，选择三机房部署无疑是个更好的选择，无论哪个机房发生了故障，剩下两个机房的机器数量都超过半数。假如我们有三个机房可以部署服务，并且这三个机房间的网络状况良好，那么就可以在三个机房中都部署若干个机器来组成一个 ZooKeeper 集群。</p><p>我们假定构成 ZooKeeper 集群的机器总数为 N，在三个机房中部署的 ZooKeeper 服务器数分别为 N<sub>1</sub>、N<sub>2</sub> 和 N<sub>3</sub>，如果要使该 ZooKeeper 集群具有较好的容灾能力，我们可以根据如下算法来计算 ZooKeeper 集群的机器部署方案。</p><p><strong>1. 计算 N<sub>1</sub></strong></p><p>如果 ZooKeeper 集群的服务器总数是 N，那么：</p><div class=\"cnblogs_code\"><pre class=\"crayon-plain-tag\">N1 = (N-1)/2</pre></div><p>在 Java 中，“/” 运算符会自动对计算结果向下取整操作。举个例子，如果 N=8，那么 N<sub>1</sub>=3；如果 N=7，那么 N<sub>1</sub> 也等于 3。</p><p><strong>2. 计算 N<sub>2</sub> 的可选值</strong></p><p>N<sub>2</sub> 的计算规则和 N<sub>1</sub> 非常类似，只是 N<sub>2 </sub>的取值是在一个取值范围内：</p><div class=\"cnblogs_code\"><pre class=\"crayon-plain-tag\">N2 的取值范围是 1~(N-N1)/2</pre></div><p>即如果 N=8，那么 N<sub>1</sub>=3，则 N<sub>2</sub> 的取值范围就是 1~2，分别是 1 和 2。注意，1 和 2 仅仅是 N<sub>2</sub> 的可选值，并非最终值——如果 N<sub>2</sub> 为某个可选值的时候，无法计算出 N<sub>3</sub> 的值，那么该可选值也无效。</p><p><strong>3. 计算 N<sub>3</sub>，同时确定 N<sub>2</sub> 的值</strong></p><p>很显然，现在只剩下 N<sub>3</sub> 了，可以简单的认为 N<sub>3</sub> 的取值就是剩下的机器数，即：</p><div class=\"cnblogs_code\"><pre class=\"crayon-plain-tag\">N3 = N - N1 - N2</pre></div><p>只是 N<sub>3</sub> 的取值必须满足 N<sub>3</sub> &lt; N<sub>1</sub>+N2。在满足这个条件的基础下，我们遍历步骤 2 中计算得到的 N<sub>2</sub> 的可选值，即可得到三机房部署时每个机房的服务器数量了。</p><p>现在我们以 7 台机器为例，来看看如何分配三机房的机器分布。根据算法的步骤 1，我们首先确定 N<sub>1</sub> 的取值为 3。根据算法的步骤 2，我们确定了 N<sub>2</sub> 的可选值为 1 和 2。最后根据步骤 3，我们遍历 N<sub>2</sub> 的可选值，即可得到两种部署方案，分别是 (3,1,3) 和 (3,2,2)。以下是 Java 程序代码对以上算法的一种简单实现：</p><div class=\"cnblogs_code\"><pre class=\"crayon-plain-tag\">public class Allocation {
static final int n = 7;
public static void main(String[] args){
int n1,n2,n3;
n1 = (n-1) / 2;
int n2_max = (n-n1) / 2;
for(int i=1; i&lt;=n2_max; i++){
n2 = i;
n3 = n - n1 -n2;
if(n3&gt;= (n1+n2)){
continue;
}
System.out.println(\"(\"+n1+\",\"+n2+\",\"+n3+\")\");
}
}
}</pre></div><p><strong>水平扩容</strong></p><p>水平可扩容可以说是对一个分布式系统在高可用性方面提出的基本的，也是非常重要的一个要求，通过水平扩容能够帮助系统在不进行或进行极少改进工作的前提下，快速提高系统对外的服务支撑能力。简单地讲，水平扩容就是向集群中添加更多的机器，以提高系统的服务质量。</p><p>很遗憾的是，ZooKeeper 在水平扩容扩容方面做得并不十分完美，需要进行整个集群的重启。通常有两种重启方式，一种是集群整体重启，另外一种是逐台进行服务器的重启。</p><p><strong>整体重启</strong></p><p>所谓集群整体重启，就是先将整个集群停止，然后更新 ZooKeeper 的配置，然后再次启动。如果在你的系统中，ZooKeeper 并不是个非常核心的组件，并且能够允许短暂的服务停止（通常是几秒钟的时间间隔），那么不妨选择这种方式。在整体重启的过程中，所有该集群的客户端都无法 连接上集群。等到集群再次启动，这些客户端就能够自动连接上——注意，整体启动前建立起的客户端会话，并不会因为此次整体重启而失效。也就是说，在整体重启期间花费的时间将不计入会话超时时间的计算中。</p><p><strong>逐台重启</strong></p><p>这种方式更适合绝大多数的实际场景。在这种方式中，每次仅仅重启集群中的一台机器，然后逐台对整个集群中的机器进行重启操作。这种方式可以在重启期间依然保证集群对外的正常服务。</p><p>&nbsp;</p><div class=\"wp_rp_wrap  wp_rp_plain\" ><div class=\"wp_rp_content\"><h3 class=\"related_post_title\">相关文章</h3><ul class=\"related_post wp_rp\" style=\"visibility: visible\"><li ><a href=\"http://blog.jobbole.com/98633/\" class=\"wp_rp_title\">StackOverflow 这么大，它的架构是怎么样的？</a></li><li ><a href=\"http://blog.jobbole.com/91738/\" class=\"wp_rp_title\">亿级Web系统搭建：单机到分布式集群</a></li><li ><a href=\"http://blog.jobbole.com/45721/\" class=\"wp_rp_title\">Zookeeper与paxos算法</a></li><li ><a href=\"http://blog.jobbole.com/99195/\" class=\"wp_rp_title\">Kafka集群操作指南</a></li><li ><a href=\"http://blog.jobbole.com/103116/\" class=\"wp_rp_title\">游戏服务端究竟解决了什么问题？</a></li><li ><a href=\"http://blog.jobbole.com/97806/\" class=\"wp_rp_title\">数据库集群技术漫谈</a></li><li ><a href=\"http://blog.jobbole.com/34212/\" class=\"wp_rp_title\">可伸缩系统的架构经验</a></li><li ><a href=\"http://blog.jobbole.com/99246/\" class=\"wp_rp_title\">Codis集群搭建摘要</a></li><li ><a href=\"http://blog.jobbole.com/98873/\" class=\"wp_rp_title\">Docker + Swarm + etcd 集群搭建</a></li><li ><a href=\"http://blog.jobbole.com/98446/\" class=\"wp_rp_title\">CentOS 7下搭建高可用集群</a></li></ul></div></div><p><a href=\"http://blog.jobbole.com/104092/\">构建高可用ZooKeeper集群</a>，首发于<a href=\"http://blog.jobbole.com\">文章 - 伯乐在线</a>。</p>" "http://blog.jobbole.com/104092/" (22432 45384) old 7 nil nil ((title nil "构建高可用ZooKeeper集群") (link nil "http://blog.jobbole.com/104092/") (comments nil "http://blog.jobbole.com/104092/#respond") (pubDate nil "Tue, 02 Aug 2016 14:42:16 +0000") (dc:creator nil "黄山松") (category nil "IT技术") (category nil "Zookeeper") (category nil "架构") (category nil "集群") (guid ((isPermaLink . "false")) "http://blog.jobbole.com/?p=104092") (description nil "<p>ZooKeeper 是 Apache 的一个顶级项目，为分布式应用提供高效、高可用的分布式协调服务，提供了诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知和分布式锁等分布式基 础服务。由于 ZooKeeper 便捷的使用方式、卓越的性能和良好的稳定性，被广泛地应用于诸如 Hadoop、HBase、Kafka 和 Dubbo 等大型分布式系统中。</p><p><a href=\"http://blog.jobbole.com/104092/\">构建高可用ZooKeeper集群</a>，首发于<a href=\"http://blog.jobbole.com\">文章 - 伯乐在线</a>。</p>") (content:encoded nil "<p>ZooKeeper 是 Apache 的一个顶级项目，为分布式应用提供高效、高可用的分布式协调服务，提供了诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知和分布式锁等分布式基 础服务。由于 ZooKeeper 便捷的使用方式、卓越的性能和良好的稳定性，被广泛地应用于诸如 Hadoop、HBase、Kafka 和 Dubbo 等大型分布式系统中。</p><p>本文的目标读者是对 ZooKeeper 有一定了解的技术人员，将从 ZooKeeper 运行模式、集群组成、容灾和水平扩容四方面逐步深入，最终构建出高可用的 ZooKeeper 集群。</p><p><a href=\"http://jbcdn2.b0.upaiyun.com/2016/08/1278ec7406ec24ad48e2e37779fdaab3.png\"><img class=\"alignnone size-full wp-image-104096\" src=\"http://jbcdn2.b0.upaiyun.com/2016/08/1278ec7406ec24ad48e2e37779fdaab3.png\" alt=\"897247-20160630014524577-1260202033\" /></a></p><p><strong>运行模式</strong></p><p>Zookeeper 有三种运行模式：单机模式、伪集群模式和集群模式。</p><p><strong>单机模式</strong></p><p>这种模式一般适用于开发测试环境，一方面我们没有那么多机器资源，另外就是平时的开发调试并不需要极好的稳定性。</p><p>在 Linux 环境下运行单机模式需要执行以下步骤：</p><p><strong>1. 准备 Java 运行环境</strong></p><p>安装 Java 1.6 或更高版本的 JDK，并配置好 Java 相关的环境变量 $JAVA_HOME 。</p><p><strong>2. 下载 ZooKeeper 安装包</strong></p><p>下载地址：<a href=\"http://zookeeper.apache.org/releases.html\" target=\"_blank\">http://zookeeper.apache.org/releases.html</a>。选择最新的 stable 版本并解压到指定目录，我们用 $ZK_HOME 表示该目录。</p><p><strong>3. 配置 zoo.cfg</strong></p><p>首次使用 ZooKeeper，需要将 $ZK_HOME 下的 zoo_sample.cfg 文件重命名为 zoo.cfg，并进行以下配置</p><div class=\"cnblogs_code\"><div class=\"cnblogs_code_toolbar\"></div><p></p><pre class=\"crayon-plain-tag\">tickTime=2000    ##Zookeeper最小时间单元，单位毫秒(ms)，默认值为3000
dataDir=/var/lib/zookeeper    ##Zookeeper服务器存储快照文件的目录，必须配置
dataLogDir=/var/lib/log     ##Zookeeper服务器存储事务日志的目录，默认为dataDir
clientPort=2181    ##服务器对外服务端口，一般设置为2181
initLimit=5    ##Leader服务器等待Follower启动并完成数据同步的时间，默认值10，表示tickTime的10倍
syncLimit=2    ##Leader服务器和Follower之间进行心跳检测的最大延时时间，默认值5，表示tickTime的5倍</pre><p></p><div class=\"cnblogs_code_toolbar\"></div></div><p><strong>4. 启动服务</strong></p><p>使用 $ZK_HOME/bin 目录下的 zkServer.sh 脚本进行服务的启动。</p><p><strong>集群模式</strong></p><p>一个 ZooKeeper 集群通常由一组机器组成，一般 3 台以上就可以组成一个可用的 ZooKeeper 集群了。</p><p>组成 ZooKeeper 集群的每台机器都会在内存中维护当前的服务器状态，并且每台机器之间都会互相保持通信。<em>重要的一点是，只要集群中存在超过一半的机器能够正常工作，那么整个集群就能够正常对外服务。</em></p><p>ZooKeeper 的客户端程序会选择和集群中的任意一台服务器创建一个 TCP 连接，而且一旦客户端和服务器断开连接，客户端就会自动连接到集群中的其他服务器。</p><p><a href=\"http://jbcdn2.b0.upaiyun.com/2016/08/665f644e43731ff9db3d341da5c827e1.png\"><img class=\"alignnone size-full wp-image-104097\" src=\"http://jbcdn2.b0.upaiyun.com/2016/08/665f644e43731ff9db3d341da5c827e1.png\" alt=\"2\" /></a></p><p>那么如何运行 ZooKeeper 集群模式呢？首先假如我们有三台服务器，IP 分别为 IP<sub>1</sub>、IP<sub>2</sub> 和 IP<sub>3</sub>，则需要执行以下步骤：</p><p><strong>1. 准备 Java 运行环境（同上）</strong></p><p><strong>2. 下载 ZooKeeper 安装包（同上）</strong></p><p><strong>3. 配置 zoo.cfg</strong></p><div class=\"cnblogs_code\"><pre class=\"crayon-plain-tag\">tickTime=2000
dataDir=/var/lib/zookeeper
dataLogDir=/var/lib/log
clientPort=2181
initLimit=5
syncLimit=2
server.1=IP&lt;sub&gt;1&lt;/sub&gt;:2888:3888
server.2=IP&lt;sub&gt;2&lt;/sub&gt;:2888:3888
server.3=IP&lt;sub&gt;3&lt;/sub&gt;:2888:3888</pre></div><p>可以看到，相比于单机模式，集群模式多了 server.id=host:port<sub>1</sub>:port<sub>2</sub> 的配置。其中，id 被称为 Server ID，用来标识该机器在集群中的机器序号（在每台机器的 dataDir 目录下创建 myid 文件，文件内容即为该机器对应的 Server ID 数字）。host 为机器 IP，port<sub>1</sub> 用于指定 Follower 服务器与 Leader 服务器进行通信和数据同步的端口，port<sub>2</sub> 用于进行 Leader 选举过程中的投票通信。</p><p><strong>4. 创建 myid 文件</strong></p><p>在 dataDir 目录下创建名为 myid 的文件，在文件第一行写上对应的 Server ID。</p><p><strong>5. 按照相同步骤，为其他机器配置 zoo.cfg 和 myid文件</strong></p><p><strong>6. 启动服务</strong></p><p><strong>伪集群模式</strong></p><p>这是一种特殊的集群模式，即集群的所有服务器都部署在一台机器上。当你手头上有一台比较好的机器，如果作为单机模式进行部署，就会浪费资源，这 种情况下，ZooKeeper允许你在一台机器上通过启动不同的端口来启动多个 ZooKeeper 服务实例，以此来以集群的特性来对外服务。</p><p>这种模式下，只需要把 zoo.cfg 做如下修改：</p><div class=\"cnblogs_code\"><pre class=\"crayon-plain-tag\">tickTime=2000
dataDir=/var/lib/zookeeper
dataLogDir=/var/lib/log
clientPort=2181
initLimit=5
syncLimit=2
server.1=IP&lt;sub&gt;1&lt;/sub&gt;:2888:3888
server.2=IP&lt;sub&gt;1&lt;/sub&gt;:2889:3889
server.3=IP&lt;sub&gt;1&lt;/sub&gt;:2890:3890</pre></div><p><strong>集群组成</strong></p><p>要搭建一个高可用的 ZooKeeper 集群，我们首先需要确定好集群的规模。关于 ZooKeeper 集群的服务器组成，相信很多对 ZooKeeper 了解但是理解不够深入的读者，都存在或曾经存在过这样一个错误的认识：<em><strong>为了使得 ZooKeeper 集群能够顺利地选举出 Leader，必须将 ZooKeeper 集群的服务器数部署成奇数</strong>。</em>这里我们需要澄清的一点是：<strong>任意台 ZooKeeper 服务器都能部署且能正常运行。</strong></p><p>那么存在于这么多读者中的这个错误认识是怎么回事呢？其实关于 ZooKeeper 集群服务器数，ZooKeeper 官方确实给出了关于奇数的建议，但绝大部分 ZooKeeper 用户对于这个建议认识有偏差。在本书前面提到的“<strong>过半存活即可用</strong>” 特性中，我们已经了解了，一个 ZooKeeper 集群如果要对外提供可用的服务，那么集群中必须要有过半的机器正常工作并且彼此之间能够正常通信。基于这个特性，如果想搭建一个能够允许 N 台机器 down 掉的集群，那么就要部署一个由 2*N+1 台服务器构成的 ZooKeeper 集群。因此，一个由 3 台机器构成的 ZooKeeper 集群，能够在挂掉 1 台机器后依然正常工作，而对于一个由 5 台服务器构成的 ZooKeeper 集群，能够对 2 台机器挂掉的情况进行容灾。注意，如果是一个由6台服务器构成的 ZooKeeper 集群，同样只能够挂掉 2 台机器，因为如果挂掉 3 台，剩下的机器就无法实现过半了。</p><p>因此，从上面的讲解中，我们其实可以看出，对于一个由 6 台机器构成的 ZooKeeper 集群来说，和一个由 5 台机器构成的 ZooKeeper 集群，其在容灾能力上并没有任何显著的优势，反而多占用了一个服务器资源。基于这个原因，ZooKeeper 集群通常设计部署成奇数台服务器即可。</p><p><strong>容灾</strong></p><p>所谓容灾，在 IT 行业通常是指我们的计算机信息系统具有的一种在遭受诸如火灾、地震、断电和其他基础网络设备故障等毁灭性灾难的时候，依然能够对外提供可用服务的能力。</p><p>对于一些普通的应用，为了达到容灾标准，通常我们会选择在多台机器上进行部署来组成一个集群，这样即使在集群的一台或是若干台机器出现故障的情况下，整个集群依然能够对外提供可用的服务。</p><p>而对于一些核心应用，不仅要通过使用多台机器构建集群的方式来提供服务，而且还要将集群中的机器部署在两个机房，这样的话，即使其中一个机房遭遇灾难，依然能够对外提供可用的服务。</p><p>上面讲到的都是应用层面的容灾模式，那么对于 ZooKeeper 这种底层组件来说，如何进行容灾呢？讲到这里，可能多少读者会有疑问，ZooKeeper 既然已经解决了单点问题，那为什么还要进行容灾呢？</p><p><strong>单点问题</strong></p><p>单点问题是分布式环境中最常见也是最经典的问题之一，在很多分布式系统中都会存在这样的单点问题。具体地说，单点问题是指在一个分布式系统中，如果某一个组件出现故障就会引起整个系统的可用性大大下降甚至是处于瘫痪状态，那么我们就认为该组件存在单点问题。</p><p>ZooKeeper 确实已经很好地解决了单点问题。我们已经了解到，基于“过半”设计原则，ZooKeeper 在运行期间，集群中至少有过半的机器保存了最新的数据。因此，只要集群中超过半数的机器还能够正常工作，整个集群就能够对外提供服务。</p><p><strong>容灾</strong></p><p>解决了单点问题，是不是该考虑容灾了呢？答案是否定的，在搭建一个高可用的集群的时候依然需要考虑容灾问题。正如上面讲到的，如果集群中超过半数的机器还在正常工作，集群就能够对外提供正常的服务。那么，如果整个机房出现灾难性的事故，这时显然已经不是单点问题的范畴了。</p><p>在进行 ZooKeeper 的容灾方案设计过程中，我们要充分考虑到“过半原则”。也就是说，无论发生什么情况，我们必须保证 ZooKeeper 集群中有超过半数的机器能够正常工作。因此，通常有以下两种部署方案。</p><p><strong>双机房部署</strong></p><p>在进行容灾方案的设计时，我们通常是以机房为单位来考虑问题。在现实中，很多公司的机房规模并不大，因此双机房部署是个比较常见的方案。但是遗憾的是，在目前版本的 ZooKeeper 中，还没有办法能够在双机房条件下实现比较好的容灾效果——因为无论哪个机房发生异常情况，都有可能使得 ZooKeeper 集群中可用的机器无法超过半数。当 然，在拥有两个机房的场景下，通常有一个机房是主要机房（一般而言，公司会花费更多的钱去租用一个稳定性更好、设备更可靠的机房，这个机房就是主要机房， 而另外一个机房则更加廉价一些）。我们唯一能做的，就是尽量在主要机房部署更多的机器。例如，对于一个由 7 台机器组成的 ZooKeeper 集群，通常在主要机房中部署 4 台机器，剩下的 3 台机器部署到另外一个机房中。</p><p><strong>三机房部署</strong></p><p>既然在双机房部署模式下并不能实现好的容灾效果，那么对于有条件的公司，选择三机房部署无疑是个更好的选择，无论哪个机房发生了故障，剩下两个机房的机器数量都超过半数。假如我们有三个机房可以部署服务，并且这三个机房间的网络状况良好，那么就可以在三个机房中都部署若干个机器来组成一个 ZooKeeper 集群。</p><p>我们假定构成 ZooKeeper 集群的机器总数为 N，在三个机房中部署的 ZooKeeper 服务器数分别为 N<sub>1</sub>、N<sub>2</sub> 和 N<sub>3</sub>，如果要使该 ZooKeeper 集群具有较好的容灾能力，我们可以根据如下算法来计算 ZooKeeper 集群的机器部署方案。</p><p><strong>1. 计算 N<sub>1</sub></strong></p><p>如果 ZooKeeper 集群的服务器总数是 N，那么：</p><div class=\"cnblogs_code\"><pre class=\"crayon-plain-tag\">N1 = (N-1)/2</pre></div><p>在 Java 中，“/” 运算符会自动对计算结果向下取整操作。举个例子，如果 N=8，那么 N<sub>1</sub>=3；如果 N=7，那么 N<sub>1</sub> 也等于 3。</p><p><strong>2. 计算 N<sub>2</sub> 的可选值</strong></p><p>N<sub>2</sub> 的计算规则和 N<sub>1</sub> 非常类似，只是 N<sub>2 </sub>的取值是在一个取值范围内：</p><div class=\"cnblogs_code\"><pre class=\"crayon-plain-tag\">N2 的取值范围是 1~(N-N1)/2</pre></div><p>即如果 N=8，那么 N<sub>1</sub>=3，则 N<sub>2</sub> 的取值范围就是 1~2，分别是 1 和 2。注意，1 和 2 仅仅是 N<sub>2</sub> 的可选值，并非最终值——如果 N<sub>2</sub> 为某个可选值的时候，无法计算出 N<sub>3</sub> 的值，那么该可选值也无效。</p><p><strong>3. 计算 N<sub>3</sub>，同时确定 N<sub>2</sub> 的值</strong></p><p>很显然，现在只剩下 N<sub>3</sub> 了，可以简单的认为 N<sub>3</sub> 的取值就是剩下的机器数，即：</p><div class=\"cnblogs_code\"><pre class=\"crayon-plain-tag\">N3 = N - N1 - N2</pre></div><p>只是 N<sub>3</sub> 的取值必须满足 N<sub>3</sub> &lt; N<sub>1</sub>+N2。在满足这个条件的基础下，我们遍历步骤 2 中计算得到的 N<sub>2</sub> 的可选值，即可得到三机房部署时每个机房的服务器数量了。</p><p>现在我们以 7 台机器为例，来看看如何分配三机房的机器分布。根据算法的步骤 1，我们首先确定 N<sub>1</sub> 的取值为 3。根据算法的步骤 2，我们确定了 N<sub>2</sub> 的可选值为 1 和 2。最后根据步骤 3，我们遍历 N<sub>2</sub> 的可选值，即可得到两种部署方案，分别是 (3,1,3) 和 (3,2,2)。以下是 Java 程序代码对以上算法的一种简单实现：</p><div class=\"cnblogs_code\"><pre class=\"crayon-plain-tag\">public class Allocation {
    
    static final int n = 7;
    public static void main(String[] args){
        int n1,n2,n3;
        n1 = (n-1) / 2;
        int n2_max = (n-n1) / 2;
        for(int i=1; i&lt;=n2_max; i++){
            n2 = i;
            n3 = n - n1 -n2;
            if(n3&gt;= (n1+n2)){
                continue;
            }
            System.out.println(\"(\"+n1+\",\"+n2+\",\"+n3+\")\");
        }
    }
}</pre></div><p><strong>水平扩容</strong></p><p>水平可扩容可以说是对一个分布式系统在高可用性方面提出的基本的，也是非常重要的一个要求，通过水平扩容能够帮助系统在不进行或进行极少改进工作的前提下，快速提高系统对外的服务支撑能力。简单地讲，水平扩容就是向集群中添加更多的机器，以提高系统的服务质量。</p><p>很遗憾的是，ZooKeeper 在水平扩容扩容方面做得并不十分完美，需要进行整个集群的重启。通常有两种重启方式，一种是集群整体重启，另外一种是逐台进行服务器的重启。</p><p><strong>整体重启</strong></p><p>所谓集群整体重启，就是先将整个集群停止，然后更新 ZooKeeper 的配置，然后再次启动。如果在你的系统中，ZooKeeper 并不是个非常核心的组件，并且能够允许短暂的服务停止（通常是几秒钟的时间间隔），那么不妨选择这种方式。在整体重启的过程中，所有该集群的客户端都无法 连接上集群。等到集群再次启动，这些客户端就能够自动连接上——注意，整体启动前建立起的客户端会话，并不会因为此次整体重启而失效。也就是说，在整体重启期间花费的时间将不计入会话超时时间的计算中。</p><p><strong>逐台重启</strong></p><p>这种方式更适合绝大多数的实际场景。在这种方式中，每次仅仅重启集群中的一台机器，然后逐台对整个集群中的机器进行重启操作。这种方式可以在重启期间依然保证集群对外的正常服务。</p><p>&nbsp;</p><div class=\"wp_rp_wrap  wp_rp_plain\" ><div class=\"wp_rp_content\"><h3 class=\"related_post_title\">相关文章</h3><ul class=\"related_post wp_rp\" style=\"visibility: visible\"><li ><a href=\"http://blog.jobbole.com/98633/\" class=\"wp_rp_title\">StackOverflow 这么大，它的架构是怎么样的？</a></li><li ><a href=\"http://blog.jobbole.com/91738/\" class=\"wp_rp_title\">亿级Web系统搭建：单机到分布式集群</a></li><li ><a href=\"http://blog.jobbole.com/45721/\" class=\"wp_rp_title\">Zookeeper与paxos算法</a></li><li ><a href=\"http://blog.jobbole.com/99195/\" class=\"wp_rp_title\">Kafka集群操作指南</a></li><li ><a href=\"http://blog.jobbole.com/103116/\" class=\"wp_rp_title\">游戏服务端究竟解决了什么问题？</a></li><li ><a href=\"http://blog.jobbole.com/97806/\" class=\"wp_rp_title\">数据库集群技术漫谈</a></li><li ><a href=\"http://blog.jobbole.com/34212/\" class=\"wp_rp_title\">可伸缩系统的架构经验</a></li><li ><a href=\"http://blog.jobbole.com/99246/\" class=\"wp_rp_title\">Codis集群搭建摘要</a></li><li ><a href=\"http://blog.jobbole.com/98873/\" class=\"wp_rp_title\">Docker + Swarm + etcd 集群搭建</a></li><li ><a href=\"http://blog.jobbole.com/98446/\" class=\"wp_rp_title\">CentOS 7下搭建高可用集群</a></li></ul></div></div><p><a href=\"http://blog.jobbole.com/104092/\">构建高可用ZooKeeper集群</a>，首发于<a href=\"http://blog.jobbole.com\">文章 - 伯乐在线</a>。</p>") (wfw:commentRss nil "http://blog.jobbole.com/104092/feed/") (slash:comments nil "0"))) ("Linux环境多线程编程基础设施" "<p style=\"text-align: justify\">本文介绍多线程环境下并行编程的基础设施。主要包括：</p><blockquote><ul><li>volatile</li><li>__thread</li><li>Memory Barrier</li><li>__sync_synchronize</li></ul></blockquote><h2 id=\"volatile\" style=\"text-align: justify\">volatile</h2><p style=\"text-align: justify\">编译器有时候为了优化性能，会将一些变量的值缓存到寄存器中，因此如果编译器发现该变量的值没有改变的话，将从寄存器里读出该值，这样可以避免内存访问。</p><p style=\"text-align: justify\">但是这种做法有时候会有问题。如果该变量确实（以某种很难检测的方式）被修改呢？那岂不是读到错的值？是的。在多线程情况下，问题更为突出：当某个线程对一个内存单元进行修改后，其他线程如果从寄存器里读取该变量可能读到老值，未更新的值，错误的值，不新鲜的值。</p><p style=\"text-align: justify\"><span id=\"more-104086\"></span></p><p style=\"text-align: justify\">如何防止这样错误的“优化”？方法就是给变量加上<strong>volatile</strong>修饰。</p><p></p><pre class=\"crayon-plain-tag\">volatile int i=10;//用volatile修饰变量i
......//something happened
int b = i;//强制从内存中读取实时的i的值</pre><p></p><p style=\"text-align: justify\"><strong>OK</strong>，毕竟<strong>volatile</strong>不是完美的，它也在某种程度上限制了优化。有时候是不是有这样的需求：我要你立即实时读取数据的时候，你就访问内存，别优化；否则，你该优化还是优化你的。能做到吗？</p><p style=\"text-align: justify\">不加<strong>volatile</strong>修饰，那么就做不到前面一点。加了<strong>volatile</strong>，后面这一方面就无从谈起，怎么办？伤脑筋。</p><p style=\"text-align: justify\">其实我们可以这样：</p><p></p><pre class=\"crayon-plain-tag\">int i = 2; //变量i还是不用加volatile修饰
#define ACCESS_ONCE(x) (* (volatile typeof(x) *) &amp;(x))</pre><p></p><p style=\"text-align: justify\">需要实时读取i的值时候，就调用<code>ACCESS_ONCE(i)</code>，否则直接使用i即可。</p><p style=\"text-align: justify\">这个技巧，我是从《<strong>Is parallel programming hard？</strong>》上学到的。</p><p style=\"text-align: justify\">听起来都很好？然而险象环生：<strong>volatile</strong>常被误用，很多人往往不知道或者忽略它的两个特点：在<strong>C/C++</strong>语言里，<strong>volatile</strong>不保证原子性；使用<strong>volatile</strong>不应该对它有任何<strong>Memory Barrier</strong>的期待。</p><p style=\"text-align: justify\">第一点比较好理解，对于第二点，我们来看一个很经典的例子：</p><p></p><pre class=\"crayon-plain-tag\">volatile int is_ready = 0;
char message[123];
void thread_A
{
while(is_ready == 0)
{
}
//use message;
}
void thread_B
{
strcpy(message,\"everything seems ok\");
is_ready = 1;
}</pre><p></p><p style=\"text-align: justify\">线程<strong>B</strong>中，虽然<strong>is_ready</strong>有<strong>volatile</strong>修饰，但是这里的<strong>volatile</strong>不提供任何<strong>Memory Barrier</strong>，因此<strong>12</strong>行和<strong>13</strong>行可能被乱序执行，<code>is_ready = 1</code>被执行，而<strong>message</strong>还未被正确设置，导致线程<strong>A</strong>读到错误的值。</p><p style=\"text-align: justify\">这意味着，在多线程中使用<strong>volatile</strong>需要非常谨慎、小心。</p><h2 id=\"thread\" style=\"text-align: justify\">__thread</h2><p style=\"text-align: justify\"><strong>__thread</strong>是<strong>gcc</strong>内置的用于多线程编程的基础设施。用<strong>__thread</strong>修饰的变量，每个线程都拥有一份实体，相互独立，互不干扰。举个例子：</p><p></p><pre class=\"crayon-plain-tag\">#include
#include
#include
using namespace std;
__thread int i = 1;
void* thread1(void* arg);
void* thread2(void* arg);
int main()
{
pthread_t pthread1;
pthread_t pthread2;
pthread_create(&amp;pthread1, NULL, thread1, NULL);
pthread_create(&amp;pthread2, NULL, thread2, NULL);
pthread_join(pthread1, NULL);
pthread_join(pthread2, NULL);
return 0;
}
void* thread1(void* arg)
{
coutiendl;//输出 2
return NULL;
}
void* thread2(void* arg)
{
sleep(1); //等待thread1完成更新
coutiendl;//输出 2，而不是3
return NULL;
}</pre><p></p><p style=\"text-align: justify\">需要注意的是：</p><p style=\"text-align: justify\">1，<strong>__thread</strong>可以修饰全局变量、函数的静态变量，但是无法修饰函数的局部变量。</p><p style=\"text-align: justify\">2，被<strong>__thread</strong>修饰的变量只能在编译期初始化，且只能通过常量表达式来初始化。</p><h2 id=\"memory-barrier\" style=\"text-align: justify\">Memory Barrier</h2><p style=\"text-align: justify\">为了优化，现代编译器和<strong>CPU</strong>可能会乱序执行指令。例如：</p><p></p><pre class=\"crayon-plain-tag\">int a = 1;
int b = 2;
a = b + 3;
b = 10;</pre><p></p><p style=\"text-align: justify\"><strong>CPU</strong>乱序执行后，第4行语句和第5行语句的执行顺序可能变为先<code>b=10</code>然后再<code>a=b+3</code></p><p style=\"text-align: justify\">有些人可能会说，那结果不就不对了吗？b为10，a为13？可是正确结果应该是a为5啊。</p><p style=\"text-align: justify\">哦，这里说的是语句的执行，对应的汇编指令不是简单的mov b,10和mov b,a+3。</p><p style=\"text-align: justify\">生成的汇编代码可能是：</p><p></p><pre class=\"crayon-plain-tag\">movl    b(%rip), %eax ; 将b的值暂存入%eax
movl    $10, b(%rip) ; b = 10
addl    $3, %eax ; %eax加3
movl    %eax, a(%rip) ; 将%eax也就是b+3的值写入a,即 a = b + 3</pre><p></p><p style=\"text-align: justify\">这并不奇怪，为了优化性能，有时候确实可以这么做。但是在多线程并行编程中，有时候乱序就会出问题。</p><p style=\"text-align: justify\">一个最典型的例子是用锁保护临界区。如果临界区的代码被拉到加锁前或者释放锁之后执行，那么将导致不明确的结果，往往让人不开心的结果。</p><p style=\"text-align: justify\">还有，比如随意将读数据和写数据乱序，那么本来是先读后写，变成先写后读就导致后面读到了脏的数据。因此，<strong>Memory Barrier</strong>就是用来防止乱序执行的。具体说来，<strong>Memory Barrier</strong>包括三种：</p><p style=\"text-align: justify\">1，<strong>acquire barrier</strong>。<strong>acquire barrier</strong>之后的指令不能也不会被拉到该<strong>acquire barrier</strong>之前执行。</p><p style=\"text-align: justify\">2，<strong>release barrier</strong>。<strong>release barrier</strong>之前的指令不能也不会被拉到该<strong>release barrier</strong>之后执行。</p><p style=\"text-align: justify\">3，<strong>full barrier</strong>。以上两种的合集。</p><p style=\"text-align: justify\">所以，很容易知道，加锁，也就是<strong>lock</strong>对应<strong>acquire barrier</strong>；释放锁，也就是<strong>unlock</strong>对应<strong>release barrier</strong>。哦，那么<strong>full barrier</strong>呢？</p><h2 id=\"syncsynchronize\" style=\"text-align: justify\">__sync_synchronize</h2><p style=\"text-align: justify\"><code>__sync_synchronize</code>就是一种<strong>full barrier</strong>。</p><div class=\"wp_rp_wrap  wp_rp_plain\" id=\"wp_rp_first\"><div class=\"wp_rp_content\"><h3 class=\"related_post_title\">相关文章</h3><ul class=\"related_post wp_rp\" style=\"visibility: visible\"><li ><a href=\"http://blog.jobbole.com/92792/\" class=\"wp_rp_title\">Linux Shell 创建序列数组</a></li><li ><a href=\"http://blog.jobbole.com/93132/\" class=\"wp_rp_title\">Linux Shell 管道命令(pipe)使用及与 Shell 重定向区别</a></li><li ><a href=\"http://blog.jobbole.com/97676/\" class=\"wp_rp_title\">基于 JavaScript 的操作系统你听说过吗？</a></li><li ><a href=\"http://blog.jobbole.com/104042/\" class=\"wp_rp_title\">如何在 Linux 下检测内存泄漏</a></li><li ><a href=\"http://blog.jobbole.com/98633/\" class=\"wp_rp_title\">StackOverflow 这么大，它的架构是怎么样的？</a></li><li ><a href=\"http://blog.jobbole.com/101619/\" class=\"wp_rp_title\">Linux 信号应用之黑匣子程序设计</a></li><li ><a href=\"http://blog.jobbole.com/23638/\" class=\"wp_rp_title\">28个Unix/Linux的命令行神器</a></li><li ><a href=\"http://blog.jobbole.com/91887/\" class=\"wp_rp_title\">Linux内存管理：Malloc</a></li><li ><a href=\"http://blog.jobbole.com/91891/\" class=\"wp_rp_title\">Linux 内存管理：内存映射 </a></li><li ><a href=\"http://blog.jobbole.com/86521/\" class=\"wp_rp_title\">深入浅出：Linux设备驱动中的并发控制</a></li></ul></div></div><p><a href=\"http://blog.jobbole.com/104086/\">Linux环境多线程编程基础设施</a>，首发于<a href=\"http://blog.jobbole.com\">文章 - 伯乐在线</a>。</p>" "http://blog.jobbole.com/104086/" (22433 21216) old 3 nil nil ((title nil "Linux环境多线程编程基础设施") (link nil "http://blog.jobbole.com/104086/") (comments nil "http://blog.jobbole.com/104086/#respond") (pubDate nil "Wed, 03 Aug 2016 02:11:44 +0000") (dc:creator nil "ABOER") (category nil "IT技术") (category nil "Linux") (guid ((isPermaLink . "false")) "http://blog.jobbole.com/?p=104086") (description nil "<p>编译器有时候为了优化性能，会将一些变量的值缓存到寄存器中，因此如果编译器发现该变量的值没有改变的话，将从寄存器里读出该值，这样可以避免内存访问。</p><p><a href=\"http://blog.jobbole.com/104086/\">Linux环境多线程编程基础设施</a>，首发于<a href=\"http://blog.jobbole.com\">文章 - 伯乐在线</a>。</p>") (content:encoded nil "<p style=\"text-align: justify\">本文介绍多线程环境下并行编程的基础设施。主要包括：</p><blockquote><ul><li>volatile</li><li>__thread</li><li>Memory Barrier</li><li>__sync_synchronize</li></ul></blockquote><h2 id=\"volatile\" style=\"text-align: justify\">volatile</h2><p style=\"text-align: justify\">编译器有时候为了优化性能，会将一些变量的值缓存到寄存器中，因此如果编译器发现该变量的值没有改变的话，将从寄存器里读出该值，这样可以避免内存访问。</p><p style=\"text-align: justify\">但是这种做法有时候会有问题。如果该变量确实（以某种很难检测的方式）被修改呢？那岂不是读到错的值？是的。在多线程情况下，问题更为突出：当某个线程对一个内存单元进行修改后，其他线程如果从寄存器里读取该变量可能读到老值，未更新的值，错误的值，不新鲜的值。</p><p style=\"text-align: justify\"><span id=\"more-104086\"></span></p><p style=\"text-align: justify\">如何防止这样错误的“优化”？方法就是给变量加上<strong>volatile</strong>修饰。</p><p></p><pre class=\"crayon-plain-tag\">volatile int i=10;//用volatile修饰变量i
......//something happened 
int b = i;//强制从内存中读取实时的i的值</pre><p></p><p style=\"text-align: justify\"><strong>OK</strong>，毕竟<strong>volatile</strong>不是完美的，它也在某种程度上限制了优化。有时候是不是有这样的需求：我要你立即实时读取数据的时候，你就访问内存，别优化；否则，你该优化还是优化你的。能做到吗？</p><p style=\"text-align: justify\">不加<strong>volatile</strong>修饰，那么就做不到前面一点。加了<strong>volatile</strong>，后面这一方面就无从谈起，怎么办？伤脑筋。</p><p style=\"text-align: justify\">其实我们可以这样：</p><p></p><pre class=\"crayon-plain-tag\">int i = 2; //变量i还是不用加volatile修饰

#define ACCESS_ONCE(x) (* (volatile typeof(x) *) &amp;(x))</pre><p></p><p style=\"text-align: justify\">需要实时读取i的值时候，就调用<code>ACCESS_ONCE(i)</code>，否则直接使用i即可。</p><p style=\"text-align: justify\">这个技巧，我是从《<strong>Is parallel programming hard？</strong>》上学到的。</p><p style=\"text-align: justify\">听起来都很好？然而险象环生：<strong>volatile</strong>常被误用，很多人往往不知道或者忽略它的两个特点：在<strong>C/C++</strong>语言里，<strong>volatile</strong>不保证原子性；使用<strong>volatile</strong>不应该对它有任何<strong>Memory Barrier</strong>的期待。</p><p style=\"text-align: justify\">第一点比较好理解，对于第二点，我们来看一个很经典的例子：</p><p></p><pre class=\"crayon-plain-tag\">volatile int is_ready = 0;
char message[123];
void thread_A
{
  while(is_ready == 0)
  {
  }
  //use message;
}
void thread_B
{
  strcpy(message,\"everything seems ok\");
  is_ready = 1;
}</pre><p></p><p style=\"text-align: justify\">线程<strong>B</strong>中，虽然<strong>is_ready</strong>有<strong>volatile</strong>修饰，但是这里的<strong>volatile</strong>不提供任何<strong>Memory Barrier</strong>，因此<strong>12</strong>行和<strong>13</strong>行可能被乱序执行，<code>is_ready = 1</code>被执行，而<strong>message</strong>还未被正确设置，导致线程<strong>A</strong>读到错误的值。</p><p style=\"text-align: justify\">这意味着，在多线程中使用<strong>volatile</strong>需要非常谨慎、小心。</p><h2 id=\"thread\" style=\"text-align: justify\">__thread</h2><p style=\"text-align: justify\"><strong>__thread</strong>是<strong>gcc</strong>内置的用于多线程编程的基础设施。用<strong>__thread</strong>修饰的变量，每个线程都拥有一份实体，相互独立，互不干扰。举个例子：</p><p></p><pre class=\"crayon-plain-tag\">#include
#include
#include
using namespace std;
__thread int i = 1;
void* thread1(void* arg);
void* thread2(void* arg);
int main()
{
  pthread_t pthread1;
  pthread_t pthread2;
  pthread_create(&amp;pthread1, NULL, thread1, NULL);
  pthread_create(&amp;pthread2, NULL, thread2, NULL);
  pthread_join(pthread1, NULL);
  pthread_join(pthread2, NULL);
  return 0;
}
void* thread1(void* arg)
{
  coutiendl;//输出 2  
  return NULL;
}
void* thread2(void* arg)
{
  sleep(1); //等待thread1完成更新
  coutiendl;//输出 2，而不是3
  return NULL;
}</pre><p></p><p style=\"text-align: justify\">需要注意的是：</p><p style=\"text-align: justify\">1，<strong>__thread</strong>可以修饰全局变量、函数的静态变量，但是无法修饰函数的局部变量。</p><p style=\"text-align: justify\">2，被<strong>__thread</strong>修饰的变量只能在编译期初始化，且只能通过常量表达式来初始化。</p><h2 id=\"memory-barrier\" style=\"text-align: justify\">Memory Barrier</h2><p style=\"text-align: justify\">为了优化，现代编译器和<strong>CPU</strong>可能会乱序执行指令。例如：</p><p></p><pre class=\"crayon-plain-tag\">int a = 1;
int b = 2;
a = b + 3;
b = 10;</pre><p></p><p style=\"text-align: justify\"><strong>CPU</strong>乱序执行后，第4行语句和第5行语句的执行顺序可能变为先<code>b=10</code>然后再<code>a=b+3</code></p><p style=\"text-align: justify\">有些人可能会说，那结果不就不对了吗？b为10，a为13？可是正确结果应该是a为5啊。</p><p style=\"text-align: justify\">哦，这里说的是语句的执行，对应的汇编指令不是简单的mov b,10和mov b,a+3。</p><p style=\"text-align: justify\">生成的汇编代码可能是：</p><p></p><pre class=\"crayon-plain-tag\">movl    b(%rip), %eax ; 将b的值暂存入%eax
movl    $10, b(%rip) ; b = 10
addl    $3, %eax ; %eax加3
movl    %eax, a(%rip) ; 将%eax也就是b+3的值写入a,即 a = b + 3</pre><p></p><p style=\"text-align: justify\">这并不奇怪，为了优化性能，有时候确实可以这么做。但是在多线程并行编程中，有时候乱序就会出问题。</p><p style=\"text-align: justify\">一个最典型的例子是用锁保护临界区。如果临界区的代码被拉到加锁前或者释放锁之后执行，那么将导致不明确的结果，往往让人不开心的结果。</p><p style=\"text-align: justify\">还有，比如随意将读数据和写数据乱序，那么本来是先读后写，变成先写后读就导致后面读到了脏的数据。因此，<strong>Memory Barrier</strong>就是用来防止乱序执行的。具体说来，<strong>Memory Barrier</strong>包括三种：</p><p style=\"text-align: justify\">1，<strong>acquire barrier</strong>。<strong>acquire barrier</strong>之后的指令不能也不会被拉到该<strong>acquire barrier</strong>之前执行。</p><p style=\"text-align: justify\">2，<strong>release barrier</strong>。<strong>release barrier</strong>之前的指令不能也不会被拉到该<strong>release barrier</strong>之后执行。</p><p style=\"text-align: justify\">3，<strong>full barrier</strong>。以上两种的合集。</p><p style=\"text-align: justify\">所以，很容易知道，加锁，也就是<strong>lock</strong>对应<strong>acquire barrier</strong>；释放锁，也就是<strong>unlock</strong>对应<strong>release barrier</strong>。哦，那么<strong>full barrier</strong>呢？</p><h2 id=\"syncsynchronize\" style=\"text-align: justify\">__sync_synchronize</h2><p style=\"text-align: justify\"><code>__sync_synchronize</code>就是一种<strong>full barrier</strong>。</p><div class=\"wp_rp_wrap  wp_rp_plain\" id=\"wp_rp_first\"><div class=\"wp_rp_content\"><h3 class=\"related_post_title\">相关文章</h3><ul class=\"related_post wp_rp\" style=\"visibility: visible\"><li ><a href=\"http://blog.jobbole.com/92792/\" class=\"wp_rp_title\">Linux Shell 创建序列数组</a></li><li ><a href=\"http://blog.jobbole.com/93132/\" class=\"wp_rp_title\">Linux Shell 管道命令(pipe)使用及与 Shell 重定向区别</a></li><li ><a href=\"http://blog.jobbole.com/97676/\" class=\"wp_rp_title\">基于 JavaScript 的操作系统你听说过吗？</a></li><li ><a href=\"http://blog.jobbole.com/104042/\" class=\"wp_rp_title\">如何在 Linux 下检测内存泄漏</a></li><li ><a href=\"http://blog.jobbole.com/98633/\" class=\"wp_rp_title\">StackOverflow 这么大，它的架构是怎么样的？</a></li><li ><a href=\"http://blog.jobbole.com/101619/\" class=\"wp_rp_title\">Linux 信号应用之黑匣子程序设计</a></li><li ><a href=\"http://blog.jobbole.com/23638/\" class=\"wp_rp_title\">28个Unix/Linux的命令行神器</a></li><li ><a href=\"http://blog.jobbole.com/91887/\" class=\"wp_rp_title\">Linux内存管理：Malloc</a></li><li ><a href=\"http://blog.jobbole.com/91891/\" class=\"wp_rp_title\">Linux 内存管理：内存映射 </a></li><li ><a href=\"http://blog.jobbole.com/86521/\" class=\"wp_rp_title\">深入浅出：Linux设备驱动中的并发控制</a></li></ul></div></div><p><a href=\"http://blog.jobbole.com/104086/\">Linux环境多线程编程基础设施</a>，首发于<a href=\"http://blog.jobbole.com\">文章 - 伯乐在线</a>。</p>") (wfw:commentRss nil "http://blog.jobbole.com/104086/feed/") (slash:comments nil "0"))) ("理解 glibc 内存分配器的机制与实现" "<p>一直以来，我都沉迷于堆内存的一切。脑子里一直充斥着这些问题：</p><ul><li>怎样从内核获取堆内存？</li><li>内存管理的效率如何?</li><li>是什么在管理它？内核？库函数？还是应用程序？</li><li>堆内存可以扩展吗？</li></ul><p>直到最近我才有时间思考并理解这些问题。所以想在本文和大家分享我的思考过程。除了我们即将讨论的内存分配器，还有如下几种的存在：</p><ul><li>dlmalloc – General purpose allocator</li><li>ptmalloc2 – glibc</li><li>jemalloc – FreeBSD and Firefox</li><li>tcmalloc – Google</li><li>libumem – Solaris …</li></ul><p>每个内存分配器都说自己可以快速分配内存、可扩展而且高效。但并不是所有的分配器都适用于我们的应用程序。像那些对内存异常渴求的应用程序来说，它的性能很大程度上依赖于内存分配器的性能。在这篇文章中，我打算只介绍 ‘glibc malloc’内存分配器。希望未来有机会可以介绍其他几种。为了帮助大家深入理解 ‘glibc malloc’，本文会贴一些源代码。现在，准备好了吗？开始 glibc malloc 吧！</p><h1>历史</h1><p>ptmalloc2 是 dlmalloc 的分支。于 2006 年发布，在这条分支上，添加了对线程的支持。在正式版发布后， ptmalloc2 被集成到 glibc 的源代码中。在这之后，对这个内存分配器的修改直接在 glibc malloc 的源码中进行。今后，ptmalloc2 和 glibc的 malloc 之间可能差异会越来越大。</p><p>系统调用：从本文的分析中，我们会发现 malloc 内部要么调用 brk，要么调用 mmap。</p><p>线程化：</p><p>在早期的 linux 中，将 dlmalloc 作为默认的内存分配器。不过由于 ptmalloc2 对线程的支持，它便取代了 dlmalloc 的地位。线程化可以提高内存分配器的性能从而提高应用程序的性能。在 dlmalloc 中，如果两个线程同时调用 malloc，由于数据结构 freelist 在所有线程间共享, 只有一个线程可以进入临界区。这样导致了在多线程的应用程序中，malloc 会很浪费时间，从而降低应用程序的性能。而在 ptmalloc2 中，当两个线程同时调用 malloc 就不会出现这种窘境，因为每个线程都有自己独立的 heap 段，管理 heap 的freelist 结构也是相互独立的，从而不管多少线程同时请求内存，都会立即分配完成。这种每个线程都有独立 heap、独立 freelist 的行为称为 “per thread arena”。</p><h1>例子</h1><p></p><pre class=\"crayon-plain-tag\">/* Per thread arena example. */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;pthread.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
void* threadFunc(void* arg) {
printf(\"Before malloc in thread 1n\");
getchar();
char* addr = (char*) malloc(1000);
printf(\"After malloc and before free in thread 1n\");
getchar();
free(addr);
printf(\"After free in thread 1n\");
getchar();
}
int main() {
pthread_t t1;
void* s;
int ret;
char* addr;
printf(\"Welcome to per thread arena example::%dn\",getpid());
printf(\"Before malloc in main threadn\");
getchar();
addr = (char*) malloc(1000);
printf(\"After malloc and before free in main threadn\");
getchar();
free(addr);
printf(\"After free in main threadn\");
getchar();
ret = pthread_create(&amp;t1, NULL, threadFunc, NULL);
if(ret)
{
printf(\"Thread creation errorn\");
return -1;
}
ret = pthread_join(t1, &amp;s);
if(ret)
{
printf(\"Thread join errorn\");
return -1;
}
return 0;
}</pre><p>输出分析：</p><p>在 main 线程 malloc 之前：从下面的输出我们可以看出，由于此时还没有创建线程 thread1，从而没有 heap 段，也没有线程栈。</p><pre class=\"crayon-plain-tag\">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ./mthread
Welcome to per thread arena example::6501
Before malloc in main thread
...
sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ cat /proc/6501/maps
08048000-08049000 r-xp 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread
08049000-0804a000 r--p 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread
0804a000-0804b000 rw-p 00001000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread
b7e05000-b7e07000 rw-p 00000000 00:00 0
...
sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$</pre><p>在 main 线程 malloc 后：从下面输出能看出， heap segment已经创建了，并且就处于 data segment(0804b000-0806c000)之上。这就意味着： heap 内存是通过增加程序中断点(program break location)来创建的(例如，系统调用 brk)。同时请注意，尽管程序中只申请 1000字节的内存，创建的 heap 内存却是 132KB。这一段连续的 heap 内存被称为 “arena”。由于它是在 main 线程中创建，所以也被称为 “main arena”。在这之后的内存请求都会使用这一块 “arena”，直到消耗完这片空间。当 arena 耗完，可以通过增加程序中断点的方式来增加 arena(在增加之后，top chunk 的大小也会随之调整)。与之类似，如果 top chunk 中有过多的空闲空间， arena 的区域也会收缩。</p><p>注意： 所谓 “top chunk” 指的是 “arena” 最顶部的内存块。想要了解更多知识，请看下面 ”Top Chunk” 的内容。</p><pre class=\"crayon-plain-tag\">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ./mthread
Welcome to per thread arena example::6501
Before malloc in main thread
After malloc and before free in main thread
...
sploitfun@sploitfun-VirtualBox:~/lsploits/hof/ptmalloc.ppt/mthread$ cat /proc/6501/maps
08048000-08049000 r-xp 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread
08049000-0804a000 r--p 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread
0804a000-0804b000 rw-p 00001000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread
0804b000-0806c000 rw-p 00000000 00:00 0          [heap]
b7e05000-b7e07000 rw-p 00000000 00:00 0
...
sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$</pre><p>Main 线程 free 内存后：从下面输出可以看出，当我们在程序中释放已分配的内存后，实际上这块内存并没有立即还给操作系统。这块已分配的内存(大小为 1000 字节)仅仅是释放给了 ‘glibc malloc’ 的库，这个库将这块空闲出来的内存块添加到 “main arena bin” 中(在 glibc malloc 中，freelist 结构被认为是一个个容器 bins)。在这之后，一旦用户请求内存， ‘glibc malloc’ 不再从 kernel 请求 heap 内存，而是从这些 bin 中找到空闲的内存块分配出去。只有当找不到空闲的内存块时，它才会从 kernel 请求新的内存。</p><pre class=\"crayon-plain-tag\">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ./mthread
Welcome to per thread arena example::6501
Before malloc in main thread
After malloc and before free in main thread
After free in main thread
...
sploitfun@sploitfun-VirtualBox:~/lsploits/hof/ptmalloc.ppt/mthread$ cat /proc/6501/maps
08048000-08049000 r-xp 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread
08049000-0804a000 r--p 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread
0804a000-0804b000 rw-p 00001000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread
0804b000-0806c000 rw-p 00000000 00:00 0          [heap]
b7e05000-b7e07000 rw-p 00000000 00:00 0</pre><p>Thread1 线程 malloc 之前：从下面的输出可以看出，此时没有thread1 的 heap segment，但是线程栈已经创建了。</p><pre class=\"crayon-plain-tag\">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ./mthread
Welcome to per thread arena example::6501
Before malloc in main thread
After malloc and before free in main thread
After free in main thread
Before malloc in thread 1
...
sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ cat /proc/6501/maps
08048000-08049000 r-xp 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread
08049000-0804a000 r--p 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread
0804a000-0804b000 rw-p 00001000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread
0804b000-0806c000 rw-p 00000000 00:00 0          [heap]
b7604000-b7605000 ---p 00000000 00:00 0
b7605000-b7e07000 rw-p 00000000 00:00 0          [stack:6594]
...
sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$</pre><p>Thread1 线程 malloc 之后：从下面输出可以看出，thread1的 heap segment 也已经创建了。并且就处于内存映射段(b7500000-b7521000 大小为 132 Kb)中，由此我们可以得出结论：不同于 main 线程，这里的 heap 内存是通过系统调用 mmap 来创建的。同样，即便用户只请求了 1000 字节，实际映射到进程地址空间的大小为 1M。在这 1M 内存中，只有 132K 的内存被赋予了读写权限，作为该线程的 heap 内存。这一块连续的内存块被称为 “thread arena”。</p><p>注意：如果用户请求内存大小超过 128K（比如 malloc(132*1024)），并且单个 arena 无法满足用户需求的情况下，不管这个内存请求来自 main arena 还是 thread arena，都会采用 mmap 的方式来分配内存。</p><pre class=\"crayon-plain-tag\">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ./mthread
Welcome to per thread arena example::6501
Before malloc in main thread
After malloc and before free in main thread
After free in main thread
Before malloc in thread 1
After malloc and before free in thread 1
...
sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ cat /proc/6501/maps
08048000-08049000 r-xp 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread
08049000-0804a000 r--p 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread
0804a000-0804b000 rw-p 00001000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread
0804b000-0806c000 rw-p 00000000 00:00 0          [heap]
b7500000-b7521000 rw-p 00000000 00:00 0
b7521000-b7600000 ---p 00000000 00:00 0
b7604000-b7605000 ---p 00000000 00:00 0
b7605000-b7e07000 rw-p 00000000 00:00 0          [stack:6594]
...
sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$</pre><p>Thread1 中释放内存之后： 同样，这块内存实际上也并没有还给操作系统。而是被转交给了’glibc malloc’，从而被添加到 thread arena bin 的空闲块中。</p><pre class=\"crayon-plain-tag\">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ./mthread
Welcome to per thread arena example::6501
Before malloc in main thread
After malloc and before free in main thread
After free in main thread
Before malloc in thread 1
After malloc and before free in thread 1
After free in thread 1
...
sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ cat /proc/6501/maps
08048000-08049000 r-xp 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread
08049000-0804a000 r--p 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread
0804a000-0804b000 rw-p 00001000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread
0804b000-0806c000 rw-p 00000000 00:00 0          [heap]
b7500000-b7521000 rw-p 00000000 00:00 0
b7521000-b7600000 ---p 00000000 00:00 0
b7604000-b7605000 ---p 00000000 00:00 0
b7605000-b7e07000 rw-p 00000000 00:00 0          [stack:6594]
...
sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$</pre><p>Arena 的数量： 从上面几个例子中，我们可以看到主线程有 main arena，线程1 有它自己的 thread arena。那么问题来了，我们是否可以不管线程个数多少，都将线程与 arena 的个数做一一映射呢？答案是 NO！某些应用程序可能有很多线程（大于 CPU 个数），在这种情况下，如果我们给每个线程配一个 arena 简直是自作孽，而且很没意义。所以呢，我们应用程序的 arena 数目受制于系统中 CPU 个数。</p><p>&nbsp;</p><p>对 32 位系统:</p><p>arena 个数 = 2 <em> 核心个</em></p><p><em>对</em><em>64 位系统: arena 个数 = 8 </em> 核心个数</p><p>例如： 假设有个多线程程序（4 个线程 ———— 主线程 + 3 个用户线程） 跑在 32 位的单核系统上，线程数大于 2 乘以核心个数（2*1 = 2）.碰到这种情况， glibc malloc 会保证所有可用的线程间共享多个 arena。但是这种共享是怎么实现的呢？</p><p>在主线程中，当我们第一次调用 malloc 函数会创建 main arena，这是毋庸置疑的。</p><p>在线程1、线程2 中第一次调用 malloc 函数后，会分别给他俩创建各自的 arena。直到线程和 arena 达到了一对一映射。</p><p>在线程3中，第一次调用 malloc 函数，这时候会计算是否到了 arena 最大数。在这个例子中已经达到限额了，因此会尝试复用其他已存在的 arena（主线程或线程1 或线程2的arena）。</p><p>复用： 遍历所有可用的 arena，并尝试给 arena 枷锁。</p><p>如果成功枷锁（假设 main rena 被锁住），将这个 arena 返回给用户。</p><p>&nbsp;</p><p>如果没有找到空闲的 arena，那么就会堵塞在当前 arena 上。 当线程 3 第二次调用 malloc，malloc 会尝试使用可访问 arena（main arena）。如果 main arena 空闲，直接使用。否则线程3 会被堵塞，直到 main arena 空闲。这时候 main arena 就在主线程和线程 3 之间共享啦！</p><p>下面三个主要数据结构可以在 ‘glibc malloc’ 源码中找到：</p><p>Heap_info – Heap Header – 每个线程 arena 都可以有多个heap 段。每个 heap 段都有自己的 header。为什么需要多个 heap 段呢？一开始的时候，每个线程都只有一个 heap 段的，但是渐渐的，堆空间用光光了，就会调用 mmap 来获取新的heap 段（非连续区域）。</p><p>Mallac_state – Arena Header – 每个线程 arena 可以有多个堆，但是，所有这些堆只能有一个 arena header。Arena header 结构中包含 bin、top chunk、 last reminder chunk 等。</p><p>mallc_chunk – Chunk Header – 由于用户的内存请求，堆会被分割成许多块（chunk）。每个这样的块有着自己的 chunk header。</p><p>注意： Main arena 没有多个 heap 段，也因此没有 heap_info 结构。当 main arena 中堆空间耗尽了，就会调用 sbrk 来扩展堆空间（连续区域），直到heap 段顶端达到了内存映射段。不同于线程 arena，main arena 的 arena header 结构不属于sbrk 的heap 段。它是一个全局变量， 因此我们可以在 libc.so 的数据段中看到它的身影。</p><p>下图很形象的展示了 main arena 和线程 arena 的结构（单个 heap 段）：</p><p><img src=\"http://ww1.sinaimg.cn/mw690/6941baebjw1f6e1ad899xj20qo0k0jud.jpg\" /></p><p>下图展示了线程 arena 的结构（多个 heap 段）：</p><p><img src=\"http://ww4.sinaimg.cn/mw690/6941baebgw1f6e15vnm9wj20qo0k0q5p.jpg\" /></p><p>&nbsp;</p><h1>Chunk</h1><p>&nbsp;</p><p>heap 段中的块可以是以下几种类型：</p><p>已分配的内存块</p><p>空闲内存块</p><p>顶层块</p><p>最终提示块</p><h2>Allocated chunk:</h2><p><img src=\"http://ww4.sinaimg.cn/mw690/6941baebgw1f6e15uwdftj20qq0ixjt3.jpg\" /></p><p>Prev_size: 如果前一个内存块是空闲的，这个字段保存前一个内存块的大小。否则说明前一个内存块已经分配出去了，这个字段保存前一个内存块的用户数据。</p><p>Size: 这个字段保存已分配内存块的大小。最后三个位包含标志信息。</p><p>&nbsp;</p><p>PREV_USE (P) – 前块内存已分配</p><p>IS_MAPPED (M) – 内存块通过 mmap 申请</p><p>NON_MAIN_ARENA (N) – 内存块属于线程 arena</p><p>NOTE:</p><p>Malloc_chunk 的其他字段（例如 fd, bk）不存在于已分配内存块。因此这种内存块的用户数据就保存在这些字段中。</p><p>为了存储 malloc_chunk 结构，还有出于内存对齐的目的，我们需要额外的空间，因此将用户请求的内存大小转化为可用大小（内部表示形式）。转化方式为：可用大小的后三位不置位，用于存储标志信息。</p><h2>Free Chunk:</h2><p><img src=\"http://ww1.sinaimg.cn/mw690/6941baebgw1f6e15ucoyej20q40ikwgc.jpg\" /></p><p>Prev_size : 要知道两块空闲内存块不可能相邻。一旦两个内存块都空闲，它们就会被整合成一整个空闲内存块。也就是说，我们这块空闲内存块的前一个内存块肯定是已分配的，因此， prev_size 字段保存的是前一个内存块的用户数据。</p><p>Size: 这个字段保存当前空闲内存块的大小。</p><p>fd: 前向指针 – 指向同一容器中的下一块内存块（注意是容器，这里并不是物理内存上的下一个 chunk）。</p><p>Bk: 后向指针 – 指向同一容器中的前一个内存块（同上）。</p><h1>Bins:</h1><p>容器（bins）： 容器指的是空闲链表结构 freelist。用于管理多个空闲内存块。根据块大小的不同，容器可以分为：</p><p>用于保存这些容器的数据结构有：</p><p>fastbinsY ： 这个数组用于保存 fast bins。</p><p>Bins ： 这个数组用于后三种容器。一共有 126 个容器，划分为三组：</p><p>Bin 1 – Unsorted bin</p><p>Bin 2 to Bin 63 – Small bin</p><p>Bin 64 to Bin 126 – Large bin</p><p>Fast Bin：</p><p>大小为 16～80字节的内存块称为 fast chunk。保存这些 fast chunk 的容器就是 fast bins。在所有这些容器中， fast bins 操作内存效率高。</p><h3>Number of bins – 10</h3><p>容器 bin 的个数 – 10 每个 fast bin 都包含一个空闲内存块的单链表。之所以采用单链表，是因为 fast bins 中内存块的添加、删除操作都在列表的头尾端进行，不涉及中间段的移除操作 —— 后进先出。</p><h3>Chunk size – 8 bytes apart</h3><p>Chunk 大小 – 以 8 字节划分 Fast bins 包含一条链表 binlist，以 8 字节对齐。例如，第一个 fast bin（索引为0）包含一条链表，它的内存块大小为 16字节，第二个 fast bin 中链表上的内存块大小为 24 字节，以此类推。</p><p>每个 fast bin 中的内存块大小是一致的。</p><p>在 malloc 初始化期间， fast bin 最大值设置为 64 字节（不是80字节）。因此，默认情况下16~64 字节的内存块都被视为 fast chunks。</p><p>不存在合并 ——在 fast bins 中允许相邻两块都是空闲块，不会被自动合并。虽然不合并会导致内存碎片，但是它大大加速了 free 操作！！</p><p>Malloc(fast chunk) – 一开始 fast bin 最大值和fast bin 都是空的，所以不管用户请求的块大小怎样，都不会走到 fast bin 的代码，而是 small bin code。</p><p>之后，由于内存释放等原因，fast bin 不为空，通过fast bin 索引来找到对应的 binlist。</p><p>最后，binlist 中的第一块内存块从链表中移除并返回给用户。</p><p>根据 fast bin 索引值找到对应的 binlist</p><p>这块待释放的内存块添加到上面 binlist 的链表头。</p><p><img src=\"http://ww2.sinaimg.cn/mw690/6941baebgw1f6e15tlvvij20qo0k00v2.jpg\" /></p><h2>Unsorted Bin:</h2><p>当释放small chunk 或者 large chunk时，不会将它们添加到 small bin 或者 large bin 中，而是添加到 unsorted bin。这种解决方案让‘glibc mallc’多了一种重复利用空闲内存块的方式。因为不需要花时间去各自的容器中去找，从而也提高了分配和释放内存的效率。</p><p>Number of bins – 1</p><p>Unsorted bin 中包含空闲内存块的环形双向链表。</p><p>内存块大小 —— 无大小限制，任意大小的内存块都可以。</p><p><img src=\"http://ww2.sinaimg.cn/mw690/6941baebgw1f6e15sxpqkj20xs0o1af1.jpg\" /></p><h2>Small Bin:</h2><p>小于 512 字节的内存块称为 small chunk。容纳这类 small chunk 的称为 small bins。 在内存分配和释放时， Small bins 的处理速度优于 large bins（但是低于 fast bins）。</p><p>Number of bins – 62</p><p>Bins 数目 – 62</p><p>每个 small bin 都包含一条环形双向链表（binlist）。之所以使用双向链表是因为内存块需要在链表中间解引用。在链表头添加内存块，在链表尾端删除（FIFO）。</p><p>Chunk Size – 8 bytes apart</p><p>内存块大小 —— 以 8字节划分</p><p>Small bin 也包含一条内存块链表 binlist， 链表中每个内存块按照 8 字节对齐。例如：第一个 small bin（bin 2)，它的链表中内存块的大小为 16字节，第二个 small bin （bin 3），它的链表中内存块大小为 24 字节，以此类推。 每个 small bin 中的内存块大小一致，因此无需排序。</p><p>内存块合并 ——相邻的两块内存块如果都是空闲的话会合并为一整块。合并会消除内存碎片，但是很显然会降低内存释放的效率。</p><p>Malloc(small chunk) —— 起初，所有的 small bins 都是 NULL，因此即使用户请求的是 small chunk，也不会走到 small bin 的代码，而是 unsorted bin 提供服务。 同样，第一次调用 malloc 时， 会初始化 malloc_state 结构中的 small bin 和large bin (bins)。比如，bins 可以指向自身，表明它是空的。 之后当 small bin 不为空， malloc 会从 binlist 中移除最后一块内存块并返回给用户。</p><p>Free(small chunk)—— 释放 small chunk 时，首先检查他的前后内存块是否为空闲，如果空闲的话，需要合并内存块。例如，将内存块从对应的链表中解引用，将合并后的大内存块添加到 unsorted bin 链表头。</p><h2>Large Bin:</h2><p>大于或等于 512b 的内存块就是 large chunk。保存这类内存块的容器称为 large bins。在内存分配和释放时， large bins 效率低于 small bins。</p><p>Number of bins – 63</p><p>每个 large bin 都包含一条环形双向链表（也称为 binlist）。因为 large bin 中内存块可能在任何位置添加删除。</p><p>在这 63 个 bin 中：</p><p>其中有 32 个 bins，它们所包含的环形双向链表 binlist，其中每个内存块按照 64 字节划分。例如，第一个 large bin （bin 65）包含一条 binlist，它的内存块大小为 512b~568b，第二个 large bin（ bin 66），它的链表中中每个内存块的大小为 576b~632b，以此类推。</p><p>有16个 bins ，它的 binlist 中内存块大小为 512 字节。</p><p>有 8 个 bins ，它们的 binlist 中内存块大小为 4096 字节</p><p>有 4 个 bins 的 binlist 大小为 32768 字节</p><p>有两个 bins ，它的 binlist 中内存块大小为 262144 字节</p><p>唯一有一个 bin ，它的内存块就是剩下的所有可用内存。</p><p>与 small bin 不同的是， large bin 中的内存块大小并不是完全一样的。降序存放，最大的内存块保存在 binlist 的 front 端，最小的保存在 rear 端。</p><p>合并 —— 两个空闲内存块不可相邻，会合并为单个空闲快。</p><p>Large bins 初始化为空，因此即使用户请求 large chunk，也不会走到 large bin 的代码，而是走到下一个 largest bin代码【这部分代码很多，按顺序排下来，在 _int_malloc 函数中，先转化用户请求size，根据size 判断是哪一种请求，接下来依次为 fast bin、small bin、 large bin、以及更大的 large request 等等】。</p><p>同样，在我们第一次调用 malloc 期间， malloc_state 结构中的 small bin 和 large bin 结构也会被初始化，比如指针指向它们自身以表明为空。</p><p>在这之后的请求，如果 large bin 不为空，且最大内存块大于用户请求的 size，这时候会从尾端到前端遍历 binlist，直到找到一块大小等于或者约等于用户请求的内存块。一旦找到，这个内存块会被分割为两块：</p><p>其一：用户块（用户请求的实际大小）——返回给用户</p><p>其二：剩余块（找到的内存块减去用户请求大小后剩下的部分）——添加到 unsorted bin。</p><p>如果最大内存块小于用户请求大小，malloc 会尝试下一个 largest bin（非空的）。下一块 largest bin 代码会扫描 binmaps，去寻找下一个非空的 largest bin，一旦找到 bin，就会检索这个 bin 中 binlist 的内存块，分割内存块并返回给用户。如果找不到的话，就会接着使用 top chunk，力争解决用户需求。</p><p>Free(large chunk) —— 这个释放的过程类似于 free(small chunk).</p><h2>Top Chunk:</h2><p>Arena 中最顶部的内存块就是 top chunk。它不属于任何 bin。如果所有的 bins 中都没有空闲内存块，就会使用 top chunk 来服务用户。如果 top chunk 大于用户实际请求的 size，就会被分割为两块：</p><p>用户块（大小等于用户实际请求）</p><p>剩余块（剩下的那部分）</p><p>这样，剩余块就是新的 top chunk。如果 top chunk 小于用户请求块大小，sbrk (main arena)或者 mmap (thread arena)系统调用就会用来扩展 top chunk。</p><h2>Last Remainder Chunk:</h2><p>最近一次分割产生的剩余块就是 last reminder chunk。它可以用来提高访问局部性，比如，连续的小内存块 malloc 请求可能会使得这些分配的内存块离的很近。</p><p>但是 arena 中可用的内存块如此之多，哪块有资格可以成为 last reminder chunk 呢？</p><p>当用户请求小内存块时，如果无法从 small bin 和 unsorted bin 获取帮助，就会遍历 binmaps 找到下一个非空 largest bin。就像之前说的，找到了非空 bin 后，取得的内存块被一分为二，用户块返回给用户，剩余块到了 unsorted bin。这个剩余块就是新的 last reminder chunk。</p><h3>如何实现访问局部性？</h3><p>假设用户连续多次请求分配小内存块，而 unsorted bin 中只剩下 last reminder chunk，这个 chunk 会被一分为二。还是那样分割，返回一块给用户，留下剩余块塞给 unsorted bin。下一个请求又是这样，一次次操作下来，内存分配都在最开始的 last reminder chunk 上进行，最终使得分配出去的内存块都在连续区域中。</p><div class=\"wp_rp_wrap  wp_rp_plain\" ><div class=\"wp_rp_content\"><h3 class=\"related_post_title\">相关文章</h3><ul class=\"related_post wp_rp\" style=\"visibility: visible\"><li ><a href=\"http://blog.jobbole.com/88673/\" class=\"wp_rp_title\">如何设计一个内存分配器？</a></li><li ><a href=\"http://blog.jobbole.com/98633/\" class=\"wp_rp_title\">StackOverflow 这么大，它的架构是怎么样的？</a></li><li ><a href=\"http://blog.jobbole.com/100081/\" class=\"wp_rp_title\">MySQL 读写分离介绍及搭建</a></li><li ><a href=\"http://blog.jobbole.com/98769/\" class=\"wp_rp_title\">AlphaGo相关技术：蒙特卡罗方法简介</a></li><li ><a href=\"http://blog.jobbole.com/99654/\" class=\"wp_rp_title\">蜕变成蝶：Linux设备驱动之字符设备驱动</a></li><li ><a href=\"http://blog.jobbole.com/53059/\" class=\"wp_rp_title\">objc系列译文（2.4）：线程安全类的设计</a></li><li ><a href=\"http://blog.jobbole.com/87400/\" class=\"wp_rp_title\">Go并发编程基础</a></li><li ><a href=\"http://blog.jobbole.com/101924/\" class=\"wp_rp_title\">C#多线程之旅（2）：创建和开始线程</a></li><li ><a href=\"http://blog.jobbole.com/103800/\" class=\"wp_rp_title\">MySQL 最佳实践：空间优化</a></li><li ><a href=\"http://blog.jobbole.com/100349/\" class=\"wp_rp_title\">如果有人问你数据库的原理，叫他看这篇文章</a></li></ul></div></div><p><a href=\"http://blog.jobbole.com/103993/\">理解 glibc 内存分配器的机制与实现</a>，首发于<a href=\"http://blog.jobbole.com\">文章 - 伯乐在线</a>。</p>" "http://blog.jobbole.com/103993/" (22433 19150) old 4 nil nil ((title nil "理解 glibc 内存分配器的机制与实现") (link nil "http://blog.jobbole.com/103993/") (comments nil "http://blog.jobbole.com/103993/#respond") (pubDate nil "Wed, 03 Aug 2016 01:37:18 +0000") (dc:creator nil "巽离") (category nil "IT技术") (category nil "glibc") (category nil "内存分配器") (guid ((isPermaLink . "false")) "http://blog.jobbole.com/?p=103993") (description nil "<p>一直以来，我都沉迷于堆内存的一切。脑子里一直充斥着这些问题：怎样从内核获取堆内存？内存管理的效率如何?是什么在管理它？内核？库函数？还是应用程序？堆内存可以扩展吗？直到最近我才有时间思考并理解这些问题。所以想在本文和大家分享我的思考过程</p><p><a href=\"http://blog.jobbole.com/103993/\">理解 glibc 内存分配器的机制与实现</a>，首发于<a href=\"http://blog.jobbole.com\">文章 - 伯乐在线</a>。</p>") (content:encoded nil "<p>一直以来，我都沉迷于堆内存的一切。脑子里一直充斥着这些问题：</p><ul><li>怎样从内核获取堆内存？</li><li>内存管理的效率如何?</li><li>是什么在管理它？内核？库函数？还是应用程序？</li><li>堆内存可以扩展吗？</li></ul><p>直到最近我才有时间思考并理解这些问题。所以想在本文和大家分享我的思考过程。除了我们即将讨论的内存分配器，还有如下几种的存在：</p><ul><li>dlmalloc – General purpose allocator</li><li>ptmalloc2 – glibc</li><li>jemalloc – FreeBSD and Firefox</li><li>tcmalloc – Google</li><li>libumem – Solaris &#8230;</li></ul><p>每个内存分配器都说自己可以快速分配内存、可扩展而且高效。但并不是所有的分配器都适用于我们的应用程序。像那些对内存异常渴求的应用程序来说，它的性能很大程度上依赖于内存分配器的性能。在这篇文章中，我打算只介绍 ‘glibc malloc’内存分配器。希望未来有机会可以介绍其他几种。为了帮助大家深入理解 ‘glibc malloc’，本文会贴一些源代码。现在，准备好了吗？开始 glibc malloc 吧！</p><h1>历史</h1><p>ptmalloc2 是 dlmalloc 的分支。于 2006 年发布，在这条分支上，添加了对线程的支持。在正式版发布后， ptmalloc2 被集成到 glibc 的源代码中。在这之后，对这个内存分配器的修改直接在 glibc malloc 的源码中进行。今后，ptmalloc2 和 glibc的 malloc 之间可能差异会越来越大。</p><p>系统调用：从本文的分析中，我们会发现 malloc 内部要么调用 brk，要么调用 mmap。</p><p>线程化：</p><p>在早期的 linux 中，将 dlmalloc 作为默认的内存分配器。不过由于 ptmalloc2 对线程的支持，它便取代了 dlmalloc 的地位。线程化可以提高内存分配器的性能从而提高应用程序的性能。在 dlmalloc 中，如果两个线程同时调用 malloc，由于数据结构 freelist 在所有线程间共享, 只有一个线程可以进入临界区。这样导致了在多线程的应用程序中，malloc 会很浪费时间，从而降低应用程序的性能。而在 ptmalloc2 中，当两个线程同时调用 malloc 就不会出现这种窘境，因为每个线程都有自己独立的 heap 段，管理 heap 的freelist 结构也是相互独立的，从而不管多少线程同时请求内存，都会立即分配完成。这种每个线程都有独立 heap、独立 freelist 的行为称为 “per thread arena”。</p><h1>例子</h1><p></p><pre class=\"crayon-plain-tag\">/* Per thread arena example. */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;pthread.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;

void* threadFunc(void* arg) {
        printf(\"Before malloc in thread 1n\");
        getchar();
        char* addr = (char*) malloc(1000);
        printf(\"After malloc and before free in thread 1n\");
        getchar();
        free(addr);
        printf(\"After free in thread 1n\");
        getchar();
}

int main() {
        pthread_t t1;
        void* s;
        int ret;
        char* addr;

        printf(\"Welcome to per thread arena example::%dn\",getpid());
        printf(\"Before malloc in main threadn\");
        getchar();
        addr = (char*) malloc(1000);
        printf(\"After malloc and before free in main threadn\");
        getchar();
        free(addr);
        printf(\"After free in main threadn\");
        getchar();
        ret = pthread_create(&amp;t1, NULL, threadFunc, NULL);
        if(ret)
        {
                printf(\"Thread creation errorn\");
                return -1;
        }
        ret = pthread_join(t1, &amp;s);
        if(ret)
        {
                printf(\"Thread join errorn\");
                return -1;
        }
        return 0;
}</pre><p>输出分析：</p><p>在 main 线程 malloc 之前：从下面的输出我们可以看出，由于此时还没有创建线程 thread1，从而没有 heap 段，也没有线程栈。</p><pre class=\"crayon-plain-tag\">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ./mthread 
Welcome to per thread arena example::6501
Before malloc in main thread
...
sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ cat /proc/6501/maps
08048000-08049000 r-xp 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread
08049000-0804a000 r--p 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread
0804a000-0804b000 rw-p 00001000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread
b7e05000-b7e07000 rw-p 00000000 00:00 0 
...
sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$</pre><p>在 main 线程 malloc 后：从下面输出能看出， heap segment已经创建了，并且就处于 data segment(0804b000-0806c000)之上。这就意味着： heap 内存是通过增加程序中断点(program break location)来创建的(例如，系统调用 brk)。同时请注意，尽管程序中只申请 1000字节的内存，创建的 heap 内存却是 132KB。这一段连续的 heap 内存被称为 “arena”。由于它是在 main 线程中创建，所以也被称为 “main arena”。在这之后的内存请求都会使用这一块 “arena”，直到消耗完这片空间。当 arena 耗完，可以通过增加程序中断点的方式来增加 arena(在增加之后，top chunk 的大小也会随之调整)。与之类似，如果 top chunk 中有过多的空闲空间， arena 的区域也会收缩。</p><p>注意： 所谓 “top chunk” 指的是 “arena” 最顶部的内存块。想要了解更多知识，请看下面 ”Top Chunk” 的内容。</p><pre class=\"crayon-plain-tag\">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ./mthread 
Welcome to per thread arena example::6501
Before malloc in main thread
After malloc and before free in main thread
...
sploitfun@sploitfun-VirtualBox:~/lsploits/hof/ptmalloc.ppt/mthread$ cat /proc/6501/maps
08048000-08049000 r-xp 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread
08049000-0804a000 r--p 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread
0804a000-0804b000 rw-p 00001000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread
0804b000-0806c000 rw-p 00000000 00:00 0          [heap]
b7e05000-b7e07000 rw-p 00000000 00:00 0 
...
sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$</pre><p>Main 线程 free 内存后：从下面输出可以看出，当我们在程序中释放已分配的内存后，实际上这块内存并没有立即还给操作系统。这块已分配的内存(大小为 1000 字节)仅仅是释放给了 ‘glibc malloc’ 的库，这个库将这块空闲出来的内存块添加到 “main arena bin” 中(在 glibc malloc 中，freelist 结构被认为是一个个容器 bins)。在这之后，一旦用户请求内存， ‘glibc malloc’ 不再从 kernel 请求 heap 内存，而是从这些 bin 中找到空闲的内存块分配出去。只有当找不到空闲的内存块时，它才会从 kernel 请求新的内存。</p><pre class=\"crayon-plain-tag\">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ./mthread 
Welcome to per thread arena example::6501
Before malloc in main thread
After malloc and before free in main thread
After free in main thread
...
sploitfun@sploitfun-VirtualBox:~/lsploits/hof/ptmalloc.ppt/mthread$ cat /proc/6501/maps
08048000-08049000 r-xp 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread
08049000-0804a000 r--p 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread
0804a000-0804b000 rw-p 00001000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread
0804b000-0806c000 rw-p 00000000 00:00 0          [heap]
b7e05000-b7e07000 rw-p 00000000 00:00 0</pre><p>Thread1 线程 malloc 之前：从下面的输出可以看出，此时没有thread1 的 heap segment，但是线程栈已经创建了。</p><pre class=\"crayon-plain-tag\">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ./mthread 
Welcome to per thread arena example::6501
Before malloc in main thread
After malloc and before free in main thread
After free in main thread
Before malloc in thread 1
...
sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ cat /proc/6501/maps
08048000-08049000 r-xp 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread
08049000-0804a000 r--p 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread
0804a000-0804b000 rw-p 00001000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread
0804b000-0806c000 rw-p 00000000 00:00 0          [heap]
b7604000-b7605000 ---p 00000000 00:00 0 
b7605000-b7e07000 rw-p 00000000 00:00 0          [stack:6594]
...
sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$</pre><p>Thread1 线程 malloc 之后：从下面输出可以看出，thread1的 heap segment 也已经创建了。并且就处于内存映射段(b7500000-b7521000 大小为 132 Kb)中，由此我们可以得出结论：不同于 main 线程，这里的 heap 内存是通过系统调用 mmap 来创建的。同样，即便用户只请求了 1000 字节，实际映射到进程地址空间的大小为 1M。在这 1M 内存中，只有 132K 的内存被赋予了读写权限，作为该线程的 heap 内存。这一块连续的内存块被称为 “thread arena”。</p><p>注意：如果用户请求内存大小超过 128K（比如 malloc(132*1024)），并且单个 arena 无法满足用户需求的情况下，不管这个内存请求来自 main arena 还是 thread arena，都会采用 mmap 的方式来分配内存。</p><pre class=\"crayon-plain-tag\">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ./mthread 
Welcome to per thread arena example::6501
Before malloc in main thread
After malloc and before free in main thread
After free in main thread
Before malloc in thread 1
After malloc and before free in thread 1
...
sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ cat /proc/6501/maps
08048000-08049000 r-xp 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread
08049000-0804a000 r--p 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread
0804a000-0804b000 rw-p 00001000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread
0804b000-0806c000 rw-p 00000000 00:00 0          [heap]
b7500000-b7521000 rw-p 00000000 00:00 0 
b7521000-b7600000 ---p 00000000 00:00 0 
b7604000-b7605000 ---p 00000000 00:00 0 
b7605000-b7e07000 rw-p 00000000 00:00 0          [stack:6594]
...
sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$</pre><p>Thread1 中释放内存之后： 同样，这块内存实际上也并没有还给操作系统。而是被转交给了’glibc malloc’，从而被添加到 thread arena bin 的空闲块中。</p><pre class=\"crayon-plain-tag\">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ./mthread 
Welcome to per thread arena example::6501
Before malloc in main thread
After malloc and before free in main thread
After free in main thread
Before malloc in thread 1
After malloc and before free in thread 1
After free in thread 1
...
sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ cat /proc/6501/maps
08048000-08049000 r-xp 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread
08049000-0804a000 r--p 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread
0804a000-0804b000 rw-p 00001000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread
0804b000-0806c000 rw-p 00000000 00:00 0          [heap]
b7500000-b7521000 rw-p 00000000 00:00 0 
b7521000-b7600000 ---p 00000000 00:00 0 
b7604000-b7605000 ---p 00000000 00:00 0 
b7605000-b7e07000 rw-p 00000000 00:00 0          [stack:6594]
...
sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$</pre><p>Arena 的数量： 从上面几个例子中，我们可以看到主线程有 main arena，线程1 有它自己的 thread arena。那么问题来了，我们是否可以不管线程个数多少，都将线程与 arena 的个数做一一映射呢？答案是 NO！某些应用程序可能有很多线程（大于 CPU 个数），在这种情况下，如果我们给每个线程配一个 arena 简直是自作孽，而且很没意义。所以呢，我们应用程序的 arena 数目受制于系统中 CPU 个数。</p><p>&nbsp;</p><p>对 32 位系统:</p><p>arena 个数 = 2 <em> 核心个</em></p><p><em>对</em><em>64 位系统: arena 个数 = 8 </em> 核心个数</p><p>例如： 假设有个多线程程序（4 个线程 ———— 主线程 + 3 个用户线程） 跑在 32 位的单核系统上，线程数大于 2 乘以核心个数（2*1 = 2）.碰到这种情况， glibc malloc 会保证所有可用的线程间共享多个 arena。但是这种共享是怎么实现的呢？</p><p>在主线程中，当我们第一次调用 malloc 函数会创建 main arena，这是毋庸置疑的。</p><p>在线程1、线程2 中第一次调用 malloc 函数后，会分别给他俩创建各自的 arena。直到线程和 arena 达到了一对一映射。</p><p>在线程3中，第一次调用 malloc 函数，这时候会计算是否到了 arena 最大数。在这个例子中已经达到限额了，因此会尝试复用其他已存在的 arena（主线程或线程1 或线程2的arena）。</p><p>复用： 遍历所有可用的 arena，并尝试给 arena 枷锁。</p><p>如果成功枷锁（假设 main rena 被锁住），将这个 arena 返回给用户。</p><p>&nbsp;</p><p>如果没有找到空闲的 arena，那么就会堵塞在当前 arena 上。 当线程 3 第二次调用 malloc，malloc 会尝试使用可访问 arena（main arena）。如果 main arena 空闲，直接使用。否则线程3 会被堵塞，直到 main arena 空闲。这时候 main arena 就在主线程和线程 3 之间共享啦！</p><p>下面三个主要数据结构可以在 ‘glibc malloc’ 源码中找到：</p><p>Heap_info &#8211; Heap Header &#8211; 每个线程 arena 都可以有多个heap 段。每个 heap 段都有自己的 header。为什么需要多个 heap 段呢？一开始的时候，每个线程都只有一个 heap 段的，但是渐渐的，堆空间用光光了，就会调用 mmap 来获取新的heap 段（非连续区域）。</p><p>Mallac_state &#8211; Arena Header &#8211; 每个线程 arena 可以有多个堆，但是，所有这些堆只能有一个 arena header。Arena header 结构中包含 bin、top chunk、 last reminder chunk 等。</p><p>mallc_chunk &#8211; Chunk Header &#8211; 由于用户的内存请求，堆会被分割成许多块（chunk）。每个这样的块有着自己的 chunk header。</p><p>注意： Main arena 没有多个 heap 段，也因此没有 heap_info 结构。当 main arena 中堆空间耗尽了，就会调用 sbrk 来扩展堆空间（连续区域），直到heap 段顶端达到了内存映射段。不同于线程 arena，main arena 的 arena header 结构不属于sbrk 的heap 段。它是一个全局变量， 因此我们可以在 libc.so 的数据段中看到它的身影。</p><p>下图很形象的展示了 main arena 和线程 arena 的结构（单个 heap 段）：</p><p><img src=\"http://ww1.sinaimg.cn/mw690/6941baebjw1f6e1ad899xj20qo0k0jud.jpg\" /></p><p>下图展示了线程 arena 的结构（多个 heap 段）：</p><p><img src=\"http://ww4.sinaimg.cn/mw690/6941baebgw1f6e15vnm9wj20qo0k0q5p.jpg\" /></p><p>&nbsp;</p><h1>Chunk</h1><p>&nbsp;</p><p>heap 段中的块可以是以下几种类型：</p><p>已分配的内存块</p><p>空闲内存块</p><p>顶层块</p><p>最终提示块</p><h2>Allocated chunk:</h2><p><img src=\"http://ww4.sinaimg.cn/mw690/6941baebgw1f6e15uwdftj20qq0ixjt3.jpg\" /></p><p>Prev_size: 如果前一个内存块是空闲的，这个字段保存前一个内存块的大小。否则说明前一个内存块已经分配出去了，这个字段保存前一个内存块的用户数据。</p><p>Size: 这个字段保存已分配内存块的大小。最后三个位包含标志信息。</p><p>&nbsp;</p><p>PREV_USE (P) &#8211; 前块内存已分配</p><p>IS_MAPPED (M) &#8211; 内存块通过 mmap 申请</p><p>NON_MAIN_ARENA (N) &#8211; 内存块属于线程 arena</p><p>NOTE:</p><p>Malloc_chunk 的其他字段（例如 fd, bk）不存在于已分配内存块。因此这种内存块的用户数据就保存在这些字段中。</p><p>为了存储 malloc_chunk 结构，还有出于内存对齐的目的，我们需要额外的空间，因此将用户请求的内存大小转化为可用大小（内部表示形式）。转化方式为：可用大小的后三位不置位，用于存储标志信息。</p><h2>Free Chunk:</h2><p><img src=\"http://ww1.sinaimg.cn/mw690/6941baebgw1f6e15ucoyej20q40ikwgc.jpg\" /></p><p>Prev_size : 要知道两块空闲内存块不可能相邻。一旦两个内存块都空闲，它们就会被整合成一整个空闲内存块。也就是说，我们这块空闲内存块的前一个内存块肯定是已分配的，因此， prev_size 字段保存的是前一个内存块的用户数据。</p><p>Size: 这个字段保存当前空闲内存块的大小。</p><p>fd: 前向指针 &#8211; 指向同一容器中的下一块内存块（注意是容器，这里并不是物理内存上的下一个 chunk）。</p><p>Bk: 后向指针 &#8211; 指向同一容器中的前一个内存块（同上）。</p><h1>Bins:</h1><p>容器（bins）： 容器指的是空闲链表结构 freelist。用于管理多个空闲内存块。根据块大小的不同，容器可以分为：</p><p>用于保存这些容器的数据结构有：</p><p>fastbinsY ： 这个数组用于保存 fast bins。</p><p>Bins ： 这个数组用于后三种容器。一共有 126 个容器，划分为三组：</p><p>Bin 1 – Unsorted bin</p><p>Bin 2 to Bin 63 – Small bin</p><p>Bin 64 to Bin 126 – Large bin</p><p>Fast Bin：</p><p>大小为 16～80字节的内存块称为 fast chunk。保存这些 fast chunk 的容器就是 fast bins。在所有这些容器中， fast bins 操作内存效率高。</p><h3>Number of bins – 10</h3><p>容器 bin 的个数 &#8211; 10 每个 fast bin 都包含一个空闲内存块的单链表。之所以采用单链表，是因为 fast bins 中内存块的添加、删除操作都在列表的头尾端进行，不涉及中间段的移除操作 —— 后进先出。</p><h3>Chunk size – 8 bytes apart</h3><p>Chunk 大小 &#8211; 以 8 字节划分 Fast bins 包含一条链表 binlist，以 8 字节对齐。例如，第一个 fast bin（索引为0）包含一条链表，它的内存块大小为 16字节，第二个 fast bin 中链表上的内存块大小为 24 字节，以此类推。</p><p>每个 fast bin 中的内存块大小是一致的。</p><p>在 malloc 初始化期间， fast bin 最大值设置为 64 字节（不是80字节）。因此，默认情况下16~64 字节的内存块都被视为 fast chunks。</p><p>不存在合并 ——在 fast bins 中允许相邻两块都是空闲块，不会被自动合并。虽然不合并会导致内存碎片，但是它大大加速了 free 操作！！</p><p>Malloc(fast chunk) &#8211; 一开始 fast bin 最大值和fast bin 都是空的，所以不管用户请求的块大小怎样，都不会走到 fast bin 的代码，而是 small bin code。</p><p>之后，由于内存释放等原因，fast bin 不为空，通过fast bin 索引来找到对应的 binlist。</p><p>最后，binlist 中的第一块内存块从链表中移除并返回给用户。</p><p>根据 fast bin 索引值找到对应的 binlist</p><p>这块待释放的内存块添加到上面 binlist 的链表头。</p><p><img src=\"http://ww2.sinaimg.cn/mw690/6941baebgw1f6e15tlvvij20qo0k00v2.jpg\" /></p><h2>Unsorted Bin:</h2><p>当释放small chunk 或者 large chunk时，不会将它们添加到 small bin 或者 large bin 中，而是添加到 unsorted bin。这种解决方案让‘glibc mallc’多了一种重复利用空闲内存块的方式。因为不需要花时间去各自的容器中去找，从而也提高了分配和释放内存的效率。</p><p>Number of bins – 1</p><p>Unsorted bin 中包含空闲内存块的环形双向链表。</p><p>内存块大小 —— 无大小限制，任意大小的内存块都可以。</p><p><img src=\"http://ww2.sinaimg.cn/mw690/6941baebgw1f6e15sxpqkj20xs0o1af1.jpg\" /></p><h2>Small Bin:</h2><p>小于 512 字节的内存块称为 small chunk。容纳这类 small chunk 的称为 small bins。 在内存分配和释放时， Small bins 的处理速度优于 large bins（但是低于 fast bins）。</p><p>Number of bins – 62</p><p>Bins 数目 &#8211; 62</p><p>每个 small bin 都包含一条环形双向链表（binlist）。之所以使用双向链表是因为内存块需要在链表中间解引用。在链表头添加内存块，在链表尾端删除（FIFO）。</p><p>Chunk Size – 8 bytes apart</p><p>内存块大小 —— 以 8字节划分</p><p>Small bin 也包含一条内存块链表 binlist， 链表中每个内存块按照 8 字节对齐。例如：第一个 small bin（bin 2)，它的链表中内存块的大小为 16字节，第二个 small bin （bin 3），它的链表中内存块大小为 24 字节，以此类推。 每个 small bin 中的内存块大小一致，因此无需排序。</p><p>内存块合并 ——相邻的两块内存块如果都是空闲的话会合并为一整块。合并会消除内存碎片，但是很显然会降低内存释放的效率。</p><p>Malloc(small chunk) —— 起初，所有的 small bins 都是 NULL，因此即使用户请求的是 small chunk，也不会走到 small bin 的代码，而是 unsorted bin 提供服务。 同样，第一次调用 malloc 时， 会初始化 malloc_state 结构中的 small bin 和large bin (bins)。比如，bins 可以指向自身，表明它是空的。 之后当 small bin 不为空， malloc 会从 binlist 中移除最后一块内存块并返回给用户。</p><p>Free(small chunk)—— 释放 small chunk 时，首先检查他的前后内存块是否为空闲，如果空闲的话，需要合并内存块。例如，将内存块从对应的链表中解引用，将合并后的大内存块添加到 unsorted bin 链表头。</p><h2>Large Bin:</h2><p>大于或等于 512b 的内存块就是 large chunk。保存这类内存块的容器称为 large bins。在内存分配和释放时， large bins 效率低于 small bins。</p><p>Number of bins – 63</p><p>每个 large bin 都包含一条环形双向链表（也称为 binlist）。因为 large bin 中内存块可能在任何位置添加删除。</p><p>在这 63 个 bin 中：</p><p>其中有 32 个 bins，它们所包含的环形双向链表 binlist，其中每个内存块按照 64 字节划分。例如，第一个 large bin （bin 65）包含一条 binlist，它的内存块大小为 512b~568b，第二个 large bin（ bin 66），它的链表中中每个内存块的大小为 576b~632b，以此类推。</p><p>有16个 bins ，它的 binlist 中内存块大小为 512 字节。</p><p>有 8 个 bins ，它们的 binlist 中内存块大小为 4096 字节</p><p>有 4 个 bins 的 binlist 大小为 32768 字节</p><p>有两个 bins ，它的 binlist 中内存块大小为 262144 字节</p><p>唯一有一个 bin ，它的内存块就是剩下的所有可用内存。</p><p>与 small bin 不同的是， large bin 中的内存块大小并不是完全一样的。降序存放，最大的内存块保存在 binlist 的 front 端，最小的保存在 rear 端。</p><p>合并 —— 两个空闲内存块不可相邻，会合并为单个空闲快。</p><p>Large bins 初始化为空，因此即使用户请求 large chunk，也不会走到 large bin 的代码，而是走到下一个 largest bin代码【这部分代码很多，按顺序排下来，在 _int_malloc 函数中，先转化用户请求size，根据size 判断是哪一种请求，接下来依次为 fast bin、small bin、 large bin、以及更大的 large request 等等】。</p><p>同样，在我们第一次调用 malloc 期间， malloc_state 结构中的 small bin 和 large bin 结构也会被初始化，比如指针指向它们自身以表明为空。</p><p>在这之后的请求，如果 large bin 不为空，且最大内存块大于用户请求的 size，这时候会从尾端到前端遍历 binlist，直到找到一块大小等于或者约等于用户请求的内存块。一旦找到，这个内存块会被分割为两块：</p><p>其一：用户块（用户请求的实际大小）——返回给用户</p><p>其二：剩余块（找到的内存块减去用户请求大小后剩下的部分）——添加到 unsorted bin。</p><p>如果最大内存块小于用户请求大小，malloc 会尝试下一个 largest bin（非空的）。下一块 largest bin 代码会扫描 binmaps，去寻找下一个非空的 largest bin，一旦找到 bin，就会检索这个 bin 中 binlist 的内存块，分割内存块并返回给用户。如果找不到的话，就会接着使用 top chunk，力争解决用户需求。</p><p>Free(large chunk) —— 这个释放的过程类似于 free(small chunk).</p><h2>Top Chunk:</h2><p>Arena 中最顶部的内存块就是 top chunk。它不属于任何 bin。如果所有的 bins 中都没有空闲内存块，就会使用 top chunk 来服务用户。如果 top chunk 大于用户实际请求的 size，就会被分割为两块：</p><p>用户块（大小等于用户实际请求）</p><p>剩余块（剩下的那部分）</p><p>这样，剩余块就是新的 top chunk。如果 top chunk 小于用户请求块大小，sbrk (main arena)或者 mmap (thread arena)系统调用就会用来扩展 top chunk。</p><h2>Last Remainder Chunk:</h2><p>最近一次分割产生的剩余块就是 last reminder chunk。它可以用来提高访问局部性，比如，连续的小内存块 malloc 请求可能会使得这些分配的内存块离的很近。</p><p>但是 arena 中可用的内存块如此之多，哪块有资格可以成为 last reminder chunk 呢？</p><p>当用户请求小内存块时，如果无法从 small bin 和 unsorted bin 获取帮助，就会遍历 binmaps 找到下一个非空 largest bin。就像之前说的，找到了非空 bin 后，取得的内存块被一分为二，用户块返回给用户，剩余块到了 unsorted bin。这个剩余块就是新的 last reminder chunk。</p><h3>如何实现访问局部性？</h3><p>假设用户连续多次请求分配小内存块，而 unsorted bin 中只剩下 last reminder chunk，这个 chunk 会被一分为二。还是那样分割，返回一块给用户，留下剩余块塞给 unsorted bin。下一个请求又是这样，一次次操作下来，内存分配都在最开始的 last reminder chunk 上进行，最终使得分配出去的内存块都在连续区域中。</p><div class=\"wp_rp_wrap  wp_rp_plain\" ><div class=\"wp_rp_content\"><h3 class=\"related_post_title\">相关文章</h3><ul class=\"related_post wp_rp\" style=\"visibility: visible\"><li ><a href=\"http://blog.jobbole.com/88673/\" class=\"wp_rp_title\">如何设计一个内存分配器？</a></li><li ><a href=\"http://blog.jobbole.com/98633/\" class=\"wp_rp_title\">StackOverflow 这么大，它的架构是怎么样的？</a></li><li ><a href=\"http://blog.jobbole.com/100081/\" class=\"wp_rp_title\">MySQL 读写分离介绍及搭建</a></li><li ><a href=\"http://blog.jobbole.com/98769/\" class=\"wp_rp_title\">AlphaGo相关技术：蒙特卡罗方法简介</a></li><li ><a href=\"http://blog.jobbole.com/99654/\" class=\"wp_rp_title\">蜕变成蝶：Linux设备驱动之字符设备驱动</a></li><li ><a href=\"http://blog.jobbole.com/53059/\" class=\"wp_rp_title\">objc系列译文（2.4）：线程安全类的设计</a></li><li ><a href=\"http://blog.jobbole.com/87400/\" class=\"wp_rp_title\">Go并发编程基础</a></li><li ><a href=\"http://blog.jobbole.com/101924/\" class=\"wp_rp_title\">C#多线程之旅（2）：创建和开始线程</a></li><li ><a href=\"http://blog.jobbole.com/103800/\" class=\"wp_rp_title\">MySQL 最佳实践：空间优化</a></li><li ><a href=\"http://blog.jobbole.com/100349/\" class=\"wp_rp_title\">如果有人问你数据库的原理，叫他看这篇文章</a></li></ul></div></div><p><a href=\"http://blog.jobbole.com/103993/\">理解 glibc 内存分配器的机制与实现</a>，首发于<a href=\"http://blog.jobbole.com\">文章 - 伯乐在线</a>。</p>") (wfw:commentRss nil "http://blog.jobbole.com/103993/feed/") (slash:comments nil "0"))) ("开发者MAC电脑里的十八般兵器" "<p>古人常以刀、枪、剑、戟、斧、钺、铲、叉、鞭、锏、锤、戈、镋、棍、槊、棒、矛、钯十八种兵器，样样精通，来形容一个人的武学技能get状态。在开发者的世界里，熟练掌握各种辅助工具，可以达到事半功倍，快速提高工作效率的效果。闲话不扯了，来看看究竟是什么。</p><h1>道场</h1><p>习武学道讲经论法总有个场所，这样容易把有意向来学习的人聚集起来，而且有助于信息的传播，精力的集中，技能的修炼，经验的交流和水平高下的切磋。工具的运用也是在一个特定的开发环境里才能发挥出比较好的效果。<br />
我这里的开发环境(DOJO)是苹果公司Apple Inc.()2014年出的一款Mac Pro，具体配置如下：</p><blockquote><p>MacBook Pro（Retina 显示屏，15 英寸，2014 年中）</p><p>处理器 2.2 GHz Intel Core i7</p><p>内存 16 GB 1600 MHz DDR3</p><p>图形卡 Intel Iris Pro 1536 MB</p><p>操作系统 OS X EI Capitan</p></blockquote><p>这里描述的工具都是运行在这个硬件以及软件环境的，经过了2年多的开发经验／经历的靠谱验证，所以拿来分享给大家。</p><p>如果有朋友的研发环境和这里描述的不太一致，那么仅作参考吧，具体结合自己的情况。</p><p>为了方便检索，所以增加了工具分类。</p><p>开发第一步是做什么？学习文档？画流程图？还是直接写代码？恩，先从学习文档开始吧。</p><h1 id=\"section-1\">文档查看</h1><h3 id=\"dash\">Dash</h3><p>写代码的时候是不是有些API记不住，比如画椭圆该用哪个类？计算开平方用什么函数？怎么连接远程的mysql服务器检索数据？这个时候一般怎么办？问度娘？问谷歌？直接查看在线编程文档？</p><p>在国内问谷歌需要翻墙，那么涉及到另外工具的使用。查看在线文档，如果记不住入口网址怎么办？放收藏里啊，如果入口改变了呢？还是需要问搜索引擎啊！那么问题来了，度娘乱贴小广告咋办？用Dash吧，一个APP搜罗了这个世界上几乎所有的编程语言文档，而且更新速度快。</p><p>软件主页以及下载地址<a href=\"https://kapeli.com/dash\">https://kapeli.com/dash</a></p><h1 id=\"section-2\">流程图设计</h1><p>OmniGraffle 有很多人推荐，不过笔者觉得这个软件太贵了，所以推荐了两款免费的软件流程设计工具。</p><h3 id=\"xmind\">XMind</h3><p>主攻脑图（思维导图），流程图也支持，另外还有日程安排计划等额外的功能。</p><p>软件主页以及下载地址<a href=\"http://www.xmind.net/\">http://www.xmind.net/</a></p><h3 id=\"gliffy-diagrams\">Gliffy Diagrams</h3><p>并不是一个独立安装的APP，而是作为Chrome的插件，可以去Chrome的App Store下载安装，很轻量，运行速度快。</p><p>软件主页<a href=\"https://www.gliffy.com/\">https://www.gliffy.com/</a></p><h1 id=\"section-3\">文本编辑器</h1><p>不仅限于代码编辑，一款好的编辑器会让你的编辑工作充满愉悦。</p><h3 id=\"macvim\">MacVim</h3><p>为什么我一开始不推荐时下流行头牌Sublime呢？因为，我用vi/vim已经超过十年的时间了。当初在学校，vm/emacs二选一，我选择了更容易上手实践的vi，从此一直用它来查看／编译文本／代码。</p><p>软件主页以及下载地址<a href=\"http://macvim-dev.github.io/macvim/\">http://macvim-dev.github.io/macvim/</a></p><h3 id=\"macdown\">MacDown</h3><p>一般代码查看和编辑用Vi就够了，剩下其他的文档，恩，现在大多数文章／文档采用的<strong>MarkDown</strong>语法编写，所以用一款MarkDown编辑器就够了。比如本文的编写，我用的MacDown编辑器，文章语法采用MarkDown语法。既然是MarkDown编辑器，那么有人会提到用<strong>Mou</strong>，笔者也试用过一段时间，遇到了一些问题，比如语法支持和界面显示，后来改用MacDown，觉得各方面都支持的不错，所以一直使用。</p><p>软件主页以及下载地址<a href=\"http://macdown.uranusjr.com/\">http://macdown.uranusjr.com/</a></p><h3 id=\"sublime-text\">Sublime Text</h3><p>如果你不是一路走着linux从事开发的话，估计很难对Vi/Emacs熟悉。那么，像note++或者ultraedit这类第三方编辑器会是你比较不错的选择。相比于集成开发环境IDE的笨重，运行慢和耗内存，选择一个轻量级的编辑器是在平时比较频繁的非常规查看／编辑代码／文档时一个不错的选择。那么，以前那些用第三方编辑器的用户都去哪儿了？应该就是这个Sublime Text了吧。</p><p>软件主页以及下载地址<a href=\"http://www.sublimetext.com/\">http://www.sublimetext.com/</a></p><h1 id=\"section-4\">图片编辑器</h1><p>写文章撸代码，除了文字的处理外，还需要有美图的点缀和衬托。更多时候，图是吸引流量和眼球的一种重要手段。</p><h3 id=\"gimp\">GIMP</h3><p>为啥不用Adobe Photo Shop呢？太贵，太复杂。那么，好吧，这里笔者推荐用GIMP，PS该有的，它基本都有。</p><p>软件主页以及下载地址<a href=\"http://www.gimp.org/\">http://www.gimp.org/</a></p><h1 id=\"ide\">集成开发环境IDE</h1><p>集成开发环境一般是集编辑，编译，链接，调试，版本管理和打包发布于一体的大型开发软件。它的特点是功能丰富，上手快，易操作。缺点也显而易见，笨重，运行速度慢，需要更多的CPU，内存资源。</p><h3 id=\"eclipse\">Eclipse</h3><p>老牌万金油型集成开发环境，上手快，支持几乎所有语言，但是近几年使用人数在下滑，逐渐转向Android Studio和IntelliJ IDEA了。</p><p>软件主页以及下载地址<a href=\"http://www.eclipse.org\">http://www.eclipse.org</a></p><h3 id=\"android-studio\">Android Studio</h3><p>安卓程序猿专属开发环境。</p><p>软件主页以及下载地址<a href=\"https://developer.android.com/studio/index.html\">https://developer.android.com/studio/index.html</a></p><h3 id=\"intellij-idea\">IntelliJ IDEA</h3><p>Eclipse替代品，支持市面上大部分流行的开发语言和框架，上手快，界面更加人性化，现代集成开发环境的典范。</p><p>软件主页以及下载地址<a href=\"https://www.jetbrains.com\">https://www.jetbrains.com</a></p><h3 id=\"xcode\">Xcode</h3><p>苹果公司官方唯一指定的Object-C与Swift集成开发环境。</p><p>软件主页以及下载地址<a href=\"https://developer.apple.com/xcode/\">https://developer.apple.com/xcode/</a></p><h1 id=\"section-5\">分析调试类</h1><p>APP写好了，安装到设备，但是从网络拉取图片显示失败了，怎么破？APP打安装包后想看下包里面到底有些啥？遇到这样的问题，这个的工具可以帮助你解决上面遇到的问题。</p><h3 id=\"wireshark\">Wireshark</h3><p>老牌网络抓包利器，各种平台都可以玩耍。</p><p>软件主页以及下载地址<a href=\"https://www.wireshark.org/\">https://www.wireshark.org/</a></p><h3 id=\"tcpdump\">tcpdump</h3><p>这是一个命令行工具，可以看作是Wireshark的命令行版。</p><p>系统自带，无需额外安装。<a href=\"https://support.apple.com/en-hk/HT202013\">使用帮助</a></p><h3 id=\"charles\">Charles</h3><p>网络抓包利器加上代理功能，并支持自签名证书，所以可以用来在手机上抓取https的包。使用非常方便。付费软件，值得购买。</p><p>软件主页以及下载地址<a href=\"https://www.charlesproxy.com/\">https://www.charlesproxy.com/</a></p><h3 id=\"jd-gui\">JD-GUI</h3><p>Java的class文件反编译神器，可以从二进制class文件查看它的Java源代码。</p><p>软件主页以及下载地址<a href=\"http://jd.benow.ca/\">http://jd.benow.ca/</a></p><h3 id=\"jadx\">JADX</h3><p>JD-GUI的增强版，支持查看安卓apk/dex文件中反编译的Java源代码以及查看apk中其他文件的内容。</p><p>软件主页以及下载地址<a href=\"https://github.com/skylot/jadx\">https://github.com/skylot/jadx</a></p><h1 id=\"section-6\">版本管理</h1><p>频繁的修改，反悔，记录需要管理，所以版本管理是必须的。</p><h3 id=\"sourcetree\">SourceTree</h3><p>Atlassians出品的图形化版本管理工具，支持Git和Mercurial。</p><p>软件主页以及下载地址<a href=\"https://www.sourcetreeapp.com/\">https://www.sourcetreeapp.com/</a></p><h1 id=\"section-7\">文件共享</h1><p>从文件服务器(FTP, Samba etc.)下载资料或者上传文件到服务器上。</p><h3 id=\"filezilla\">FileZilla</h3><p>老牌Sourceforge开源文件传输软件。</p><p>软件主页以及下载地址<a href=\"https://sourceforge.net/projects/filezilla/\">https://sourceforge.net/projects/filezilla/</a></p><h1 id=\"section-8\">证书管理</h1><p>证书一般用于https加密，移动APP软件的安装文件签名。</p><h3 id=\"portecle\">Portecle</h3><p>图像化管理证书的工具。</p><p>软件主页以及下载地址<a href=\"https://sourceforge.net/projects/portecle/\">https://sourceforge.net/projects/portecle/</a></p><h1 id=\"section-9\">截屏</h1><p>截屏是强需求，没错。MAC下有截屏快捷键，只能截屏。一般用户截屏完毕后，不是马上发出去，而是做后期处理。</p><h3 id=\"snip\">snip</h3><p>截屏，编辑。</p><p>软件主页以及下载地址<a href=\"http://snip.qq.com/\">http://snip.qq.com/</a></p><h1 id=\"section-10\">数据库</h1><p>调试APP的时候，如果APP产生了数据，并且把数据保存在数据库（sqlite）中。如果想在开发主机上查看，可以用如下的工具。</p><h3 id=\"datum\">Datum</h3><p>查看sqlite数据库的内容。</p><p>软件主页以及下载地址<a href=\"http://www.datumapps.com/\">http://www.datumapps.com/</a></p><h1 id=\"section-11\">网络请求</h1><p>有时候需要自己构造一个http网络请求(GET/POST)，并查看输入输出的详细内容。简单的GET用浏览器可以代劳，复杂一点的需要浏览器安装插件支持。用如下的工具可以到达更好的效果。</p><h3 id=\"wget\">wget</h3><p>命令行工具。除了查看发送网络请求，查看结果外。另外一个用途是下载文件，特别是大文件，用浏览器下载经常会断线，而且断点续传做的不是太好。wget命令下载文件，支持断点续传，这个用起来不错。</p><h3 id=\"curl\">curl</h3><p>功能基本同wget，系统自带工具，无需安装。</p><h3 id=\"rest-client\">rest-client</h3><p>支持restful风格的网络请求构造，请求和结果相应。调试restful接口的好帮手。</p><p>软件主页以及下载地址<a href=\"https://github.com/wiztools/rest-client\">https://github.com/wiztools/rest-client</a></p><h1 id=\"section-12\">虚拟机&amp;模拟器</h1><p>我的电脑是MAC，可是招商银行的专业版没有MAC的客户端，肿么破？我想在MAC上看到安卓APP运行的情况，怎么办？安装一个虚拟机吧！</p><h3 id=\"virtualbox\">VirtualBox</h3><p>老牌虚拟机软件，支持市面上几乎所有流行的操作系统。</p><p>软件主页以及下载地址<a href=\"https://www.virtualbox.org/\">https://www.virtualbox.org/</a></p><h3>Genymotion</h3><p>安卓模拟器，运行安卓APP如同在手机上一样的速度。</p><p>软件主页以及下载地址<a href=\"https://www.genymotion.com/\">https://www.genymotion.com/</a></p><h1 id=\"mac\">MAC专用</h1><p>有些工具是MAC系统专用的，比如用来管理苹果设备(iPad, iPhone, iMac, Mac etc.)配置文件的工具。</p><h3 id=\"apple-configurator\">Apple Configurator</h3><p>上App Store自行搜索下载安装。</p><p><a href=\"http://help.apple.com/configurator/mac/2.2.1/\">使用帮助</a></p><h1 id=\"section-13\">服务端工具套件</h1><p>有时候需要本地调试一些服务端提供的服务，或者是网站后台。这个时候一个开发／调试／模拟环境的选择变的重要了。还是那句不忘初衷的话，好的工具让你事半功倍！</p><h3 id=\"bitnami\">Bitnami服务端套件</h3><p>本地调试web服务器，nginx, mysql, php-fpm, etc.</p><p>软件主页以及下载地址<a href=\"https://bitnami.com\">https://bitnami.com</a></p><h3 id=\"kitematic\">Kitematic</h3><p>Docker图形化管理工具。</p><p>软件主页以及下载地址<a href=\"https://kitematic.com/\">https://kitematic.com/</a></p><h1 id=\"section-14\">科学上网利器</h1><p>我要上谷歌搜索最新的Android开发文档和API，可是目前在国内用不了谷歌，怎么办？翻墙吧！</p><h3 id=\"shadowsocksx\">ShadowsocksX</h3><p>看标题，不多说，默默的下载，安装然后运行，配置，打开浏览器，访问谷歌，搜索Android就可以啦！</p><p>软件主页以及下载地址<a href=\"https://sourceforge.net/projects/shadowsocksgui/\">https://sourceforge.net/projects/shadowsocksgui/</a></p><h3 id=\"lantern\">Lantern</h3><p>如果上面那个不行，那么试试这个吧，不多说了。</p><p>软件主页以及下载地址<a href=\"https://github.com/getlantern/lantern\">https://github.com/getlantern/lantern</a></p><p></p><div class=\"wp_rp_wrap  wp_rp_plain\" id=\"wp_rp_first\"><div class=\"wp_rp_content\"><h3 class=\"related_post_title\">相关文章</h3><ul class=\"related_post wp_rp\" style=\"visibility: visible\"><li ><a href=\"http://blog.jobbole.com/71827/\" class=\"wp_rp_title\">为 OS X 开发者准备的 15 个超棒应用</a></li><li ><a href=\"http://blog.jobbole.com/63552/\" class=\"wp_rp_title\">Mac 上的 PHP/JS 项目开发工具</a></li><li ><a href=\"http://blog.jobbole.com/94972/\" class=\"wp_rp_title\">高效 Macbook 开发之道：工具篇</a></li><li ><a href=\"http://blog.jobbole.com/104019/\" class=\"wp_rp_title\">为什么很多硅谷工程师偏爱 OS X，而不是 Linux 或 Windows？</a></li><li ><a href=\"http://blog.jobbole.com/72238/\" class=\"wp_rp_title\">OS X 平台的 8 个实用终端工具</a></li><li ><a href=\"http://blog.jobbole.com/34764/\" class=\"wp_rp_title\">王垠：漫谈Linux、Windows和Mac</a></li><li ><a href=\"http://blog.jobbole.com/52811/\" class=\"wp_rp_title\">Mac用户不可或缺的10个效率工具</a></li><li ><a href=\"http://blog.jobbole.com/101403/\" class=\"wp_rp_title\">15款你可能不知道的精致Mac应用</a></li><li ><a href=\"http://blog.jobbole.com/101026/\" class=\"wp_rp_title\">Mac 下提升工作效率的方式</a></li><li ><a href=\"http://blog.jobbole.com/40278/\" class=\"wp_rp_title\">如何在安装双启动后卸载 Windows 或者 Linux</a></li></ul></div></div><p><a href=\"http://blog.jobbole.com/104138/\">开发者MAC电脑里的十八般兵器</a>，首发于<a href=\"http://blog.jobbole.com\">文章 - 伯乐在线</a>。</p>" "http://blog.jobbole.com/104138/" (22433 30537) old 1 nil nil ((title nil "开发者MAC电脑里的十八般兵器") (link nil "http://blog.jobbole.com/104138/") (comments nil "http://blog.jobbole.com/104138/#respond") (pubDate nil "Wed, 03 Aug 2016 04:47:05 +0000") (dc:creator nil "中二饼") (category nil "工具与资源") (category nil "Mac") (category nil "工具") (guid ((isPermaLink . "false")) "http://blog.jobbole.com/?p=104138") (description nil "<p>作为一名开发者，无论是移动端 (Android/iOS)，前端 (H5)，后端 (PHP/JAVA/GO) 或者全栈，运用常用工具辅助开发，提高编程，调试，以及抓八阿哥的效率。如同古人习武，十八般兵器，样样精通，方能小有成就。</p><p><a href=\"http://blog.jobbole.com/104138/\">开发者MAC电脑里的十八般兵器</a>，首发于<a href=\"http://blog.jobbole.com\">文章 - 伯乐在线</a>。</p>") (content:encoded nil "<p>古人常以刀、枪、剑、戟、斧、钺、铲、叉、鞭、锏、锤、戈、镋、棍、槊、棒、矛、钯十八种兵器，样样精通，来形容一个人的武学技能get状态。在开发者的世界里，熟练掌握各种辅助工具，可以达到事半功倍，快速提高工作效率的效果。闲话不扯了，来看看究竟是什么。</p><h1>道场</h1><p>习武学道讲经论法总有个场所，这样容易把有意向来学习的人聚集起来，而且有助于信息的传播，精力的集中，技能的修炼，经验的交流和水平高下的切磋。工具的运用也是在一个特定的开发环境里才能发挥出比较好的效果。<br />
我这里的开发环境(DOJO)是苹果公司Apple Inc.()2014年出的一款Mac Pro，具体配置如下：</p><blockquote><p>MacBook Pro（Retina 显示屏，15 英寸，2014 年中）</p><p>处理器 2.2 GHz Intel Core i7</p><p>内存 16 GB 1600 MHz DDR3</p><p>图形卡 Intel Iris Pro 1536 MB</p><p>操作系统 OS X EI Capitan</p></blockquote><p>这里描述的工具都是运行在这个硬件以及软件环境的，经过了2年多的开发经验／经历的靠谱验证，所以拿来分享给大家。</p><p>如果有朋友的研发环境和这里描述的不太一致，那么仅作参考吧，具体结合自己的情况。</p><p>为了方便检索，所以增加了工具分类。</p><p>开发第一步是做什么？学习文档？画流程图？还是直接写代码？恩，先从学习文档开始吧。</p><h1 id=\"section-1\">文档查看</h1><h3 id=\"dash\">Dash</h3><p>写代码的时候是不是有些API记不住，比如画椭圆该用哪个类？计算开平方用什么函数？怎么连接远程的mysql服务器检索数据？这个时候一般怎么办？问度娘？问谷歌？直接查看在线编程文档？</p><p>在国内问谷歌需要翻墙，那么涉及到另外工具的使用。查看在线文档，如果记不住入口网址怎么办？放收藏里啊，如果入口改变了呢？还是需要问搜索引擎啊！那么问题来了，度娘乱贴小广告咋办？用Dash吧，一个APP搜罗了这个世界上几乎所有的编程语言文档，而且更新速度快。</p><p>软件主页以及下载地址<a href=\"https://kapeli.com/dash\">https://kapeli.com/dash</a></p><h1 id=\"section-2\">流程图设计</h1><p>OmniGraffle 有很多人推荐，不过笔者觉得这个软件太贵了，所以推荐了两款免费的软件流程设计工具。</p><h3 id=\"xmind\">XMind</h3><p>主攻脑图（思维导图），流程图也支持，另外还有日程安排计划等额外的功能。</p><p>软件主页以及下载地址<a href=\"http://www.xmind.net/\">http://www.xmind.net/</a></p><h3 id=\"gliffy-diagrams\">Gliffy Diagrams</h3><p>并不是一个独立安装的APP，而是作为Chrome的插件，可以去Chrome的App Store下载安装，很轻量，运行速度快。</p><p>软件主页<a href=\"https://www.gliffy.com/\">https://www.gliffy.com/</a></p><h1 id=\"section-3\">文本编辑器</h1><p>不仅限于代码编辑，一款好的编辑器会让你的编辑工作充满愉悦。</p><h3 id=\"macvim\">MacVim</h3><p>为什么我一开始不推荐时下流行头牌Sublime呢？因为，我用vi/vim已经超过十年的时间了。当初在学校，vm/emacs二选一，我选择了更容易上手实践的vi，从此一直用它来查看／编译文本／代码。</p><p>软件主页以及下载地址<a href=\"http://macvim-dev.github.io/macvim/\">http://macvim-dev.github.io/macvim/</a></p><h3 id=\"macdown\">MacDown</h3><p>一般代码查看和编辑用Vi就够了，剩下其他的文档，恩，现在大多数文章／文档采用的<strong>MarkDown</strong>语法编写，所以用一款MarkDown编辑器就够了。比如本文的编写，我用的MacDown编辑器，文章语法采用MarkDown语法。既然是MarkDown编辑器，那么有人会提到用<strong>Mou</strong>，笔者也试用过一段时间，遇到了一些问题，比如语法支持和界面显示，后来改用MacDown，觉得各方面都支持的不错，所以一直使用。</p><p>软件主页以及下载地址<a href=\"http://macdown.uranusjr.com/\">http://macdown.uranusjr.com/</a></p><h3 id=\"sublime-text\">Sublime Text</h3><p>如果你不是一路走着linux从事开发的话，估计很难对Vi/Emacs熟悉。那么，像note++或者ultraedit这类第三方编辑器会是你比较不错的选择。相比于集成开发环境IDE的笨重，运行慢和耗内存，选择一个轻量级的编辑器是在平时比较频繁的非常规查看／编辑代码／文档时一个不错的选择。那么，以前那些用第三方编辑器的用户都去哪儿了？应该就是这个Sublime Text了吧。</p><p>软件主页以及下载地址<a href=\"http://www.sublimetext.com/\">http://www.sublimetext.com/</a></p><h1 id=\"section-4\">图片编辑器</h1><p>写文章撸代码，除了文字的处理外，还需要有美图的点缀和衬托。更多时候，图是吸引流量和眼球的一种重要手段。</p><h3 id=\"gimp\">GIMP</h3><p>为啥不用Adobe Photo Shop呢？太贵，太复杂。那么，好吧，这里笔者推荐用GIMP，PS该有的，它基本都有。</p><p>软件主页以及下载地址<a href=\"http://www.gimp.org/\">http://www.gimp.org/</a></p><h1 id=\"ide\">集成开发环境IDE</h1><p>集成开发环境一般是集编辑，编译，链接，调试，版本管理和打包发布于一体的大型开发软件。它的特点是功能丰富，上手快，易操作。缺点也显而易见，笨重，运行速度慢，需要更多的CPU，内存资源。</p><h3 id=\"eclipse\">Eclipse</h3><p>老牌万金油型集成开发环境，上手快，支持几乎所有语言，但是近几年使用人数在下滑，逐渐转向Android Studio和IntelliJ IDEA了。</p><p>软件主页以及下载地址<a href=\"http://www.eclipse.org\">http://www.eclipse.org</a></p><h3 id=\"android-studio\">Android Studio</h3><p>安卓程序猿专属开发环境。</p><p>软件主页以及下载地址<a href=\"https://developer.android.com/studio/index.html\">https://developer.android.com/studio/index.html</a></p><h3 id=\"intellij-idea\">IntelliJ IDEA</h3><p>Eclipse替代品，支持市面上大部分流行的开发语言和框架，上手快，界面更加人性化，现代集成开发环境的典范。</p><p>软件主页以及下载地址<a href=\"https://www.jetbrains.com\">https://www.jetbrains.com</a></p><h3 id=\"xcode\">Xcode</h3><p>苹果公司官方唯一指定的Object-C与Swift集成开发环境。</p><p>软件主页以及下载地址<a href=\"https://developer.apple.com/xcode/\">https://developer.apple.com/xcode/</a></p><h1 id=\"section-5\">分析调试类</h1><p>APP写好了，安装到设备，但是从网络拉取图片显示失败了，怎么破？APP打安装包后想看下包里面到底有些啥？遇到这样的问题，这个的工具可以帮助你解决上面遇到的问题。</p><h3 id=\"wireshark\">Wireshark</h3><p>老牌网络抓包利器，各种平台都可以玩耍。</p><p>软件主页以及下载地址<a href=\"https://www.wireshark.org/\">https://www.wireshark.org/</a></p><h3 id=\"tcpdump\">tcpdump</h3><p>这是一个命令行工具，可以看作是Wireshark的命令行版。</p><p>系统自带，无需额外安装。<a href=\"https://support.apple.com/en-hk/HT202013\">使用帮助</a></p><h3 id=\"charles\">Charles</h3><p>网络抓包利器加上代理功能，并支持自签名证书，所以可以用来在手机上抓取https的包。使用非常方便。付费软件，值得购买。</p><p>软件主页以及下载地址<a href=\"https://www.charlesproxy.com/\">https://www.charlesproxy.com/</a></p><h3 id=\"jd-gui\">JD-GUI</h3><p>Java的class文件反编译神器，可以从二进制class文件查看它的Java源代码。</p><p>软件主页以及下载地址<a href=\"http://jd.benow.ca/\">http://jd.benow.ca/</a></p><h3 id=\"jadx\">JADX</h3><p>JD-GUI的增强版，支持查看安卓apk/dex文件中反编译的Java源代码以及查看apk中其他文件的内容。</p><p>软件主页以及下载地址<a href=\"https://github.com/skylot/jadx\">https://github.com/skylot/jadx</a></p><h1 id=\"section-6\">版本管理</h1><p>频繁的修改，反悔，记录需要管理，所以版本管理是必须的。</p><h3 id=\"sourcetree\">SourceTree</h3><p>Atlassians出品的图形化版本管理工具，支持Git和Mercurial。</p><p>软件主页以及下载地址<a href=\"https://www.sourcetreeapp.com/\">https://www.sourcetreeapp.com/</a></p><h1 id=\"section-7\">文件共享</h1><p>从文件服务器(FTP, Samba etc.)下载资料或者上传文件到服务器上。</p><h3 id=\"filezilla\">FileZilla</h3><p>老牌Sourceforge开源文件传输软件。</p><p>软件主页以及下载地址<a href=\"https://sourceforge.net/projects/filezilla/\">https://sourceforge.net/projects/filezilla/</a></p><h1 id=\"section-8\">证书管理</h1><p>证书一般用于https加密，移动APP软件的安装文件签名。</p><h3 id=\"portecle\">Portecle</h3><p>图像化管理证书的工具。</p><p>软件主页以及下载地址<a href=\"https://sourceforge.net/projects/portecle/\">https://sourceforge.net/projects/portecle/</a></p><h1 id=\"section-9\">截屏</h1><p>截屏是强需求，没错。MAC下有截屏快捷键，只能截屏。一般用户截屏完毕后，不是马上发出去，而是做后期处理。</p><h3 id=\"snip\">snip</h3><p>截屏，编辑。</p><p>软件主页以及下载地址<a href=\"http://snip.qq.com/\">http://snip.qq.com/</a></p><h1 id=\"section-10\">数据库</h1><p>调试APP的时候，如果APP产生了数据，并且把数据保存在数据库（sqlite）中。如果想在开发主机上查看，可以用如下的工具。</p><h3 id=\"datum\">Datum</h3><p>查看sqlite数据库的内容。</p><p>软件主页以及下载地址<a href=\"http://www.datumapps.com/\">http://www.datumapps.com/</a></p><h1 id=\"section-11\">网络请求</h1><p>有时候需要自己构造一个http网络请求(GET/POST)，并查看输入输出的详细内容。简单的GET用浏览器可以代劳，复杂一点的需要浏览器安装插件支持。用如下的工具可以到达更好的效果。</p><h3 id=\"wget\">wget</h3><p>命令行工具。除了查看发送网络请求，查看结果外。另外一个用途是下载文件，特别是大文件，用浏览器下载经常会断线，而且断点续传做的不是太好。wget命令下载文件，支持断点续传，这个用起来不错。</p><h3 id=\"curl\">curl</h3><p>功能基本同wget，系统自带工具，无需安装。</p><h3 id=\"rest-client\">rest-client</h3><p>支持restful风格的网络请求构造，请求和结果相应。调试restful接口的好帮手。</p><p>软件主页以及下载地址<a href=\"https://github.com/wiztools/rest-client\">https://github.com/wiztools/rest-client</a></p><h1 id=\"section-12\">虚拟机&amp;模拟器</h1><p>我的电脑是MAC，可是招商银行的专业版没有MAC的客户端，肿么破？我想在MAC上看到安卓APP运行的情况，怎么办？安装一个虚拟机吧！</p><h3 id=\"virtualbox\">VirtualBox</h3><p>老牌虚拟机软件，支持市面上几乎所有流行的操作系统。</p><p>软件主页以及下载地址<a href=\"https://www.virtualbox.org/\">https://www.virtualbox.org/</a></p><h3>Genymotion</h3><p>安卓模拟器，运行安卓APP如同在手机上一样的速度。</p><p>软件主页以及下载地址<a href=\"https://www.genymotion.com/\">https://www.genymotion.com/</a></p><h1 id=\"mac\">MAC专用</h1><p>有些工具是MAC系统专用的，比如用来管理苹果设备(iPad, iPhone, iMac, Mac etc.)配置文件的工具。</p><h3 id=\"apple-configurator\">Apple Configurator</h3><p>上App Store自行搜索下载安装。</p><p><a href=\"http://help.apple.com/configurator/mac/2.2.1/\">使用帮助</a></p><h1 id=\"section-13\">服务端工具套件</h1><p>有时候需要本地调试一些服务端提供的服务，或者是网站后台。这个时候一个开发／调试／模拟环境的选择变的重要了。还是那句不忘初衷的话，好的工具让你事半功倍！</p><h3 id=\"bitnami\">Bitnami服务端套件</h3><p>本地调试web服务器，nginx, mysql, php-fpm, etc.</p><p>软件主页以及下载地址<a href=\"https://bitnami.com\">https://bitnami.com</a></p><h3 id=\"kitematic\">Kitematic</h3><p>Docker图形化管理工具。</p><p>软件主页以及下载地址<a href=\"https://kitematic.com/\">https://kitematic.com/</a></p><h1 id=\"section-14\">科学上网利器</h1><p>我要上谷歌搜索最新的Android开发文档和API，可是目前在国内用不了谷歌，怎么办？翻墙吧！</p><h3 id=\"shadowsocksx\">ShadowsocksX</h3><p>看标题，不多说，默默的下载，安装然后运行，配置，打开浏览器，访问谷歌，搜索Android就可以啦！</p><p>软件主页以及下载地址<a href=\"https://sourceforge.net/projects/shadowsocksgui/\">https://sourceforge.net/projects/shadowsocksgui/</a></p><h3 id=\"lantern\">Lantern</h3><p>如果上面那个不行，那么试试这个吧，不多说了。</p><p>软件主页以及下载地址<a href=\"https://github.com/getlantern/lantern\">https://github.com/getlantern/lantern</a></p><p></p><div class=\"wp_rp_wrap  wp_rp_plain\" id=\"wp_rp_first\"><div class=\"wp_rp_content\"><h3 class=\"related_post_title\">相关文章</h3><ul class=\"related_post wp_rp\" style=\"visibility: visible\"><li ><a href=\"http://blog.jobbole.com/71827/\" class=\"wp_rp_title\">为 OS X 开发者准备的 15 个超棒应用</a></li><li ><a href=\"http://blog.jobbole.com/63552/\" class=\"wp_rp_title\">Mac 上的 PHP/JS 项目开发工具</a></li><li ><a href=\"http://blog.jobbole.com/94972/\" class=\"wp_rp_title\">高效 Macbook 开发之道：工具篇</a></li><li ><a href=\"http://blog.jobbole.com/104019/\" class=\"wp_rp_title\">为什么很多硅谷工程师偏爱 OS X，而不是 Linux 或 Windows？</a></li><li ><a href=\"http://blog.jobbole.com/72238/\" class=\"wp_rp_title\">OS X 平台的 8 个实用终端工具</a></li><li ><a href=\"http://blog.jobbole.com/34764/\" class=\"wp_rp_title\">王垠：漫谈Linux、Windows和Mac</a></li><li ><a href=\"http://blog.jobbole.com/52811/\" class=\"wp_rp_title\">Mac用户不可或缺的10个效率工具</a></li><li ><a href=\"http://blog.jobbole.com/101403/\" class=\"wp_rp_title\">15款你可能不知道的精致Mac应用</a></li><li ><a href=\"http://blog.jobbole.com/101026/\" class=\"wp_rp_title\">Mac 下提升工作效率的方式</a></li><li ><a href=\"http://blog.jobbole.com/40278/\" class=\"wp_rp_title\">如何在安装双启动后卸载 Windows 或者 Linux</a></li></ul></div></div><p><a href=\"http://blog.jobbole.com/104138/\">开发者MAC电脑里的十八般兵器</a>，首发于<a href=\"http://blog.jobbole.com\">文章 - 伯乐在线</a>。</p>") (wfw:commentRss nil "http://blog.jobbole.com/104138/feed/") (slash:comments nil "0"))) ("18 个锻炼编程技能的网站" "<p dir=\"ltr\">编程几乎已经成为了人类所知每个行业的必要组成部分，它帮助组织和维护大型系统的方式是无可比拟的，所以越来越多的人开始了他们的编程之旅。</p><p>要学习编程，你可以通过交互式平台或者书本，随便一种你觉得最适合和容易的学习方式。但是，有时候这样还不够，我们想要练习一些新的东西。</p><p>编程最很大程度上是关于创造力，是你产生新鲜有趣想法的能力。但是，有时候因为在处理普通问题上花去了大量时间，我们都忘记了创造力。我不是很肯定这是不是编程挑战产生的原因，但它们一定可以帮你想出自己的想法来编程。</p><p>可以说，编程挑战可以极好地：</p><ul><li>学习另辟蹊径地完成事情</li><li>练习一种新的编程语言</li><li>遇到关键问题进行解决</li><li>保持我们的大脑敏锐且专注</li><li>玩得开心！</li></ul><p>在我寻找最好的编程挑战的过程中，我把列表缩小到五个好资源。相信它们可以在你的编程之旅中极大地帮助你，或者可以满足学习和探索计算机科学更多领域的目的。</p><h2><a href=\"http://www.topcoder.com/\" target=\"_blank\">[topcoder]</a></h2><p><img id=\"pic\" class=\" \" src=\"http://ww2.sinaimg.cn/large/7cc829d3gw1f6geln0fdmj20m80aojtx.jpg\" /></p><p dir=\"ltr\">你能赚到真金白银，而且它被近一百万程序员所支持，所以我很肯定一定能遇到许多有挑战性的东西。我这么说，是因为我相信有些刚起步的编程爱好者可能会觉得topcoder比较难。</p><p dir=\"ltr\">可以参加每天或者每周的编程挑战，两者都极其困难，而且需要非常好的思维技巧来完成。但这是值得的，因为它最终会为你的简历增色不少。</p><h2><a href=\"http://www.hackerearth.com/\" target=\"_blank\">HackerEarth</a></h2><p><img id=\"pic\" class=\" \" src=\"http://ww1.sinaimg.cn/large/7cc829d3gw1f6gelo4b1oj20m80aoac2.jpg\" /></p><p dir=\"ltr\">HackerEarth提供一种软件即服务应用（SaaS），来对应试者的技术和逻辑能力进行自动评估。作为一个整合和挑选开发者的平台，它也帮助企业招才纳贤。</p><p dir=\"ltr\">它们经常添加挑战，你可以提前几个星期注册，这样可以在你要参加之前提前准备和了解。和TopCoder一样，这是一个高质量的网站，提供需要深思熟虑的挑战，而且也证实以后会对你的事业有所裨益。</p><h2><a href=\"http://coderbyte.com/\" target=\"_blank\">Coderbyte</a></h2><p><img id=\"pic\" class=\" \" src=\"http://ww2.sinaimg.cn/large/7cc829d3gw1f6gelovj3wj20m80b3jsi.jpg\" /></p><p dir=\"ltr\">Coderbyte是Kickstarter资助的项目（虽然，它本身在这项运动之前就已经存在了），而且它针对完全的初学者和类似中级程序员。</p><p dir=\"ltr\">它是由Daniel Borowski在2012年发起的，而且此后发展成一个由喜欢在空闲时间解决编程问题的程序员们自行维护的社区。</p><p dir=\"ltr\">如果有什么不明白的，你也可以提问，这个社区也是比较活跃的。所以你应该很有可能得到答案。很多人都热爱Coderbyte，我看到的全部都是正面评价。</p><h2><a href=\"https://projecteuler.net/\" target=\"_blank\">Project Euler</a></h2><p><img id=\"pic\" class=\" \" src=\"http://ww4.sinaimg.cn/large/7cc829d3gw1f6gelqt4rfj20m80b3whg.jpg\" /></p><p dir=\"ltr\">Project Euler大概是世界上最受欢迎的编程挑战网站，而且自从十多年前推出之后，就成为了成千上万用户的家园。你可以每周添加一个额外的挑战，不过我敢肯定，要想搞定已经在等待解决的450多个问题已经要花点时间了。</p><p dir=\"ltr\">它们设立得并不是很难，反而更加需要关键的思考和解决问题，以此来帮助你成长和学习你所使用的语言。这一切都是为了锻炼你进步，确保你充分理解自己在做什么。</p><p dir=\"ltr\">你可以从<a href=\"http://en.wikipedia.org/wiki/Project_Euler\" target=\"_blank\">Wikipedia</a>、<a href=\"http://www.reddit.com/r/projecteuler/\" target=\"_blank\">Reddit</a>、<a href=\"http://stackoverflow.com/questions/tagged/project-euler\" target=\"_blank\">Stack Overflow</a> 和 <a href=\"https://code.google.com/p/projecteuler-solutions/\" target=\"_blank\">Google Code</a>.上更多地了解Project Euler。</p><h2><a href=\"http://www.reddit.com/r/dailyprogrammer\" target=\"_blank\">Daily Programmer</a></h2><p><img id=\"pic\" class=\" \" src=\"http://ww1.sinaimg.cn/large/7cc829d3gw1f6geltnxsyj20m80b3aer.jpg\" /></p><p dir=\"ltr\">我们要用我个人的最爱来做个总结：Reddit的Daily Programmer。如果你想更多地学习语言和解决问题，这是一个极精彩的值得加入的讨论区。我想以它目前的状态，你可以每周解决三个独特的问题。</p><p dir=\"ltr\">更不用说已经有数百个可以解决了。你在评论里创造的每次提交都会被社区成员查看，所以你可以得到关于你解法的意见和答案。</p><p dir=\"ltr\">强力推荐。</p><p dir=\"ltr\"><a href=\"https://codility.com/train/\" target=\"_blank\">Codility Train</a></p><p><img id=\"pic\" class=\" \" src=\"http://ww1.sinaimg.cn/large/7cc829d3gw1f6gelvtqlbj20m80ao769.jpg\" /></p><p dir=\"ltr\">你可以得到多个提前订制和提前思考过的挑战，而且可以用多种编程语言提交。它们都按照合适的难度排序了，大概有40-50个可以查看。</p><p dir=\"ltr\">每一个都详细解释了最终程序应该做什么，而且据我所见－每一个也都有时间限制，所以不能松懈！</p><h2><a href=\"http://www.spoj.com/\" target=\"_blank\">SPOJ</a></h2><p><img id=\"pic\" class=\" \" src=\"http://ww2.sinaimg.cn/large/7cc829d3gw1f6gelxmy0kj20m80aoq51.jpg\" /></p><p dir=\"ltr\">Sphere Online Judge是一个有成千上万个可以让你成天解决的编程挑战所组成的社区。它支持输入所有你可以想到的编程语言，而且在它背后还有一个优秀社区始终如一地有效帮助着社区的论坛。</p><h2><a href=\"http://www.codechef.com/\" target=\"_blank\">CodeChef</a></h2><p><img id=\"pic\" class=\" \" src=\"http://ww3.sinaimg.cn/large/7cc829d3gw1f6gelzkfy3j20m80b3gnp.jpg\" /></p><p dir=\"ltr\">CodeChef是由Directi创造的，作为一种挑战和参与开发者社区的方法，同时也提供一个练习、竞争和提高的平台。它由一大堆待解决的问题所驱动，而且你可以得到别人解决已知编程挑战的源代码。</p><p dir=\"ltr\">它被分成了几个难度等级，而且网站本身是一个大小合理的社区。看起来真的是一个很棒的挑战网站。</p><h2><a href=\"https://www.codeeval.com/\" target=\"_blank\">CodeEval</a></h2><p><img id=\"pic\" class=\" \" src=\"http://ww1.sinaimg.cn/large/7cc829d3gw1f6gem3153qj20m80b3tan.jpg\" /></p><p dir=\"ltr\">作为一个希望向雇主和其他开发者展示自己编程技巧的开发者，你可以加入CodeEval。你要参与和加入几个不同地区的竞赛，但大部分是建立一个产品或者应用，并得到现金奖励作为回报。同时，你可以参与编程挑战，可以在解决之后加到你未来的简历上，给你的潜在雇主留下良好的第一印象。</p><p dir=\"ltr\">它致力于帮助开发者们宣传他们在自己工作领域的经验，而且看起来做得非常好。</p><h2><a href=\"https://www.hackerrank.com/\" target=\"_blank\">HackerRank</a></h2><p><img id=\"pic\" class=\" \" src=\"http://ww1.sinaimg.cn/large/7cc829d3gw1f6gemagor2j20m80ao411.jpg\" /></p><p dir=\"ltr\">我立刻就喜欢上HackerRank的是它关于人工智能的那部分挑战，它们非常酷，而且让高级程序员也有东西可以玩。它的背后是Y Combinator、SVAngel和许多其他公司。绝对有很多黑客在攻克这些。</p><h2><a href=\"http://www.talentbuddy.co/\" target=\"_blank\">Talentbuddy</a></h2><p dir=\"ltr\">Talentbuddy是一个友好的地方，你可以通过有趣的面向面试的方法，来练习解决问题的能力。我想你也许会觉得这个网站关于人际交往的部分稍微有一点烦人，但是总的来说它有一些非常好的可以学习的课程，甚至还有MongoDB的东西可以练习－能看到高级的挑战总是好的！</p><h2><a href=\"http://www.codewars.com/\" target=\"_blank\">Codewars</a></h2><p><img id=\"pic\" class=\" \" src=\"http://ww1.sinaimg.cn/large/7cc829d3gw1f6gemes3o4j20m80b3wgi.jpg\" /></p><p dir=\"ltr\">Codewars有一个很好的编程挑战的方法，而且很认真地对待他们的作品。我试着找到正确的词语来形容它，不过这里有Codewars提供的一段十分钟的介绍视频。</p><p dir=\"ltr\">我觉得你会喜欢它的，就像社区里很多开发者已经喜欢的那样。</p><h2><a href=\"http://rosalind.info/problems/locations/\" target=\"_blank\">Rosalind</a></h2><p><img id=\"pic\" class=\" \" src=\"http://ww2.sinaimg.cn/large/7cc829d3gw1f6gemfdaotj20m80b3goc.jpg\" /></p><p dir=\"ltr\">这是个稍微比较特别的方法，但仍然不失是一个很棒的解决和学习编程问题的方法。Rosalind提供一些关于生物信息学的挑战，你可以按照自己的节奏来解决。</p><h2><a href=\"http://fightcodegame.com/\" target=\"_blank\">FightCode</a></h2><p><img id=\"pic\" class=\" \" src=\"http://ww4.sinaimg.cn/large/7cc829d3gw1f6gemhq5wkj20m80b3dht.jpg\" /></p><p dir=\"ltr\">你可以编写你自己的机器人，然后用它们来和社区里的其他成员比拼。它是一种“即编即用”型的平台，但如果是初学这种方法或者只是想找点乐趣，它还是非常有用的。试试看这些文档，好更了解它一些。</p><h2><a href=\"http://codeforces.com/\" target=\"_blank\">Codeforces</a></h2><p><img id=\"pic\" class=\" \" src=\"http://ww1.sinaimg.cn/large/7cc829d3gw1f6gemi904ej20m80ao40t.jpg\" /></p><h2><a href=\"http://exercism.io/\" target=\"_blank\">Exercism</a></h2><p><img id=\"pic\" class=\" \" src=\"http://ww1.sinaimg.cn/large/7cc829d3gw1f6gemjgej9j20m80aoab4.jpg\" /></p><h2><a href=\"https://www.kaggle.com/\" target=\"_blank\">Kaggle</a></h2><p><img id=\"pic\" class=\" \" src=\"http://ww1.sinaimg.cn/large/7cc829d3gw1f6gemktimmj20m80aomy8.jpg\" /></p><h2><a title=\" \" href=\"https://www.codingame.com/start\" target=\"_blank\">CodinGame</a></h2><p>CodinGame 对程序员来说是一个巨大的挑战，如果你想提升编程技能，玩CodinGame是一种有趣的方式。</p><p><img id=\"pic\" class=\" \" src=\"http://ww3.sinaimg.cn/large/7cc829d3gw1f6gemlqi5dj20m80aotbj.jpg\" /></p><h3>更多 → 《<a href=\"http://blog.jobbole.com/100733/\" target=\"_blank\">一大波能提高编程技能的游戏</a>》</h3><p>上面哪一个，可以算是你自己的最爱？</p><div class=\"wp_rp_wrap  wp_rp_plain\" ><div class=\"wp_rp_content\"><h3 class=\"related_post_title\">相关文章</h3><ul class=\"related_post wp_rp\" style=\"visibility: visible\"><li ><a href=\"http://blog.jobbole.com/103116/\" class=\"wp_rp_title\">游戏服务端究竟解决了什么问题？</a></li><li ><a href=\"http://blog.jobbole.com/35711/\" class=\"wp_rp_title\">换种方式学编程：如何训练你的机器人</a></li><li ><a href=\"http://blog.jobbole.com/60389/\" class=\"wp_rp_title\">CodeCombat：玩游戏就能学会编程</a></li><li ><a href=\"http://blog.jobbole.com/41204/\" class=\"wp_rp_title\">伯乐在线编程挑战第 0 期 – 呼叫转移系统</a></li><li ><a href=\"http://blog.jobbole.com/41216/\" class=\"wp_rp_title\">伯乐在线编程挑战简介</a></li><li ><a href=\"http://blog.jobbole.com/76930/\" class=\"wp_rp_title\">来自 Mozilla 的 HTML5 游戏开发资源</a></li><li ><a href=\"http://blog.jobbole.com/49786/\" class=\"wp_rp_title\">教孩子们编程，相关学习资源</a></li><li ><a href=\"http://blog.jobbole.com/77291/\" class=\"wp_rp_title\">教孩子学习编程基础知识的 10 个工具</a></li><li ><a href=\"http://blog.jobbole.com/100733/\" class=\"wp_rp_title\">一大波能提高编程技能的游戏</a></li><li ><a href=\"http://blog.jobbole.com/22883/\" class=\"wp_rp_title\">百行 HTML5 代码实现四种双人对弈游戏</a></li></ul></div></div><p><a href=\"http://blog.jobbole.com/67820/\">18 个锻炼编程技能的网站</a>，首发于<a href=\"http://blog.jobbole.com\">文章 - 伯乐在线</a>。</p>" "http://blog.jobbole.com/67820/" (22433 29216) old 2 nil nil ((title nil "18 个锻炼编程技能的网站") (link nil "http://blog.jobbole.com/67820/") (comments nil "http://blog.jobbole.com/67820/#respond") (pubDate nil "Wed, 03 Aug 2016 04:25:04 +0000") (dc:creator nil "Reset") (category nil "工具与资源") (category nil "游戏") (category nil "编程") (category nil "编程挑战") (guid ((isPermaLink . "false")) "http://blog.jobbole.com/?p=67820") (description nil "<p>要学习编程，你可以通过交互式平台或者书本，随便一种你觉得最适合和容易的学习方式。但是，有时候这样还不够，我们想要练习一些新的东西。</p><p><a href=\"http://blog.jobbole.com/67820/\">18 个锻炼编程技能的网站</a>，首发于<a href=\"http://blog.jobbole.com\">文章 - 伯乐在线</a>。</p>") (content:encoded nil "<p dir=\"ltr\">编程几乎已经成为了人类所知每个行业的必要组成部分，它帮助组织和维护大型系统的方式是无可比拟的，所以越来越多的人开始了他们的编程之旅。</p><p>要学习编程，你可以通过交互式平台或者书本，随便一种你觉得最适合和容易的学习方式。但是，有时候这样还不够，我们想要练习一些新的东西。</p><p>编程最很大程度上是关于创造力，是你产生新鲜有趣想法的能力。但是，有时候因为在处理普通问题上花去了大量时间，我们都忘记了创造力。我不是很肯定这是不是编程挑战产生的原因，但它们一定可以帮你想出自己的想法来编程。</p><p>可以说，编程挑战可以极好地：</p><ul><li>学习另辟蹊径地完成事情</li><li>练习一种新的编程语言</li><li>遇到关键问题进行解决</li><li>保持我们的大脑敏锐且专注</li><li>玩得开心！</li></ul><p>在我寻找最好的编程挑战的过程中，我把列表缩小到五个好资源。相信它们可以在你的编程之旅中极大地帮助你，或者可以满足学习和探索计算机科学更多领域的目的。</p><h2><a href=\"http://www.topcoder.com/\" target=\"_blank\">[topcoder]</a></h2><p><img id=\"pic\" class=\" \" src=\"http://ww2.sinaimg.cn/large/7cc829d3gw1f6geln0fdmj20m80aojtx.jpg\" /></p><p dir=\"ltr\">你能赚到真金白银，而且它被近一百万程序员所支持，所以我很肯定一定能遇到许多有挑战性的东西。我这么说，是因为我相信有些刚起步的编程爱好者可能会觉得topcoder比较难。</p><p dir=\"ltr\">可以参加每天或者每周的编程挑战，两者都极其困难，而且需要非常好的思维技巧来完成。但这是值得的，因为它最终会为你的简历增色不少。</p><h2><a href=\"http://www.hackerearth.com/\" target=\"_blank\">HackerEarth</a></h2><p><img id=\"pic\" class=\" \" src=\"http://ww1.sinaimg.cn/large/7cc829d3gw1f6gelo4b1oj20m80aoac2.jpg\" /></p><p dir=\"ltr\">HackerEarth提供一种软件即服务应用（SaaS），来对应试者的技术和逻辑能力进行自动评估。作为一个整合和挑选开发者的平台，它也帮助企业招才纳贤。</p><p dir=\"ltr\">它们经常添加挑战，你可以提前几个星期注册，这样可以在你要参加之前提前准备和了解。和TopCoder一样，这是一个高质量的网站，提供需要深思熟虑的挑战，而且也证实以后会对你的事业有所裨益。</p><h2><a href=\"http://coderbyte.com/\" target=\"_blank\">Coderbyte</a></h2><p><img id=\"pic\" class=\" \" src=\"http://ww2.sinaimg.cn/large/7cc829d3gw1f6gelovj3wj20m80b3jsi.jpg\" /></p><p dir=\"ltr\">Coderbyte是Kickstarter资助的项目（虽然，它本身在这项运动之前就已经存在了），而且它针对完全的初学者和类似中级程序员。</p><p dir=\"ltr\">它是由Daniel Borowski在2012年发起的，而且此后发展成一个由喜欢在空闲时间解决编程问题的程序员们自行维护的社区。</p><p dir=\"ltr\">如果有什么不明白的，你也可以提问，这个社区也是比较活跃的。所以你应该很有可能得到答案。很多人都热爱Coderbyte，我看到的全部都是正面评价。</p><h2><a href=\"https://projecteuler.net/\" target=\"_blank\">Project Euler</a></h2><p><img id=\"pic\" class=\" \" src=\"http://ww4.sinaimg.cn/large/7cc829d3gw1f6gelqt4rfj20m80b3whg.jpg\" /></p><p dir=\"ltr\">Project Euler大概是世界上最受欢迎的编程挑战网站，而且自从十多年前推出之后，就成为了成千上万用户的家园。你可以每周添加一个额外的挑战，不过我敢肯定，要想搞定已经在等待解决的450多个问题已经要花点时间了。</p><p dir=\"ltr\">它们设立得并不是很难，反而更加需要关键的思考和解决问题，以此来帮助你成长和学习你所使用的语言。这一切都是为了锻炼你进步，确保你充分理解自己在做什么。</p><p dir=\"ltr\">你可以从<a href=\"http://en.wikipedia.org/wiki/Project_Euler\" target=\"_blank\">Wikipedia</a>、<a href=\"http://www.reddit.com/r/projecteuler/\" target=\"_blank\">Reddit</a>、<a href=\"http://stackoverflow.com/questions/tagged/project-euler\" target=\"_blank\">Stack Overflow</a> 和 <a href=\"https://code.google.com/p/projecteuler-solutions/\" target=\"_blank\">Google Code</a>.上更多地了解Project Euler。</p><h2><a href=\"http://www.reddit.com/r/dailyprogrammer\" target=\"_blank\">Daily Programmer</a></h2><p><img id=\"pic\" class=\" \" src=\"http://ww1.sinaimg.cn/large/7cc829d3gw1f6geltnxsyj20m80b3aer.jpg\" /></p><p dir=\"ltr\">我们要用我个人的最爱来做个总结：Reddit的Daily Programmer。如果你想更多地学习语言和解决问题，这是一个极精彩的值得加入的讨论区。我想以它目前的状态，你可以每周解决三个独特的问题。</p><p dir=\"ltr\">更不用说已经有数百个可以解决了。你在评论里创造的每次提交都会被社区成员查看，所以你可以得到关于你解法的意见和答案。</p><p dir=\"ltr\">强力推荐。</p><p dir=\"ltr\"><a href=\"https://codility.com/train/\" target=\"_blank\">Codility Train</a></p><p><img id=\"pic\" class=\" \" src=\"http://ww1.sinaimg.cn/large/7cc829d3gw1f6gelvtqlbj20m80ao769.jpg\" /></p><p dir=\"ltr\">你可以得到多个提前订制和提前思考过的挑战，而且可以用多种编程语言提交。它们都按照合适的难度排序了，大概有40-50个可以查看。</p><p dir=\"ltr\">每一个都详细解释了最终程序应该做什么，而且据我所见－每一个也都有时间限制，所以不能松懈！</p><h2><a href=\"http://www.spoj.com/\" target=\"_blank\">SPOJ</a></h2><p><img id=\"pic\" class=\" \" src=\"http://ww2.sinaimg.cn/large/7cc829d3gw1f6gelxmy0kj20m80aoq51.jpg\" /></p><p dir=\"ltr\">Sphere Online Judge是一个有成千上万个可以让你成天解决的编程挑战所组成的社区。它支持输入所有你可以想到的编程语言，而且在它背后还有一个优秀社区始终如一地有效帮助着社区的论坛。</p><h2><a href=\"http://www.codechef.com/\" target=\"_blank\">CodeChef</a></h2><p><img id=\"pic\" class=\" \" src=\"http://ww3.sinaimg.cn/large/7cc829d3gw1f6gelzkfy3j20m80b3gnp.jpg\" /></p><p dir=\"ltr\">CodeChef是由Directi创造的，作为一种挑战和参与开发者社区的方法，同时也提供一个练习、竞争和提高的平台。它由一大堆待解决的问题所驱动，而且你可以得到别人解决已知编程挑战的源代码。</p><p dir=\"ltr\">它被分成了几个难度等级，而且网站本身是一个大小合理的社区。看起来真的是一个很棒的挑战网站。</p><h2><a href=\"https://www.codeeval.com/\" target=\"_blank\">CodeEval</a></h2><p><img id=\"pic\" class=\" \" src=\"http://ww1.sinaimg.cn/large/7cc829d3gw1f6gem3153qj20m80b3tan.jpg\" /></p><p dir=\"ltr\">作为一个希望向雇主和其他开发者展示自己编程技巧的开发者，你可以加入CodeEval。你要参与和加入几个不同地区的竞赛，但大部分是建立一个产品或者应用，并得到现金奖励作为回报。同时，你可以参与编程挑战，可以在解决之后加到你未来的简历上，给你的潜在雇主留下良好的第一印象。</p><p dir=\"ltr\">它致力于帮助开发者们宣传他们在自己工作领域的经验，而且看起来做得非常好。</p><h2><a href=\"https://www.hackerrank.com/\" target=\"_blank\">HackerRank</a></h2><p><img id=\"pic\" class=\" \" src=\"http://ww1.sinaimg.cn/large/7cc829d3gw1f6gemagor2j20m80ao411.jpg\" /></p><p dir=\"ltr\">我立刻就喜欢上HackerRank的是它关于人工智能的那部分挑战，它们非常酷，而且让高级程序员也有东西可以玩。它的背后是Y Combinator、SVAngel和许多其他公司。绝对有很多黑客在攻克这些。</p><h2><a href=\"http://www.talentbuddy.co/\" target=\"_blank\">Talentbuddy</a></h2><p dir=\"ltr\">Talentbuddy是一个友好的地方，你可以通过有趣的面向面试的方法，来练习解决问题的能力。我想你也许会觉得这个网站关于人际交往的部分稍微有一点烦人，但是总的来说它有一些非常好的可以学习的课程，甚至还有MongoDB的东西可以练习－能看到高级的挑战总是好的！</p><h2><a href=\"http://www.codewars.com/\" target=\"_blank\">Codewars</a></h2><p><img id=\"pic\" class=\" \" src=\"http://ww1.sinaimg.cn/large/7cc829d3gw1f6gemes3o4j20m80b3wgi.jpg\" /></p><p dir=\"ltr\">Codewars有一个很好的编程挑战的方法，而且很认真地对待他们的作品。我试着找到正确的词语来形容它，不过这里有Codewars提供的一段十分钟的介绍视频。</p><p dir=\"ltr\">我觉得你会喜欢它的，就像社区里很多开发者已经喜欢的那样。</p><h2><a href=\"http://rosalind.info/problems/locations/\" target=\"_blank\">Rosalind</a></h2><p><img id=\"pic\" class=\" \" src=\"http://ww2.sinaimg.cn/large/7cc829d3gw1f6gemfdaotj20m80b3goc.jpg\" /></p><p dir=\"ltr\">这是个稍微比较特别的方法，但仍然不失是一个很棒的解决和学习编程问题的方法。Rosalind提供一些关于生物信息学的挑战，你可以按照自己的节奏来解决。</p><h2><a href=\"http://fightcodegame.com/\" target=\"_blank\">FightCode</a></h2><p><img id=\"pic\" class=\" \" src=\"http://ww4.sinaimg.cn/large/7cc829d3gw1f6gemhq5wkj20m80b3dht.jpg\" /></p><p dir=\"ltr\">你可以编写你自己的机器人，然后用它们来和社区里的其他成员比拼。它是一种“即编即用”型的平台，但如果是初学这种方法或者只是想找点乐趣，它还是非常有用的。试试看这些文档，好更了解它一些。</p><h2><a href=\"http://codeforces.com/\" target=\"_blank\">Codeforces</a></h2><p><img id=\"pic\" class=\" \" src=\"http://ww1.sinaimg.cn/large/7cc829d3gw1f6gemi904ej20m80ao40t.jpg\" /></p><h2><a href=\"http://exercism.io/\" target=\"_blank\">Exercism</a></h2><p><img id=\"pic\" class=\" \" src=\"http://ww1.sinaimg.cn/large/7cc829d3gw1f6gemjgej9j20m80aoab4.jpg\" /></p><h2><a href=\"https://www.kaggle.com/\" target=\"_blank\">Kaggle</a></h2><p><img id=\"pic\" class=\" \" src=\"http://ww1.sinaimg.cn/large/7cc829d3gw1f6gemktimmj20m80aomy8.jpg\" /></p><h2><a title=\" \" href=\"https://www.codingame.com/start\" target=\"_blank\">CodinGame</a></h2><p>CodinGame 对程序员来说是一个巨大的挑战，如果你想提升编程技能，玩CodinGame是一种有趣的方式。</p><p><img id=\"pic\" class=\" \" src=\"http://ww3.sinaimg.cn/large/7cc829d3gw1f6gemlqi5dj20m80aotbj.jpg\" /></p><h3>更多 → 《<a href=\"http://blog.jobbole.com/100733/\" target=\"_blank\">一大波能提高编程技能的游戏</a>》</h3><p>上面哪一个，可以算是你自己的最爱？</p><div class=\"wp_rp_wrap  wp_rp_plain\" ><div class=\"wp_rp_content\"><h3 class=\"related_post_title\">相关文章</h3><ul class=\"related_post wp_rp\" style=\"visibility: visible\"><li ><a href=\"http://blog.jobbole.com/103116/\" class=\"wp_rp_title\">游戏服务端究竟解决了什么问题？</a></li><li ><a href=\"http://blog.jobbole.com/35711/\" class=\"wp_rp_title\">换种方式学编程：如何训练你的机器人</a></li><li ><a href=\"http://blog.jobbole.com/60389/\" class=\"wp_rp_title\">CodeCombat：玩游戏就能学会编程</a></li><li ><a href=\"http://blog.jobbole.com/41204/\" class=\"wp_rp_title\">伯乐在线编程挑战第 0 期 &#8211; 呼叫转移系统</a></li><li ><a href=\"http://blog.jobbole.com/41216/\" class=\"wp_rp_title\">伯乐在线编程挑战简介</a></li><li ><a href=\"http://blog.jobbole.com/76930/\" class=\"wp_rp_title\">来自 Mozilla 的 HTML5 游戏开发资源</a></li><li ><a href=\"http://blog.jobbole.com/49786/\" class=\"wp_rp_title\">教孩子们编程，相关学习资源</a></li><li ><a href=\"http://blog.jobbole.com/77291/\" class=\"wp_rp_title\">教孩子学习编程基础知识的 10 个工具</a></li><li ><a href=\"http://blog.jobbole.com/100733/\" class=\"wp_rp_title\">一大波能提高编程技能的游戏</a></li><li ><a href=\"http://blog.jobbole.com/22883/\" class=\"wp_rp_title\">百行 HTML5 代码实现四种双人对弈游戏</a></li></ul></div></div><p><a href=\"http://blog.jobbole.com/67820/\">18 个锻炼编程技能的网站</a>，首发于<a href=\"http://blog.jobbole.com\">文章 - 伯乐在线</a>。</p>") (wfw:commentRss nil "http://blog.jobbole.com/67820/feed/") (slash:comments nil "0"))))